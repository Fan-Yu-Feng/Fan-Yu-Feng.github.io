<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代码格式化</title>
    <url>/2021/11/24/code-format/</url>
    <content><![CDATA[<p>书写代码的规范无论对团队还是个人来说都是至关重要的，写代码的过程中，有时候多余的空格、符号等需要修改，有时候心有余而力不足，大量的空格和缩进会消耗你的耐心。这时候可以通过 Idea 插件的相关配置来进行自动化的配置。</p>
<p>代码规范具体可以查看 《阿里巴巴开发手册》</p>
<a id="more"></a>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>一开始使用快捷键注释时，总是在行首时进行注释 //，需要进行调整，显得很麻烦，如图，在 <code>setting -&gt; code style -&gt; java -&gt; Code Generation</code> 设置。然后注释时按下快捷键 <code>ctrl+/</code>就可以了。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241541394.png" alt="image-20211124154156201"></p>
<h3 id="代码保存格式化（插件的形式）"><a href="#代码保存格式化（插件的形式）" class="headerlink" title="代码保存格式化（插件的形式）"></a>代码保存格式化（插件的形式）</h3><h4 id="安装-google-java-format"><a href="#安装-google-java-format" class="headerlink" title="安装 google-java-format"></a>安装 google-java-format</h4><blockquote>
<p>setting -&gt; plugin  搜索  google-java-format</p>
</blockquote>
<p>在 idea 中的插件中心搜索 google-java-format, 安装。安装好，如下图所示，启用该代码格式化工具。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241548012.png" alt="image-20211124154853869"></p>
<h4 id="安装-save-action"><a href="#安装-save-action" class="headerlink" title="安装 save-action"></a>安装 save-action</h4><blockquote>
<p>setting -&gt; plugin 搜索 save-action</p>
</blockquote>
<p>启用该工具。保存时自动格式化，将没用的import 语句删除</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241600188.png" alt="image-20211124160042086"></p>
<h4 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h4><p>优化自动导入</p>
<blockquote>
<p>setting -&gt; Editor-&gt;General -&gt; Auto Import</p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241601762.png" alt="image-20211124160157676"></p>
<p>行分隔符需要统一，不要使用 windows 的字符解析</p>
<blockquote>
<p>setting -&gt; Editor-&gt; Code Style </p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241603047.png" alt="image-20211124160337884"></p>
<p>检查缩进，统一代码缩进。</p>
<blockquote>
<p>setting -&gt; Editor-&gt; Code Style -&gt; Java </p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241602279.png" alt="image-20211124160255166"></p>
<p>启动安装的配置 </p>
<p>1、google-java-format-settings</p>
<blockquote>
<p>setting -&gt; others settings -&gt; google-java-format-settings</p>
</blockquote>
<p>找到该配置启用既可</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112221807956.png" alt="image-20211222180550677"></p>
<p>2、save-action</p>
<blockquote>
<p>setting -&gt; others settings -&gt; save-action </p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112221806019.png" alt="image-20211222180632702"></p>
]]></content>
      <categories>
        <category>格式化</category>
      </categories>
      <tags>
        <tag>代码格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu 环境搭建</title>
    <url>/2021/12/29/CMU/CMU-Lab0/</url>
    <content><![CDATA[<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112311149965.jpg" alt="CMU数据库（15-445）Lab1-BufferPoolManager"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 这里开始记录学习 CMU15-445 实现数据库的过程。学习数据库的实现过程，扩宽自己的知识面。</p>
<p> 期望：学习完该课程，期望能对数据库有个比较深入的了解，同时，对 C++ 也有个比较全面的认识。</p>
<a id="more"></a>

<p>以下是课程地址，有 note 和 homework 以及实验的 pdf 等资料。</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2020/index.html">课程地址 2020</a></p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2019/">课程地址 2019</a></p>
<p><a href="https://github.com/cmu-db/bustub">Github 地址 </a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="个人需求"><a href="#个人需求" class="headerlink" title="个人需求"></a>个人需求</h3><p> 由于公司和自己电脑是不同的环境，期望搭建一个线上的环境进行实现，方便在不同电脑上进行同步的环境进行实验，这里我使用 Docker 来进行线上环境的搭建，个人开发者可以直接上传个性化的容器。</p>
<h3 id="仓库搭建"><a href="#仓库搭建" class="headerlink" title="仓库搭建"></a>仓库搭建</h3><p>1、在 Github 上创建名为 bustub-private 的仓库，并设置该仓库为 Private</p>
<p>2、拉取代码到本地，名为 bustub-public</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --bare https://github.com/cmu-db/bustub.git bustub-public</span><br></pre></td></tr></table></figure>

<p>3、上传代码到你的 Github 仓库上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bustub-public</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> student 为用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTPS 方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --mirror https://github.com/student/bustub-private.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SSH 方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --mirror git@github.com:student/bustub-private.git</span></span><br></pre></td></tr></table></figure>

<p>4、删除本地仓库，拉取自己账号的仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> rm -rf bustub-public</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTPS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/student/bustub-private.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SSH</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:student/bustub-private.git</span></span><br></pre></td></tr></table></figure>

<p>5、添加 CMU 仓库为远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add public https://github.com/cmu-db/bustub.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证一下远程是否添加成功</span></span><br><span class="line">git remote -v</span><br><span class="line">origin    https://github.com/student/bustub-private.git (fetch)</span><br><span class="line">origin    https://github.com/student/bustub-private.git (push)</span><br><span class="line">public    https://github.com/cmu-db/bustub.git (fetch)</span><br><span class="line">public    https://github.com/cmu-db/bustub.git (push)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6、从远程仓库更新代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull public master</span><br></pre></td></tr></table></figure>

<h3 id="Docker-环境配置"><a href="#Docker-环境配置" class="headerlink" title="Docker 环境配置"></a>Docker 环境配置</h3><p>没下载的在官网下载。</p>
<p><a href="https://docs.docker.com/get-docker/">docker 下载</a></p>
<p>切换到本地仓库目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建镜像文件</span></span><br><span class="line">docker build . -t bustub</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置目录  其中 /D:/CMU/bustub-private 为 windows 本地仓库目录</span></span><br><span class="line">docker create -t -i --name bustub -v /D:/CMU/bustub-private:/bustub bustub bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果系统为 linux 或 mac 可以切换到仓库目录运行以下命令</span></span><br><span class="line">docker create -t -i --name bustub -v $(pwd):/bustub bustub bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行 bustub 镜像容器</span></span><br><span class="line">docker start -a -i bustub</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者可以直接运行挂载目录</span></span><br><span class="line">docker run  -itd -v /D:/CMU/bustub-private:/bustub --name=bustub-lab -p 3316:22 bustub</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -t -i bustub-lab /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先执行</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh-client</span></span><br><span class="line">apt-get install openssh-client</span><br><span class="line"><span class="meta">#</span><span class="bash">openssh-server</span></span><br><span class="line">apt-get install openssh-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo</span></span><br><span class="line">apt-get install sudo</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim</span></span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<h4 id="运行-package-sh-安装环境"><a href="#运行-package-sh-安装环境" class="headerlink" title="运行 package.sh 安装环境"></a>运行 package.sh 安装环境</h4><p>我运行该文件出现如下错误。</p>
<ul>
<li><p>$’\r’:command not found</p>
</li>
<li><p>: not found: 2: packages.sh:</p>
<p>: not found: 13: packages.sh:</p>
</li>
</ul>
<p>如图，运行脚本均报错，由于是 window 下文本使用的格式是 dos 命令行，和 unix 不一样，导致解析出错。我明明是 git clone 下来的仓库，不太明白为啥会错。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291535752.png" alt="image-20211229153524653"></p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>使用工具 dos2unix 文本转换工具，转换后运行既可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install dos2unix</span><br><span class="line">dos2unix packages.sh</span><br></pre></td></tr></table></figure>

<h4 id="配置文件环境"><a href="#配置文件环境" class="headerlink" title="配置文件环境"></a>配置文件环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行以下命令既可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>

<p>完成操作后，既可在本地编辑代码，然后再容器上运行我们的代码</p>
<h2 id="上传容器至个人账户"><a href="#上传容器至个人账户" class="headerlink" title="上传容器至个人账户"></a>上传容器至个人账户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器 id</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交容器镜像</span></span><br><span class="line">docker commit -m=&quot;CMU实验环境初始化&quot; -a=&quot;fanyufeng&quot; 58afd1af2086 fanyufeng/bustub-lab:0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到 docker 的个人账户</span></span><br><span class="line">docker push fanyufeng/ubuntu-cmu:1.0</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>-m: 提交的描述信息</li>
<li>-a: 指定镜像作者</li>
<li>58afd1af2086：容器 id</li>
<li>fanyufeng/bustub-lab:0.1 指定要创建的目标镜像名</li>
</ul>
<h2 id="ssh-连接容器"><a href="#ssh-连接容器" class="headerlink" title="ssh 连接容器"></a>ssh 连接容器</h2><h3 id="安装-ssh-client-命令"><a href="#安装-ssh-client-命令" class="headerlink" title="安装 ssh-client 命令"></a>安装 ssh-client 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-client</span><br></pre></td></tr></table></figure>

<p>等待，输入 Y 就可以了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840031.png" alt="img"></p>
<h3 id="安装-ssh-server-命令"><a href="#安装-ssh-server-命令" class="headerlink" title="安装 ssh-server 命令"></a>安装 ssh-server 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>等待，输入 Y 就可以了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840416.png" alt="img"></p>
<h3 id="安装完成后，先启动服务"><a href="#安装完成后，先启动服务" class="headerlink" title="安装完成后，先启动服务#"></a>安装完成后，先启动服务<a href="https://www.cnblogs.com/mengw/p/11413461.html#4201693076">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh start</span><br></pre></td></tr></table></figure>

<p><img src="image/202111301307264.png" alt="img"></p>
<p>查看是否正确启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -e|grep ssh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840319.png" alt="img"></p>
<h3 id="编辑-sshd-config-文件"><a href="#编辑-sshd-config-文件" class="headerlink" title="编辑 sshd_config 文件"></a>编辑 sshd_config 文件</h3><h4 id="需要先安装-vim-编辑器"><a href="#需要先安装-vim-编辑器" class="headerlink" title="需要先安装 vim 编辑器"></a>需要先安装 vim 编辑器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840635.png" alt="img"></p>
<h4 id="编辑-sshd-config-文件-1"><a href="#编辑-sshd-config-文件-1" class="headerlink" title="编辑 sshd_config 文件"></a>编辑 sshd_config 文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840351.png" alt="img"></p>
<p>保存退出 ESC + : + WQ</p>
<h3 id="重启-ssh-服务"><a href="#重启-ssh-服务" class="headerlink" title="重启 ssh 服务"></a>重启 ssh 服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840271.png" alt="img"></p>
<h3 id="设置-ssh-密码"><a href="#设置-ssh-密码" class="headerlink" title="设置 ssh 密码"></a>设置 ssh 密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291840943.png" alt="img"></p>
<h3 id="查看容器的-IP"><a href="#查看容器的-IP" class="headerlink" title="查看容器的 IP"></a>查看容器的 IP</h3><h4 id="先安装-net-tools-工具包"><a href="#先安装-net-tools-工具包" class="headerlink" title="先安装 net-tools 工具包"></a>先安装 net-tools 工具包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install net-tools</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291841662.png" alt="img"></p>
<h4 id="查看-IP"><a href="#查看-IP" class="headerlink" title="查看 IP"></a>查看 IP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>运行钱 映射的断开 3316 映射到 容器的 22 端口，如图，进行连接既可。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291841024.png" alt="img"></p>
<p>然后连接就可以了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112291700132.png" alt="image-20211229170006772"></p>
]]></content>
      <categories>
        <category>CMU</category>
      </categories>
      <tags>
        <tag>CMU</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu 作业1</title>
    <url>/2021/12/30/CMU/cmu-hw1/</url>
    <content><![CDATA[<p>作业地址：<a href="https://15445.courses.cs.cmu.edu/fall2020/homework1/">2020 CMU 15-445 HW1</a> 作业有说明环境及作业文件下载等数据。</p>
<p>这个作业后面的有些题还是挺复杂的，训练逻辑思维还是可以的，不过工作的话，用不到这么复杂的语句。复杂的题也是想了很久才理清逻辑。</p>
<p>完成该作业有 <a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">Sql基础知识</a> 或了解 <a href="https://blog.csdn.net/caoxiaohong1005/article/details/53868332">CTEs</a>（Common Table Expressions）| <a href="https://sqlite.org/lang_with.html">CTEs</a>  公用表达式会更好</p>
<a id="more"></a>

<h3 id="Q1-0-POINTS-Q1-SAMPLE"><a href="#Q1-0-POINTS-Q1-SAMPLE" class="headerlink" title="Q1 [0 POINTS] (Q1_SAMPLE):"></a>Q1 [0 POINTS] (Q1_SAMPLE):</h3><p>The purpose of this query is to make sure that the formatting of your output matches exactly the formatting of our auto-grading script.</p>
<p><strong>Details:</strong> List all types of work ordered by type ascendingly.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from work_type order by name</span><br></pre></td></tr></table></figure>

<h3 id="Q2-5-POINTS-Q2-LONG-NAME"><a href="#Q2-5-POINTS-Q2-LONG-NAME" class="headerlink" title="Q2 [5 POINTS] (Q2_LONG_NAME):"></a>Q2 [5 POINTS] (Q2_LONG_NAME):</h3><p>List works with longest name of each type.</p>
<p><strong>Details:</strong> For each work type, find works that have the longest names. There might be cases where there is a tie for the longest names - in that case, return all of them. Display work names and corresponding type names, and order it according to work type (ascending) and use work name (ascending) as tie-breaker.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每种类型最长名字分组 表: tem_work</span><br><span class="line">select max(length(work.name)) as max_length,work.type as type</span><br><span class="line">from work</span><br><span class="line">group by work.type </span><br><span class="line">&#x2F;&#x2F; 和类型表取交集 </span><br><span class="line">select work.name,work_type.name </span><br><span class="line">from tem_work </span><br><span class="line">inner join work on work.type &#x3D; tem_work.type </span><br><span class="line">    and tem_work.max_length &#x3D; length(work.name) </span><br><span class="line">inner join work_type on work_type.id &#x3D; work.type</span><br><span class="line">order by work.name asc, work.type asc;</span><br><span class="line">&#x2F;&#x2F; emmm 第二种实现方式</span><br><span class="line">select count(*)</span><br><span class="line">from (select max(length(work.name)) as max_length, work.name as name ,work.type as type</span><br><span class="line">from work</span><br><span class="line">group by work.type ) as tem_work </span><br><span class="line">inner join work_type on work_type.id &#x3D; tem_work.type</span><br><span class="line">order by tem_work.name asc, tem_work.type asc;</span><br></pre></td></tr></table></figure>

<h3 id="Q3-5-POINTS-Q3-OLD-MUSIC-NATIONS"><a href="#Q3-5-POINTS-Q3-OLD-MUSIC-NATIONS" class="headerlink" title="Q3 [5 POINTS] (Q3_OLD_MUSIC_NATIONS):"></a>Q3 [5 POINTS] (Q3_OLD_MUSIC_NATIONS):</h3><p>List top 10 countries with the most classical music artists (born or started before 1850) along with the number of associated artists.</p>
<p><strong>Details:</strong> Print country and number of associated arists before 1850. For example, <code>Russia|191</code>. Sort by number of artists in descending order.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 条件：在<span class="number">1850</span>年之前出生、限制 TOP10，</span><br><span class="line"># 查询：数目和国家名</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> number,a.name  </span><br><span class="line"><span class="keyword">from</span> artist </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> area a </span><br><span class="line"><span class="keyword">on</span> a.id <span class="operator">=</span> artist.area</span><br><span class="line"><span class="keyword">where</span> begin_date_year <span class="operator">&lt;</span> <span class="number">1850</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> area</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> number <span class="keyword">desc</span> </span><br><span class="line">limit <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="Q4-10-POINTS-Q4-DUBBED-SMASH"><a href="#Q4-10-POINTS-Q4-DUBBED-SMASH" class="headerlink" title="Q4 [10 POINTS] (Q4_DUBBED_SMASH):"></a>Q4 [10 POINTS] (Q4_DUBBED_SMASH):</h3><p>List the top 10 dubbed artist names with the number of dubs.</p>
<p><strong>Details:</strong> Count the number of distinct names in <code>artist_alias</code> for each artist in the <code>artist</code> table, and list only the top ten who’s from the United Kingdom and started after 1950 (not included). Print the artist name in the <code>artist</code> table and the number of corresponding distinct dubbed artist names in the <code>artist_alias</code> table.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 条件 英国地区、获得艺术家别名前十的艺术家、(艺术别名有重复 注意去重)</span><br><span class="line"># 查询 艺术家名称、别名数量</span><br><span class="line"></span><br><span class="line"># 获取英国的地区 id 为 <span class="number">221</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> area <span class="keyword">where</span> area.name <span class="keyword">like</span> <span class="string">&#x27;united%&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.name,<span class="built_in">count</span>(<span class="keyword">distinct</span> al.name) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> artist <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> artist_alias <span class="keyword">as</span> al</span><br><span class="line"><span class="keyword">on</span> al.artist <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">where</span> a.begin_date_year <span class="operator">&gt;</span> <span class="number">1950</span></span><br><span class="line"><span class="keyword">and</span> a.area <span class="operator">=</span> <span class="number">221</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Q5-10-POINTS-Q5-VINYL-LOVER"><a href="#Q5-10-POINTS-Q5-VINYL-LOVER" class="headerlink" title="Q5 [10 POINTS] (Q5_VINYL_LOVER):"></a>Q5 [10 POINTS] (Q5_VINYL_LOVER):</h3><p>List the distinct names of releases issued in vinyl format by the British band Coldplay.</p>
<p><strong>Details:</strong> Vinyl format includes ALL vinyl dimensions excluding <code>VinylDisc</code>. Sort the release names by release date ascendingly.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询 由 Coldplay 以 vinyl  格式发行的 releases </span><br><span class="line"># 按时间升序、格式以 Vinyl 结尾</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> r1.name <span class="keyword">as</span> rname</span><br><span class="line"><span class="keyword">from</span> artist_credit_name a1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> artist_credit a2 <span class="keyword">on</span> a1.artist_credit <span class="operator">=</span> a2.id</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">release</span> r1 <span class="keyword">on</span> a2.id <span class="operator">=</span> r1.artist_credit</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> release_info r2 <span class="keyword">on</span> r1.id <span class="operator">=</span> r2.release</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> medium m1 <span class="keyword">on</span> r1.id <span class="operator">=</span> m1.release</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> medium_format m2 <span class="keyword">on</span> m1.format <span class="operator">=</span> m2.id</span><br><span class="line"><span class="keyword">where</span> a1.name <span class="operator">=</span> <span class="string">&#x27;Coldplay&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> m2.name <span class="keyword">like</span> <span class="string">&#x27;%Vinyl&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> date_year,</span><br><span class="line">    date_month,</span><br><span class="line">    date_day;</span><br></pre></td></tr></table></figure>

<h3 id="Q6-10-POINTS-Q6-OLD-IS-NOT-GOLD"><a href="#Q6-10-POINTS-Q6-OLD-IS-NOT-GOLD" class="headerlink" title="Q6 [10 POINTS] (Q6_OLD_IS_NOT_GOLD):"></a>Q6 [10 POINTS] (Q6_OLD_IS_NOT_GOLD):</h3><p>Which decades saw the most number of official releases? List the number of official releases in every decade since 1900. Like <code>1970s|57210</code>.</p>
<p><strong>Details:</strong> Print all decades and the number of official releases. Releases with different issue dates or countries are considered different releases. Print the relevant decade in a fancier format by constructing a string that looks like this: <code>1970s</code>. Sort the decades in decreasing order with respect to the number of official releases and use decade (descending) as tie-breaker. Remember to exclude releases whose dates are <code>NULL</code>.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询 relase 每十年发行的数量</span><br><span class="line"># 每十年<span class="operator">|</span>数量  在<span class="number">1900</span>年之后,不同国家和不同 issue dates 算<span class="number">1</span>条</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> decade,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> (<span class="built_in">CAST</span>((date_year <span class="operator">/</span> <span class="number">10</span>) <span class="keyword">as</span> <span class="type">int</span>) <span class="operator">*</span> <span class="number">10</span>) <span class="operator">||</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">as</span> decade</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">release</span></span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> release_info <span class="keyword">on</span> release.id <span class="operator">=</span> release_info.release</span><br><span class="line">        <span class="keyword">where</span> release.status <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">and</span> date_year <span class="operator">&gt;=</span> <span class="number">1900</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> decade</span><br><span class="line"><span class="keyword">Order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span>,</span><br><span class="line">    decade <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Q7-15-POINTS-Q7-RELEASE-PERCENTAGE"><a href="#Q7-15-POINTS-Q7-RELEASE-PERCENTAGE" class="headerlink" title="Q7 [15 POINTS] (Q7_RELEASE_PERCENTAGE):"></a>Q7 [15 POINTS] (Q7_RELEASE_PERCENTAGE):</h3><p>List the month and the percentage of all releases issued in the corresponding month all over the world in the past year. Display like <code>2020.01|5.95</code>.</p>
<p><strong>Details:</strong> The percentage of releases for a month is the number of releases issued in that month devided by the total releases in the past year from 07/2019 to 07/2020, both included. Releases with different issue dates or countries are considered different releases. Round the percentage to  decimal places using <code>ROUND()</code>. Sort by dates in ascending order.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询： <span class="number">2019</span><span class="operator">/</span><span class="number">07</span><span class="number">-2020</span><span class="operator">/</span><span class="number">07</span> 每个月分发行唱片的百分比 格式：<span class="number">2020.01</span><span class="operator">|</span><span class="number">5.95</span></span><br><span class="line"># 条件： 时间：<span class="number">07</span><span class="operator">/</span><span class="number">2019</span> <span class="keyword">to</span> <span class="number">07</span><span class="operator">/</span><span class="number">2020</span>、 按时间升序</span><br><span class="line"><span class="keyword">with</span> past_year_release (<span class="keyword">year</span>, <span class="keyword">month</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> date_year,</span><br><span class="line">        date_month</span><br><span class="line">    <span class="keyword">from</span> release_info r1</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">release</span> r2 <span class="keyword">on</span> r1.release <span class="operator">=</span> r2.id</span><br><span class="line">    <span class="keyword">where</span> (</span><br><span class="line">            (</span><br><span class="line">                date_year <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line">                <span class="keyword">and</span> date_month <span class="operator">&gt;=</span> <span class="number">7</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">or</span> (</span><br><span class="line">                date_year <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line">                <span class="keyword">and</span> date_month <span class="operator">&lt;=</span> <span class="number">7</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="keyword">year</span> <span class="keyword">as</span> <span class="type">varchar</span>) <span class="operator">||</span> <span class="string">&#x27;.&#x27;</span> <span class="operator">||</span> (</span><br><span class="line">        <span class="keyword">case</span></span><br><span class="line">            <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">then</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    ) <span class="operator">||</span> <span class="built_in">cast</span>(<span class="keyword">month</span> <span class="keyword">as</span> <span class="type">varchar</span>) <span class="keyword">as</span> <span class="type">date</span>,</span><br><span class="line">    round(</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">*</span> <span class="number">100.0</span> <span class="operator">/</span> (</span><br><span class="line">            <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">            <span class="keyword">from</span> past_year_release</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">from</span> past_year_release</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="type">date</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Q8-15-POINTS-Q8-COLLABORATE-ARTIST"><a href="#Q8-15-POINTS-Q8-COLLABORATE-ARTIST" class="headerlink" title="Q8 [15 POINTS] (Q8_COLLABORATE_ARTIST):"></a>Q8 [15 POINTS] (Q8_COLLABORATE_ARTIST):</h3><p>List the number of artists who have collaborated with Ariana Grande.</p>
<p><strong>Details:</strong> Print only the total number of artists. An artist is considered a collaborator if they appear in the same artist_credit with Ariana Grande. The answer should include Ariana Grande herself.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询和  Ariana Grande 合作的艺术家数量</span><br><span class="line"><span class="keyword">Select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> artist)</span><br><span class="line"><span class="keyword">From</span> artist_credit_name</span><br><span class="line"><span class="keyword">Where</span> artist_credit <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> artist_credit</span><br><span class="line">        <span class="keyword">from</span> artist_credit_name</span><br><span class="line">        <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Ariana Grande&#x27;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="Q9-15-POINTS-Q9-DRE-AND-EMINEM"><a href="#Q9-15-POINTS-Q9-DRE-AND-EMINEM" class="headerlink" title="Q9 [15 POINTS] (Q9_DRE_AND_EMINEM):"></a>Q9 [15 POINTS] (Q9_DRE_AND_EMINEM):</h3><p>List the rank, artist names, along with the number of collaborative releases of Dr. Dre and Eminem among other most productive duos (as long as they appear in the same release) both started after 1960 (not included). Display like <code>[rank]|Dr. Dre|Eminem|[# of releases]</code>.</p>
<p><strong>Details:</strong> For example, if you see a release by A, B, and C, it will contribute to three pairs of duos: <code>A|B|1</code>, <code>A|C|1</code>, and <code>B|C|1</code>. You will first need to calculate a rank of these duos by number of collaborated releases (release with artist_credit shared by both artists) sorted descendingly, and then find the rank of <code>Dr. Dre</code> and <code>Eminem</code>. Only releases in English are considered. Both artists should be solo artists. All pairs of names should have the alphabetically smaller one first. Use artist names (asc) as tie breaker.</p>
<p><strong>Hint:</strong> Artist aliases may be used everywhere. When doing aggregation, using artist ids will ensure you get the correct results. One example entry in the rank list is <code>9|Benj Pasek|Justin Paul|27</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询和 Dr. Dre、Eminem 合作的艺术家 格式 [顺序]<span class="operator">|</span>name<span class="operator">|</span>name<span class="operator">|</span>[# <span class="keyword">of</span> releases]</span><br><span class="line"># 条件：<span class="number">1960</span>年后、 与 Dr. Dre、Eminem 合作，<span class="keyword">release</span>:英语、艺术家：独唱艺术家（Person）、升序</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> duos_list (id1, id2, count) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> a1.artist <span class="keyword">as</span> id1,</span><br><span class="line">        a2.artist <span class="keyword">as</span> id2,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">from</span> artist_credit_name a1</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> artist_credit_name a2 <span class="keyword">on</span> a1.artist_credit <span class="operator">=</span> a2.artist_credit</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">release</span> r <span class="keyword">on</span> a2.artist_credit <span class="operator">=</span> r.artist_credit</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> artist a3 <span class="keyword">on</span> a1.artist <span class="operator">=</span> a3.id</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> artist a4 <span class="keyword">on</span> a2.artist <span class="operator">=</span> a4.id</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> artist_type a5 <span class="keyword">on</span> a3.type <span class="operator">=</span> a5.id</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> artist_type a6 <span class="keyword">on</span> a4.type <span class="operator">=</span> a6.id</span><br><span class="line">        <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">language</span> l <span class="keyword">on</span> r.language <span class="operator">=</span> l.id</span><br><span class="line">    <span class="keyword">where</span> a3.name <span class="operator">&lt;</span> a4.name</span><br><span class="line">        <span class="keyword">and</span> a5.name <span class="operator">=</span> &quot;Person&quot;</span><br><span class="line">        <span class="keyword">and</span> a6.name <span class="operator">=</span> &quot;Person&quot;</span><br><span class="line">        <span class="keyword">and</span> l.name <span class="operator">=</span> <span class="string">&#x27;English&#x27;</span></span><br><span class="line">        <span class="keyword">and</span> a3.begin_date_year <span class="operator">&gt;</span> <span class="number">1960</span></span><br><span class="line">        <span class="keyword">and</span> a4.begin_date_year <span class="operator">&gt;</span> <span class="number">1960</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> a1.artist,</span><br><span class="line">        a2.artist</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">row_number</span> () <span class="keyword">over</span> (</span><br><span class="line">                <span class="keyword">order</span> <span class="keyword">by</span> count <span class="keyword">desc</span>,</span><br><span class="line">                    a1.name,</span><br><span class="line">                    a2.name</span><br><span class="line">            ) <span class="keyword">as</span> rank,</span><br><span class="line">            a1.name <span class="keyword">as</span> name1,</span><br><span class="line">            a2.name <span class="keyword">as</span> name2,</span><br><span class="line">            count</span><br><span class="line">        <span class="keyword">from</span> duos_list d</span><br><span class="line">            <span class="keyword">inner</span> <span class="keyword">join</span> artist a1 <span class="keyword">on</span> d.id1 <span class="operator">=</span> a1.id</span><br><span class="line">            <span class="keyword">inner</span> <span class="keyword">join</span> artist a2 <span class="keyword">on</span> d.id2 <span class="operator">=</span> a2.id</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">where</span> name1 <span class="operator">=</span> <span class="string">&#x27;Dr. Dre&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> name2 <span class="operator">=</span> <span class="string">&#x27;Eminem&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Q10-15-POINTS-Q10-AROUND-THE-WORLD"><a href="#Q10-15-POINTS-Q10-AROUND-THE-WORLD" class="headerlink" title="Q10 [15 POINTS] (Q10_AROUND_THE_WORLD):"></a>Q10 [15 POINTS] (Q10_AROUND_THE_WORLD):</h3><p>Concat all dubbed names of The Beatles using comma-separated values(like “<code>Beetles, fab four</code>“).</p>
<p><strong>Details:</strong> Find all dubbed names of artist “<code>The Beatles</code>“ in artist_alias and order them by id (ascending). Print a single string containing all the dubbed names separated by commas.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> c <span class="keyword">as</span> (</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">select</span> <span class="built_in">row_number</span>() <span class="keyword">over</span> (</span><br><span class="line">                  <span class="keyword">order</span> <span class="keyword">by</span> c.id <span class="keyword">asc</span></span><br><span class="line">            ) <span class="keyword">as</span> seqnum,</span><br><span class="line">            c.name <span class="keyword">as</span> name</span><br><span class="line">      <span class="keyword">from</span> artist_alias c</span><br><span class="line">            <span class="keyword">join</span> artist <span class="keyword">on</span> c.artist <span class="operator">=</span> artist.id</span><br><span class="line">      <span class="keyword">where</span> artist.name <span class="operator">=</span> <span class="string">&#x27;The Beatles&#x27;</span></span><br><span class="line">),</span><br><span class="line">flattened <span class="keyword">as</span> (</span><br><span class="line">      <span class="keyword">select</span> seqnum,</span><br><span class="line">            name <span class="keyword">as</span> name</span><br><span class="line">      <span class="keyword">from</span> c</span><br><span class="line">      <span class="keyword">where</span> seqnum <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">      <span class="keyword">select</span> c.seqnum,</span><br><span class="line">            f.name <span class="operator">||</span> <span class="string">&#x27;, &#x27;</span> <span class="operator">||</span> c.name</span><br><span class="line">      <span class="keyword">from</span> c</span><br><span class="line">            <span class="keyword">join</span> flattened f <span class="keyword">on</span> c.seqnum <span class="operator">=</span> f.seqnum <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> flattened</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> seqnum <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CMU</category>
      </categories>
      <tags>
        <tag>CMU</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 搭建博客-博客搭建（1）</title>
    <url>/2020/08/08/Hexo%E6%90%AD%E5%BB%BA/hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>补充：之前没怎么看官方文档，现在看了官方文档，发现许多问题都好解决了挺多。贴几个相关的官方链接和 Github链接。</p>
<p><a href="https://hexo.io/zh-cn/">hexo</a> <a href="http://theme-next.iissnan.com/">next</a>  <a href="https://github.com/litten/hexo-theme-yilia">yilia</a></p>
<h2 id="安装Nodejs和git"><a href="#安装Nodejs和git" class="headerlink" title="安装Nodejs和git"></a>安装Nodejs和git</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<p>在dos命令行下输入以下命令安装</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a> </p>
</blockquote>
<a id="more"></a>

<h2 id="安装-hexo框架"><a href="#安装-hexo框架" class="headerlink" title="安装 hexo框架"></a>安装 hexo框架</h2><blockquote>
<p> cnpm install -g hexo-cli </p>
<p>hexo -v #查看hexo版本</p>
<p>cd进入你的博客文件</p>
<p>hexo init  #生成博客 初始化博客</p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2.png" alt="初始化博客"></p>
<h2 id="访问博客"><a href="#访问博客" class="headerlink" title="访问博客"></a>访问博客</h2><blockquote>
<p> hexo -s   访问博客</p>
</blockquote>
<p>在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2.png" alt="第一次访问本地博客"></p>
<p>现在博客就初期搭建好了，接下来就准备将其部署到网上，可以选择github或者gitee  我选择码云，速度比较快一点</p>
<h2 id="创建gitee-仓库"><a href="#创建gitee-仓库" class="headerlink" title="创建gitee 仓库"></a>创建gitee 仓库</h2><p>准备工作</p>
<p>接下来 去码云创建一个仓库（名字和你用户名一样）</p>
<p>如果没有注册码云的可以去注册一个</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E5%88%9B%E5%BB%BA%E7%A0%81%E4%BA%91%E4%BB%93%E5%BA%93.png" alt="创建码云仓库"></p>
<p>创建完之后在hexo的目录使用git  输入以下内容</p>
<blockquote>
<p> vim _condfig.yml  </p>
<p>在里面修改添加如下内容（最末尾位置）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: 你创建的码云仓库名称</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>部署之前需要先下载git依赖</p>
<p>cpnm install –save hexo-deployer-git  </p>
<p>hexo clean  清理一下</p>
<p>hexo g    重新生成内容</p>
<p>hexo  d    部署</p>
</blockquote>
<h2 id="开启gitee-page"><a href="#开启gitee-page" class="headerlink" title="开启gitee page"></a>开启gitee page</h2><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E5%BC%80%E5%90%AFgitee%20page.png" alt="开启gitee page"></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E5%BC%80%E5%90%AFgitee%20page1.png" alt="开启gitee page1"></p>
<h2 id="部署博客到gitee"><a href="#部署博客到gitee" class="headerlink" title="部署博客到gitee"></a>部署博客到gitee</h2><p>这样就可以部署到码云上了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E9%83%A8%E7%BD%B2%E5%88%B0gitee.png" alt="部署到gitee"></p>
<h2 id="文章-主题配置"><a href="#文章-主题配置" class="headerlink" title="文章/主题配置"></a>文章/主题配置</h2><p>更换主题：我使用yilia的主题  </p>
<p>源地址：<a href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a></p>
<p>在hexo的源目录下</p>
<p>切换到主题目录 theme   使用git克隆该仓库</p>
<blockquote>
<p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a></p>
</blockquote>
<p>然后打开 _config.yml文件，将主题改成如下（对应下载的目录名字）  记得将 .git文件目录删除掉，</p>
<p>不删除的话会影响后续分支目录的上传</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/yilia%E5%85%8B%E9%9A%86.png" alt="image-20200813212100533"></p>
<p>重新启动一下 看看有没有错误</p>
<blockquote>
<p>hexo clean </p>
<p>hexo g </p>
<p>hexo s </p>
</blockquote>
<p>如果出现下图就没问题了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98%E9%83%A8%E7%BD%B2.png" alt="更新主题部署"></p>
<p>将其部署到gitee上去</p>
<p>使用命令就行了</p>
<blockquote>
<p>hexo d</p>
</blockquote>
<p>但是部署后出现了一个问题，在本地是更新主题后的页面，而远程更新后的页面没改变</p>
<p>我去查了一下，hexo clean  只是把public文件删除，但是hexo g的时候发现你并没有改配置文件，所以就没有改动，记录没改变，.deploy_git提交记录也就没改动，所以远程没改动配置文件。</p>
<p>我将.deploy_git文件删除之后，再执行hexo d -g 就更新成功了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98%E4%B9%8B%E5%90%8E%E9%83%A8%E7%BD%B2%E5%88%B0gitee.png" alt="image-20200808192045357"></p>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><h4 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h4><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。</p>
<h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/me.png</code>，设置则为<code>avatar: /assets/me.png</code>。（图标同理）</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/hexo/%E4%BF%AE%E6%94%B9blog%E5%A4%B4%E5%83%8F.png" alt="image-20200808192349719"></p>
<h3 id="文章设置"><a href="#文章设置" class="headerlink" title="文章设置"></a>文章设置</h3><h4 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h4><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page categories</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/<span class="built_in">source</span>/categories/index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<code>type: &quot;categories&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categorise</span><br><span class="line">date: 2020-08-08 17:06:45</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<h4 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h4><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 计算机网络概述</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">37</span></span><br><span class="line">categories:  </span><br><span class="line"> - 计算机网络</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的“分类”中。</p>
<h4 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h4><h4 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h4><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page tags</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/<span class="built_in">source</span>/tags/index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">45</span></span><br><span class="line">type: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>可以改成你要该的分类名称，添加<code>type: &quot;tags&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">42</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<h4 id="2-2-给文章添加“tags”属性"><a href="#2-2-给文章添加“tags”属性" class="headerlink" title="2.2 给文章添加“tags”属性"></a>2.2 给文章添加“tags”属性</h4><p>打开需要添加标签的文章，为其添加tags属性。下方的<code>tags:</code>下方的<code>- jQuery</code> <code>- 表格</code><br> <code>- 表单验证</code>就是这篇文章的标签了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 计算机网络概述</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">08</span>-<span class="number">08</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">37</span></span><br><span class="line">categories:  </span><br><span class="line"> - 计算机网络</span><br><span class="line">tags: </span><br><span class="line"> - <span class="number">408</span></span><br><span class="line"> - 网络</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</p>
<p>细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行<code>hexo new 文章名</code>命令生成的文件，页面里就有<code>categories:</code>项了。</p>
<p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu C++ 学习</title>
    <url>/2021/12/31/CMU/cmu-lab-c/</url>
    <content><![CDATA[<h2 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h2><a id="more"></a>
]]></content>
      <categories>
        <category>CMU</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-进阶配置</title>
    <url>/2021/11/28/Hexo%E6%90%AD%E5%BB%BA/hexo-advanced-setting/</url>
    <content><![CDATA[<p>这里记录 有关 Next 8.8 版本的一些进阶配置，有关自定义样式和自定义 JS 相关的内容。</p>
<p>具体参考 <a href="https://theme-next.js.org/docs/advanced-settings/">Next-Advanced-Setting</a></p>
<h2 id="自定义文件"><a href="#自定义文件" class="headerlink" title="自定义文件"></a>自定义文件</h2><p>这部分内容参考 <a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html">Next 自定义文件配置</a></p>
<a id="more"></a>

<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在之前，要自定义页面样式等操作需要修改 Next 主题的配置文件，去修改样式或模板渲染的文件等。而在之后的代码合并提交或者更新时就会出现冲突的情况。因此官方推荐使用自定义文件和主题配置文件分离的形式，进行自定义的网址设置。在站点配置文件目录下，创建<code>_data/xxx.xxx</code>文件夹，修改对应的配置，然后再主题配置文件 <code>_config.next.yml</code> 中启用对应的文件既可。</p>
<p>自定义配置文件路径：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>



<h2 id="修改样式自定义"><a href="#修改样式自定义" class="headerlink" title="修改样式自定义"></a>修改样式自定义</h2><p>修改文章样式可以在 <code>source/_data/styles.styl</code> 文件夹下进行自定义。</p>
<p>1、找到对应的样式 class，如 header-inner，个人的信息样式设置，以及背景图文章内容等样式均可找到。</p>
<p> <img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202201041055902.png" alt="image-20220104105531576"> </p>
<p>找到样式后在 <code>source/_data/styles.styl</code> 新增样式类</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 侧边、分页 rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);   <span class="number">0</span> 和 <span class="number">1</span> 是样式透明度</span><br><span class="line"><span class="selector-class">.header-inner</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他样式也是差不多原理，下面是一些常用的样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 隐藏继续努力</span><br><span class="line"><span class="selector-class">.archive</span> <span class="selector-class">.collection-title</span> &#123;</span><br><span class="line">//   <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 文章块样式</span><br><span class="line"> <span class="selector-class">.post-block</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="attribute">margin-bottom</span>: <span class="number">24px</span> <span class="meta">!important</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="meta">!important</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 背景图</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">/images/background.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed; //不重复</span><br><span class="line">    <span class="attribute">background-size</span>: cover; //填充</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">// sidebar侧边个人头像样式</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">    // 动画过渡时间</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">0.4s</span>;</span><br><span class="line">    // 透明度</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">// 标题</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span> &#123;</span><br><span class="line">    // 设置字体颜色</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 文章列表样式</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">40px</span> <span class="number">40px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 侧边、分页 rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);   <span class="number">0</span> 和 <span class="number">1</span> 是样式透明度</span><br><span class="line"><span class="selector-class">.header-inner</span>, <span class="selector-class">.sidebar-inner</span>,<span class="selector-class">.pagination</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">7px</span> <span class="number">2px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>), <span class="number">7px</span> <span class="number">4px</span> <span class="number">1px</span> -<span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.06</span>), <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.12</span>) <span class="meta">!important</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>! tips 如果样式未生效，可以加上 !important 提高自定义样式的优先级。</p>
</blockquote>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-搭建博客-博客配置(3)</title>
    <url>/2021/11/22/Hexo%E6%90%AD%E5%BB%BA/hexo-config-3/</url>
    <content><![CDATA[<p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p>
<a id="more"></a>



<p>这里主题推荐 <a href="https://github.com/litten/hexo-theme-yilia">yilia</a> 和 <a href="https://github.com/theme-next/hexo-theme-next">next</a> 两种，比较简约。 需要将主题下载到 themes 文件夹下。</p>
<p>yilia 下载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br><span class="line"><span class="comment"># 更新 </span></span><br><span class="line"><span class="built_in">cd</span> themes/yilia</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>next 下载安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>配置：需要去站点配置文件 <code>_config.yml</code> 修改  <code>theme: yilia</code> 或者  <code>theme: yilia</code> 下面是 next 的几个版本仓库</p>
<p> <a href="https://github.com/iissnan/hexo-theme-next">5.14 或更低</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next">6~7</a></p>
<p><a href="https://github.com/next-theme/hexo-theme-next">8以上</a></p>
<h2 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h2><p>这里介绍几个比较好用的命令</p>
<ul>
<li>新建文章和草稿等</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建文章</span></span><br><span class="line">hexo new post  <span class="string">&quot;titleName&quot;</span></span><br><span class="line"><span class="comment"># 新建草稿</span></span><br><span class="line">hexo new draft <span class="string">&quot;titleName&quot;</span></span><br><span class="line"><span class="comment"># 新建页面 对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成静态文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 静态文件 其中 -d 表示部署 -w 表示监控文件的改动，并生成静态文件。</span></span><br><span class="line">hexo generate -d -w </span><br></pre></td></tr></table></figure>

<p>其中 -d 需要在<code>站点配置文件中</code> 配置部署的链接及分支等。</p>
<p>-w 则是可以在你修改文件时，生成对应的静态文件，不需要重新启动，十分方便。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211122102259337.png" alt="image-20211122102259337"></p>
<ul>
<li>启动并监控</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 debug 在运行的过程中，查看应用情况</span></span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>

<ul>
<li>删除生成的静态文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除静态文件 public 下的文件</span></span><br><span class="line">hexo clean </span><br><span class="line"><span class="comment"># 删除并重新生成</span></span><br><span class="line">hexo clean -g</span><br></pre></td></tr></table></figure>

<p>以上是我常用的命令，更多命令查看： <a href="https://hexo.io/zh-cn/docs/commands">hexo commands</a></p>
<h2 id="博客配置修改"><a href="#博客配置修改" class="headerlink" title="博客配置修改"></a>博客配置修改</h2><p>配置的修改看配置文档比较详细。</p>
<p><a href="https://hexo.io/zh-cn/docs/configuration">Hexo 配置文档</a></p>
<p><a href="https://theme-next.js.org/docs">Next 文档 8.x </a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-搭建博客-常见问题(4)</title>
    <url>/2021/11/22/Hexo%E6%90%AD%E5%BB%BA/hexo-problem-4/</url>
    <content><![CDATA[<p>这里记录，搭建博客中出现的一些问题。</p>
<a id="more"></a>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题。</li>
</ul>
<p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><code>&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;</code><br><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><br><code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></p>
<h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><ul>
<li>没有<code>阅读全文</code>标志来进行截面，导致页面过长：在 md 文档中添加 <code>&lt;!--more--&gt;</code> 进行截取文章。</li>
</ul>
<h3 id="标题居中"><a href="#标题居中" class="headerlink" title="标题居中"></a>标题居中</h3><p>我此时的 Next 主题样式为 Mist，先看一下页面的样式。 标题的 <code>class=&quot;post-title&quot;</code> 添加了 <code>style=&quot;center&quot;</code>后居中。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211122113733408.png" alt="image-20211122113733408"></p>
<p>然后再配置文件中修改，则是需要在<code>Hexo\themes\next\source\css\_schemes\Mist</code>目录下，这里<code>Hexo</code>为安装时自定义的目录名。首先得让博客内容居中，找到此目录下<code>_posts-expanded.styl</code>文件用文本编辑器打开，</p>
<p>找到 .post-title 在 text-align 添加 center</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-title</span>,</span><br><span class="line"><span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-meta-text-align, center;</span><br><span class="line">  + mobile() &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置-Next-背景-3D-动画"><a href="#设置-Next-背景-3D-动画" class="headerlink" title="设置 Next 背景 3D 动画"></a>设置 Next 背景 3D 动画</h3><p>将依赖下载到 Next 的文件夹下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-three <span class="built_in">source</span>/lib/three</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中，设置其中一个为 true</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  three_waves: <span class="literal">false</span></span><br><span class="line">  canvas_lines: <span class="literal">false</span></span><br><span class="line">  canvas_sphere: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="设置统计字数时长等"><a href="#设置统计字数时长等" class="headerlink" title="设置统计字数时长等"></a>设置统计字数时长等</h3><p>需要安装 这个 next 集成的功能插件 hexo-symbols-count-time。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>

<p>在站点配置文件中设置相应的设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">false</span> <span class="comment">#是否统计阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span> <span class="comment">#是否统计总阅读时长</span></span><br></pre></td></tr></table></figure>

<h3 id="设置访问人数"><a href="#设置访问人数" class="headerlink" title="设置访问人数"></a>设置访问人数</h3><p>如果没有安装 Next 主题的话，那么请参照该 <a href="https://blog.51cto.com/u_15288309/3062193">链接进行设置</a></p>
<p>因为 Next 集成了 <a href="http://busuanzi.ibruce.info/">不蒜子</a> 这个统计插件。在主题配置文件下搜索 busuanzi 设置为 true 在 footer 下 添加<code>counter: true</code>就可以了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># 添加阅读统计</span></span><br><span class="line">  <span class="attr">counter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>需要修改，访问人数的具体内容的，可修改 <code>themes\next\layout\_third-party\statistics\busuanzi-counter.swig</code>该文件下的内容。如添加访客数文字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-item&quot;</span> id=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> style=<span class="string">&quot;display: none;&quot;</span>&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span><br><span class="line">      &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">      &lt;span&gt;访客数：&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;site-uv&quot;</span> title=<span class="string">&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;</span>&gt;</span><br><span class="line">      &lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置页脚、页面样式"><a href="#设置页脚、页面样式" class="headerlink" title="设置页脚、页面样式"></a>设置页脚、页面样式</h3><p>设置页面、标题居中、样式等，可以在对应的主题文件进行修改， 如我修改页脚的居中样式，则修改<code>themes\next\source\css\_schemes\Mist</code>下的 <code>layout.styl</code>文件中的内容。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果需要设置其他内容，可以修改其他的文件。</p>
<p>修改查看使用:<code>hexo g -w</code> 来 r 进行调试。</p>
<h2 id="升级-Next-主题"><a href="#升级-Next-主题" class="headerlink" title="升级 Next 主题"></a>升级 Next 主题</h2><table>
<thead>
<tr>
<th>版本</th>
<th>年份</th>
<th>仓库</th>
</tr>
</thead>
<tbody><tr>
<td>v5.1.4 或更低</td>
<td>2014 ~ 2017</td>
<td><a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></td>
</tr>
<tr>
<td>v6.0.0 ~ v7.8.0</td>
<td>2018 ~ 2019</td>
<td><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></td>
</tr>
<tr>
<td>v8.0.0 或更高</td>
<td>2020</td>
<td><a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></td>
</tr>
</tbody></table>
<h4 id="升级注意事项"><a href="#升级注意事项" class="headerlink" title="升级注意事项"></a>升级注意事项</h4><p>跨版本的升级可能并不顺滑（例如由 v5.1.4 或 v7.8.0 升级至 v8.0.0），请备份配置文件及修改过的文件（例如自定义模板文件）后，重新安装新的主题。具体操作请阅读文档： <a href="https://theme-next.js.org/docs/getting-started/upgrade.html">https://theme-next.js.org/docs/getting-started/upgrade.html</a></p>
<h3 id="v7-4-2-Nunjucks-引擎"><a href="#v7-4-2-Nunjucks-引擎" class="headerlink" title="v7.4.2 Nunjucks 引擎"></a>v7.4.2 Nunjucks 引擎</h3><p>鉴于 swig 缺乏维护，NexT 自 7.4.2 版本开始，使用 Nunjucks 代替 swig 作为模版引擎。如果此前根据 swig 的语法写过自定义内容，请在更新前确认它们是与 Nunjucks 兼容的，否则会报错，且生成的页面为空白。例如， Nunjucks 只支持 <code>and</code> 运算符，需要替换掉 swig 中的 <code>&amp;&amp;</code>。见 <a href="http://mozilla.github.io/nunjucks/getting-started.html">http://mozilla.github.io/nunjucks/getting-started.html</a></p>
<p>Hexo 5.0 版本移除了对于 swig 模版的支持，改为独立的 hexo-renderer-swig 插件。如果你发现 Hexo 生成的 html 中输出了 NexT 模版源码，说明你正在使用旧版本的 NexT，请根据前面「Hexo 与 NexT 兼容性」部分的内容升级 NexT。</p>
<h2 id="主题配置文件设置（推荐）"><a href="#主题配置文件设置（推荐）" class="headerlink" title="主题配置文件设置（推荐）"></a>主题配置文件设置（推荐）</h2><p> 我们习惯的方式是站点配置文件和主题配置文件分别存放不同的配置，这个方式很好，但是不适用升级 Next 主题或者提交 Merge，因此官方推荐使用新的配置文件，来放到同站点配置文件同目录下，并命名为新的配置文件 <code>_config.[themeName].yml</code>，themeName 就是你的主题名字，<a href="https://hexo.io/docs/configuration.html#Using-an-Alternate-Config">Hexo 灵活配置说明</a> ，而原来的 主题配置文件就不用修改了，修改自己的配置文件就行了。</p>
<p><strong>操作</strong></p>
<p>在刚下载安装 Next 的时候，复制如下操作，并将 _config.next.yml 文件放置到 站点配置文件同目录下。</p>
<p><code>cp themes/next/_config.yml _config.next.yml</code></p>
<p>重新生成 public 文件即可。 <a href="https://theme-next.js.org/docs/getting-started/configuration.html">参考 Next 配置</a></p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>有多种评论生成的方式，Disqus、ChangYan、GitTalk 等，具体需求可参考<a href="https://theme-next.js.org/docs/third-party-services/comments.htm">评论生成文档</a></p>
<p>我换成了 <a href="https://github.com/gitalk/gitalk#install">GitTalk</a></p>
<p><a href="https://links.jianshu.com/go?to=https://github.com/gitalk/gitalk">Gitalk</a> 是一个基于 <code>Github Issue</code> 的评论插件，使用 <code>Github</code> 帐号登录，界面干净整洁，最喜欢的一点是支持 <code>MarkDown</code> 语法，在个人博客里添加了之后就可以很简便的进行评论和回复了。</p>
<h4 id="1-创建-Github-仓库"><a href="#1-创建-Github-仓库" class="headerlink" title="1. 创建 Github 仓库"></a>1. 创建 Github 仓库</h4><p>需要在自己的 <code>Github</code> 账号下创建一个仓库来存放评论，创建的仓库只要 <code>public</code> 就行，其余没要求。</p>
<h4 id="2-创建-Github-Application"><a href="#2-创建-Github-Application" class="headerlink" title="2. 创建 Github Application"></a>2. 创建 Github Application</h4><p>需要创建一个 <code>Github Application</code> 用来授权登录，如果没有 <a href="https://links.jianshu.com/go?to=https://github.com/settings/applications/new">点击这里申请</a>，<code>Authorization callback URL</code> 填写你主页地址。其他的不用在意，没有用到就随意填。不知道怎么创建，请看 <a href="https://docs.github.com/cn/developers/apps/building-oauth-apps/creating-an-oauth-app">这里</a></p>
<h4 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h4><p>安装 gittalk</p>
<p><code>npm i --save gitalk</code></p>
<p>创建好 github app 后会生成 client_id 和 client_secret，填入即可，同时，需要你存放评论的仓库也一同放下去。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br><span class="line">  <span class="attr">admin_user:</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h4 id="出现-Error-Bad-credentials"><a href="#出现-Error-Bad-credentials" class="headerlink" title="出现 Error: Bad credentials."></a>出现 Error: Bad credentials.</h4><p>按 F12 查看请求的链接地址,之前错误的网址不见了，只好贴这个成功的示例，之前的链接是<code>https://api.github.com/repos/github_id/Fan-Yu-Feng.github.io</code>  我以为 github_id 是去查看自己 github 的用户 id，填了 Github 的用户 id，在 next 主题配置文件中填入了自己的 github id，一直报这个错误，</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112241638388.png" alt="image-20211224163522104"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-搭建博客-博客图床 picgo（2）</title>
    <url>/2021/11/19/Hexo%E6%90%AD%E5%BB%BA/hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%20picgo%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>记录一下，以防以后踩坑。</p>
<p>使用 blog 写文章的时候需要上传一些图片，不然只能在本地看。这时候就需要图床来保存博客中的图片。</p>
<p>我使用的是 typora + picgo 的方式。</p>
<a id="more"></a>

<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>picgo 下载在GitHub上有安装包。或者打开阿里云盘吧，有 windows 64bit 的安装包。</p>
<p><a href="https://molunerfinn.com/PicGo/">PicGo官网</a>   <a href="https://www.aliyundrive.com/s/2dHNyobJTMr">阿里云盘</a></p>
<p>还有就是下载  <a href="https://typora.io/">Typora</a></p>
<h2 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h2><p>下载安装完后，需要安装上传插件 gitee，有三种，任意下一种，不同的配置不一样的。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211119154827385.png" alt="image-20211119154827385"></p>
<p>然后再gitee 上进行配置再验证上传就好了，配置如下。刚开始路径写错了导致不成功，所以可以注意一下路径。</p>
<p>owner 是你的账号名，repo 是仓库，token是码云私人令牌。<a href="https://zhuanlan.zhihu.com/p/102594554">私人令牌申请</a></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211119154917309.png" alt="image-20211119154917309"></p>
<h2 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h2><p>最后在 Typora 中配置一下 picgo 的安装路径的exe文件和验证上传就可以了。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211119155220988.png" alt="image-20211119155220988"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-Tool</title>
    <url>/2021/11/22/JVM/JVM-Tool/</url>
    <content><![CDATA[<h2 id="Java-虚拟机性能监控和故障处理工具"><a href="#Java-虚拟机性能监控和故障处理工具" class="headerlink" title="Java 虚拟机性能监控和故障处理工具"></a>Java 虚拟机性能监控和故障处理工具</h2><p>使用 Java 虚拟机的性能处理工具可以方便的去分析内存数据、定位故障问题。本篇是个人学习 JVM 的知识笔记。参考资料来自周志明的</p>
<blockquote>
<p>《深入理解Java虚拟机: JVM高级特性与最佳实践（第3版）》</p>
</blockquote>
<a id="more"></a>

<p>Java 虚拟机提供的工具全都在 Java/bin 目录下，本次使用的工具是基于 Java1.8 的性能处理工具，使用的是 HotSpot 虚拟机。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111221837309.png" alt="image-20211122183701178"></p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><h4 id="jps-虚拟机进程状态工具"><a href="#jps-虚拟机进程状态工具" class="headerlink" title="jps: 虚拟机进程状态工具"></a>jps: 虚拟机进程状态工具</h4><p>jps: JVM Process Status Tool，虚拟机状态进程工具。可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。虽然功能比较单一，但它绝对是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的 LVMID 来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID 与操作系统的进程 ID（PID，Process Identifier）是一致的，使用 Windows 的任务管理器或者 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖 jps 命令显示主类的功能才能区分了。</p>
<p>jps 命令格式 ，如果不指定 hostid 就默认为当前的主机或服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>

<p>主要选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-q: 输出虚拟机唯一ID，不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m: 输出传入main方法的参数</span><br><span class="line">-l: 输出main类或Jar的全名</span><br><span class="line">-v: 输出虚拟机进程启动时JVM的参数</span><br></pre></td></tr></table></figure>

<h4 id="jstat-虚拟机显示信息监视工具"><a href="#jstat-虚拟机显示信息监视工具" class="headerlink" title="jstat: 虚拟机显示信息监视工具"></a>jstat: 虚拟机显示信息监视工具</h4><p>jstat: JVM Statistics Monintoring Tool，用于监视虚拟机各种运行状态信息的命令行工具。用于显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。它是运行时期定位虚拟机性能问题的常用工具。</p>
<p>jstat 命令格式</p>
<blockquote>
<p>jstat [ option vmid [interval [s | ms] [count] ] ]</p>
<p>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p>
</blockquote>
<p>说明: 如果是本地虚拟机进程，VMID和LVMID是一样的，如果是远程虚拟机进程，那VMID格式应该是: </p>
<blockquote>
<p>[protocol:][ // ] lvmid [@hostname [:port] /servername ]</p>
</blockquote>
<p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250<br>毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是</p>
<p>主要选项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类加载</span></span><br><span class="line"><span class="attr">class:</span> <span class="string">监视类装载、卸载数量、总空间以及类装载所耗费的时间</span></span><br><span class="line"><span class="comment"># 垃圾收集</span></span><br><span class="line"><span class="attr">gc:</span> <span class="string">监视Java堆状况，包括Eden区、两个Survivor区、老年代等容量、已用空间、GC时间合计等信息</span></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="attr">compiler:</span> <span class="string">输出JIT编译器编译过的方法、耗时等信息</span></span><br><span class="line"><span class="comment"># 堆内存</span></span><br><span class="line"><span class="attr">gccapacity:</span> <span class="string">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</span></span><br><span class="line"><span class="comment"># 新生代垃圾回收</span></span><br><span class="line"><span class="attr">gcnew:</span> <span class="string">监视新生代GC状况</span></span><br><span class="line"><span class="comment"># 新生代内存</span></span><br><span class="line"><span class="attr">gcnewcapacity:</span> <span class="string">监视内容与-gcnew基本相同，主要输出使用到的最大、最小空间</span>    </span><br><span class="line"><span class="comment"># 老年代垃圾回收</span></span><br><span class="line"><span class="attr">gcold:</span> <span class="string">监视老年代GC情况</span></span><br><span class="line"><span class="comment"># 老年代内存</span></span><br><span class="line"><span class="attr">gcoldcapacity:</span> <span class="string">监视内容与-gcold基本相同，主要输出使用到的最大、最小空间</span></span><br><span class="line"><span class="comment"># 元数据空间</span></span><br><span class="line"><span class="attr">gcmetacapacity:</span> <span class="string">监视元数据空间内存情况（jdk1.8之后）</span></span><br><span class="line"><span class="comment"># 垃圾回收统计</span></span><br><span class="line"><span class="attr">gcutil:</span> <span class="string">统计所有垃圾回收的数据</span></span><br><span class="line"><span class="comment"># 编译方法</span></span><br><span class="line"><span class="attr">printcompilation:</span> <span class="string">输出已经被JIT编译的方法</span></span><br></pre></td></tr></table></figure>

<h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>监视类装载、卸载数量、总空间以及类装载所耗费的时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -class 46416</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 12896 24288.0        6     9.4       8.92</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Loaded:</span> <span class="string">加载class的数量</span></span><br><span class="line"><span class="attr">Bytes:</span> <span class="string">所占用空间大小</span></span><br><span class="line"><span class="attr">Unloaded:</span> <span class="string">未加载数量</span></span><br><span class="line"><span class="attr">Bytes:</span> <span class="string">未加载占用空间</span></span><br><span class="line"><span class="attr">Time:</span> <span class="string">时间</span></span><br></pre></td></tr></table></figure>

<h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><blockquote>
<p>jstat -gc 46416250 20  查询进程 46416 进程每2000毫秒 查询一次 gc 情况，共20次。 </p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211128154753969.png" alt="image-20211128154753969"></p>
<p>基本字段的含义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">S0C:</span> <span class="string">第一个幸存区的大小</span></span><br><span class="line"><span class="attr">S1C:</span> <span class="string">第二个幸存区的大小</span></span><br><span class="line"><span class="attr">S0U:</span> <span class="string">第一个幸存区的使用大小</span></span><br><span class="line"><span class="attr">S1U:</span> <span class="string">第二个幸存区的使用大小</span></span><br><span class="line"><span class="attr">EC:</span> <span class="string">伊甸园区的大小</span></span><br><span class="line"><span class="attr">EU:</span> <span class="string">伊甸园区的使用大小</span></span><br><span class="line"><span class="attr">OC:</span> <span class="string">老年代大小</span></span><br><span class="line"><span class="attr">OU:</span> <span class="string">老年代使用大小</span></span><br><span class="line"><span class="attr">MC:</span> <span class="string">方法区大小</span></span><br><span class="line"><span class="attr">MU:</span> <span class="string">方法区使用大小</span></span><br><span class="line"><span class="attr">CCSC:</span> <span class="string">压缩类空间大小</span></span><br><span class="line"><span class="attr">CCSU:</span> <span class="string">压缩类空间使用大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">YGCT:</span> <span class="string">年轻代垃圾回收消耗时间</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代垃圾回收次数</span></span><br><span class="line"><span class="attr">GCT:</span> <span class="string">垃圾回收消耗总时间</span></span><br></pre></td></tr></table></figure>

<h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p> 输出JIT编译器编译过的方法、耗时等信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -compiler 46416</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    7650      0       0     1.44          0</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Compiled:</span> <span class="string">编译数量。</span></span><br><span class="line"><span class="attr">Failed:</span> <span class="string">失败数量</span></span><br><span class="line"><span class="attr">Invalid:</span>  <span class="string">不可用数量</span></span><br><span class="line"><span class="attr">Tim:</span> <span class="string">时间</span></span><br><span class="line"><span class="attr">FailedType:</span> <span class="string">失败类型</span></span><br><span class="line"><span class="attr">FailedMethod:</span> <span class="string">失败的方法</span></span><br></pre></td></tr></table></figure>

<h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p> 监视新生代GC状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcnew 46416</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU         YGC     YGCT</span><br><span class="line">3072.0 23552.0 2624.0    0.0  4  15 23552.0 353792.0 155021.4     14    0.088</span><br></pre></td></tr></table></figure>

<p>字段说明(已介绍的参数不再重复)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">S0C:</span> <span class="string">第一个幸存区大小</span></span><br><span class="line"><span class="attr">S1C:</span> <span class="string">第二个幸存区的大小</span></span><br><span class="line"><span class="attr">S0U:</span> <span class="string">第一个幸存区的使用大小</span></span><br><span class="line"><span class="attr">S1U:</span> <span class="string">第二个幸存区的使用大小</span></span><br><span class="line"><span class="string">TT:对象在新生代存活的次数</span></span><br><span class="line"><span class="string">MTT:对象在新生代存活的最大次数</span></span><br><span class="line"><span class="string">DSS:期望的幸存区大小</span></span><br><span class="line"><span class="attr">EC:</span> <span class="string">伊甸园区的大小</span></span><br><span class="line"><span class="attr">EU:</span> <span class="string">伊甸园区的使用大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">YGCT:</span> <span class="string">年轻代垃圾回收消耗时间</span></span><br></pre></td></tr></table></figure>

<h5 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity:"></a>-gcnewcapacity:</h5><p>监视内容与-gcnew基本相同，主要输出使用到的最大、最小空间    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcnewcapacity 46416</span><br><span class="line">NGCMN   NGCMX       NGC    S0CMX     S0C    S1CMX     S1C       ECMX      EC   YGC   FGC</span><br><span class="line">86528.0  1387008.0 487936.0 462336.0 3072.0 462336.0 23552.0 1385984.0 353792.0  14    3</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">NGCMN:</span> <span class="string">新生代最小容量</span></span><br><span class="line"><span class="attr">NGCMX:</span> <span class="string">新生代最大容量</span></span><br><span class="line"><span class="attr">NGC:</span> <span class="string">当前新生代容量</span></span><br><span class="line"><span class="attr">S0CMX:</span> <span class="string">最大幸存1区大小</span></span><br><span class="line"><span class="attr">S0C:</span> <span class="string">当前幸存1区大小</span></span><br><span class="line"><span class="attr">S1CMX:</span> <span class="string">最大幸存2区大小</span></span><br><span class="line"><span class="attr">S1C:</span> <span class="string">当前幸存2区大小</span></span><br><span class="line"><span class="attr">ECMX:</span> <span class="string">最大伊甸园区大小</span></span><br><span class="line"><span class="attr">EC:</span> <span class="string">当前伊甸园区大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代回收次数</span></span><br></pre></td></tr></table></figure>

<h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold:"></a>-gcold:</h5><p>监视老年代GC情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcold 46416</span><br><span class="line"> MC         MU   CCSC    CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 72024.0 67356.9  9600.0  8718.7  188416.0    45162.0     14     3    0.179    0.268</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">MC:</span> <span class="string">方法区大小</span></span><br><span class="line"><span class="attr">MU:</span> <span class="string">方法区使用大小</span></span><br><span class="line"><span class="attr">CCSC:</span> <span class="string">压缩类空间大小</span></span><br><span class="line"><span class="attr">CCSU:</span> <span class="string">压缩类空间使用大小</span></span><br><span class="line"><span class="attr">OC:</span> <span class="string">老年代大小</span></span><br><span class="line"><span class="attr">OU:</span> <span class="string">老年代使用大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGCT:</span> <span class="string">老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="attr">GCT:</span> <span class="string">垃圾回收消耗总时间</span></span><br></pre></td></tr></table></figure>

<h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity:"></a>-gcoldcapacity:</h5><p>监视内容与-gcold基本相同，主要输出使用到的最大、最小空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcoldcapacity  46416</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">   173568.0   2774528.0    188416.0    188416.0    15     3    0.179    0.271</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">OGCMN:</span> <span class="string">老年代最小容量</span></span><br><span class="line"><span class="attr">OGCMX:</span> <span class="string">老年代最大容量</span></span><br><span class="line"><span class="attr">OGC:</span> <span class="string">当前老年代大小</span></span><br><span class="line"><span class="attr">OC:</span> <span class="string">老年代大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGCT:</span> <span class="string">老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="attr">GCT:</span> <span class="string">垃圾回收消耗总时间</span></span><br></pre></td></tr></table></figure>

<h5 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity:"></a>-gcmetacapacity:</h5><p>监视元数据空间内存情况（jdk1.8之后）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcmetacapacity 46416</span><br><span class="line">MCMN    MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">0.0  1112064.0    72024.0    0.0      1048576.0     9600.0    15     3    0.179    0.271</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">MCMN:</span> <span class="string">最小元数据容量</span></span><br><span class="line"><span class="attr">MCMX:</span> <span class="string">最大元数据容量</span></span><br><span class="line"><span class="attr">MC:</span> <span class="string">当前元数据空间大小</span></span><br><span class="line"><span class="attr">CCSMN:</span> <span class="string">最小压缩类空间大小</span></span><br><span class="line"><span class="attr">CCSMX:</span> <span class="string">最大压缩类空间大小</span></span><br><span class="line"><span class="attr">CCSC:</span> <span class="string">当前压缩类空间大小</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGCT:</span> <span class="string">老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="attr">GCT:</span> <span class="string">垃圾回收消耗总时间</span></span><br></pre></td></tr></table></figure>

<h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><p> 统计所有垃圾回收的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gcutil 46416</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  84.38  28.83  23.97  93.71  90.82     15    0.092     3    0.179    0.271</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">S0:</span> <span class="string">幸存1区当前使用比例</span></span><br><span class="line"><span class="attr">S1:</span> <span class="string">幸存2区当前使用比例</span></span><br><span class="line"><span class="attr">E:</span> <span class="string">伊甸园区使用比例</span></span><br><span class="line"><span class="attr">O:</span> <span class="string">老年代使用比例</span></span><br><span class="line"><span class="attr">M:</span> <span class="string">元数据区使用比例</span></span><br><span class="line"><span class="attr">CCS:</span> <span class="string">压缩使用比例</span></span><br><span class="line"><span class="attr">YGC:</span> <span class="string">年轻代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGC:</span> <span class="string">老年代垃圾回收次数</span></span><br><span class="line"><span class="attr">FGCT:</span> <span class="string">老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="attr">GCT:</span> <span class="string">垃圾回收消耗总时间</span></span><br></pre></td></tr></table></figure>

<h5 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation:"></a>-printcompilation:</h5><p>输出已经被JIT编译的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -printcompilation 46416</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    7728      5    1 com/alibaba/druid/sql/ast/SQLOrderBy getItems</span><br></pre></td></tr></table></figure>

<p>字段说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Compiled:</span> <span class="string">最近编译方法的数量</span></span><br><span class="line"><span class="attr">Size:</span> <span class="string">最近编译方法的字节码数量</span></span><br><span class="line"><span class="attr">Type:</span> <span class="string">最近编译方法的编译类型。</span></span><br><span class="line"><span class="attr">Method:</span> <span class="string">方法名标识。</span></span><br></pre></td></tr></table></figure>

<h4 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo: Java配置信息工具"></a>jinfo: Java配置信息工具</h4><p>jinfo: Configuration Info for Java，能实时地查看和调整虚拟机各项参数。</p>
<p>命令格式：</p>
<blockquote>
<p>jinfo [option] pid</p>
</blockquote>
<p>说明：如果不传入参数，则输出该进程的所有配置信息</p>
<h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><p>Java内存映像工具，<strong>用于生成堆存储快照（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆的详细信息，如空间使用率、当前用的是哪种收集器等。</strong>如果不适用jmap命令，可以使用-XX:+HeapDumpOnOutOfMemoryError参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生</p>
<p>jmap命令格式：</p>
<blockquote>
<p>jmap [option] vmid</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-dump:</span> [<span class="string">live</span>,]<span class="string">format=b,file=&lt;filename&gt;</span> <span class="string">使用hprof二进制形式,输出jvm的heap内容到文件=.</span> <span class="string">live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.</span></span><br><span class="line"><span class="string">-finalizerinfo:</span> <span class="string">打印正等候回收的对象的信息.</span></span><br><span class="line"><span class="string">-heap:</span> <span class="string">打印heap的概要信息，GC使用的算法，heap的配置及wise</span> <span class="string">heap的使用情况.</span></span><br><span class="line"><span class="string">-histo[:live]:</span>  <span class="string">打印每个class的实例数目,内存占用,类全名信息.</span> <span class="string">VM的内部类名字开头会加上前缀”*”.</span> <span class="string">如果live</span> <span class="string">子参数加上后,只统计活的对象数量.</span></span><br><span class="line"><span class="string">-permstat:</span> <span class="string">打印classload和jvm</span> <span class="string">heap长久层的信息.</span> <span class="string">包含每个classloader的名字,活泼性,地址,父classloader</span> <span class="string">和加载的</span> <span class="string">class</span> <span class="string">数量.</span> <span class="string">另外,内部</span> <span class="string">String</span> <span class="string">的数量和占用内存数也会打印出来.</span></span><br><span class="line"><span class="string">-F:</span> <span class="string">强迫.在pid没有相应的时候使用-dump或者-histo参数.</span> <span class="string">在这个模式下,live子参数无效.</span></span><br><span class="line"><span class="string">-h:</span> <span class="string">|</span> <span class="string">-help</span> <span class="string">打印辅助信息</span></span><br><span class="line"><span class="string">-J:</span> <span class="string">传递参数给jmap启动的jvm.</span></span><br></pre></td></tr></table></figure>

<h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。</p>
<h4 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h4><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者<br>javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的<br>目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂<br>起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，<br>就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<p>jstack命令格式：</p>
<blockquote>
<p>jstack [option] vmid</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">-F:</span> <span class="string">当正常输出的请求不被响应时，强制输出线程堆栈</span></span><br><span class="line"><span class="string">-l:</span> <span class="string">除堆栈外，显示关于锁的附加信息</span></span><br><span class="line"><span class="string">-m:</span> <span class="string">如果调用到本地方法的话，可以显示C/C++的堆栈</span></span><br></pre></td></tr></table></figure>

<p>如图</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211128162910171.png" alt="image-20211128162910171"></p>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>JDK除了提供上面所讲的几个强大命令行工具外，还提供了一些可视化工具，可以方便的实时监控正在运行的Java程序。有如下：JHSDB（基于服务性代理的调试工具）、JConsole（Java监视与管理控制台）、VisualVM（多合-故障处理工具）、Java Mission Control（可持续在线的监控工具）。</p>
<h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>在 bin 目录下的 exe 文件中能找到，连接使用即可。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/image-20211128163749286.png" alt="image-20211128163749286"></p>
<h4 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h4><p>在 bin 目录下的 jvisualvm.exe， 点击即可运行    jvisualvm同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，Jvisualvm同jconsole的使用方式一样，jvisualvm界面更美观一些，数据更实时。</p>
<h4 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h4><p>在 bin 目录下的 jmc.exe，具体没有用过，可自行了解，</p>
<h4 id="JHSDB"><a href="#JHSDB" class="headerlink" title="JHSDB"></a>JHSDB</h4><p>未使用过，TODO，使用了在更新。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-日志查看</title>
    <url>/2021/11/19/Linux/Linux-%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux集群搭建</title>
    <url>/2020/08/17/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="部署Linux集群"><a href="#部署Linux集群" class="headerlink" title="部署Linux集群"></a>部署Linux集群</h2><p>最近开始搞linux集群搭建，方便项目部署集群到linux服务器上，我选择安装的是centos7 （据说大多数企业使用的都是这个）</p>
<p>虚拟机比较方便，就算炸了重新安装就好了。</p>
<p>centos下载：</p>
<p>访问其官网，<a href="https://www.centos.org/">官网</a>            点击Get CentOS Now，点击alternative downloads，点击CentOS 7列表中的x86_64，点击</p>
<p><a href="http://mirrors.163.com/centos/7/isos/x86_64/">http://mirrors.163.com/centos/7/isos/x86_64/</a></p>
<p>里边有几个不同的版本。其中这两个比较常用。其他的可以查看0_README.txt中查看各版本的区别。</p>
<p>阿里云站点进行下载</p>
<p>Actual Country 国内资源          Nearby Countries 周边国家资源</p>
<p><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">阿里云站点</a></p>
<p>每个链接都包括了镜像文件的地址、类型及版本号等信息</p>
<p>选择当前国家资源区站点下载，获取资源速度比较快</p>
<a id="more"></a>

<p>在安装时有个三个网络模式不太懂，参考这位博客答主的讲解</p>
<h2 id="虚拟机网络模式"><a href="#虚拟机网络模式" class="headerlink" title="虚拟机网络模式"></a>虚拟机网络模式</h2><p><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">网络模式参考链接</a></p>
<p>无论是vmware,virtual box,virtual pc等虚拟机软件，一般来说，虚拟机有三种网络模式:</p>
<p>1.桥接</p>
<p>2.NAT</p>
<p>3.Host-Only</p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a><strong>桥接</strong></h3><p>  桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p>
<p>  所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。</p>
<p>  例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:</p>
<p>  A:192.168.1.100/255.255.255.0, B:192.168.1.101/255.255.255.0, C:192.168.1.102/255.255.255.0, D:192.168.1.103/255.255.255.0</p>
<p>  那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254(网络地址全0和全1的除外，再除去ABCD四个人的ip地址)</p>
<p> 那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0,设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a><strong>NAT</strong></h3><p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p>
<p>  NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p>
<p>  NAT和桥接的比较:</p>
<p>  (1) NAT模式和桥接模式虚拟机都可以上外网。</p>
<p>  (2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。</p>
<p>  (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</p>
<p>  如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。</p>
<p> 例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。</p>
<p> 但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下nat虚拟网络的信息。</p>
<p> 使用vmware,在Edit-&gt;Virtual Network Editor中配置好虚拟网络信息后看到下图所示，注意VMnet8，VMnet8相当于是本机的一个路由，虚拟机设置NAT后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。</p>
<p> 选择VMnet8-&gt;NAT设置,可以看到子网ip显示为192.168.233.0，子网掩码是255.255.255.0，那路由地址呢，其实就是网关IP了，都是同个东西，这里是192.168.233.2。</p>
<p> 接下来就好办了，在对应的虚拟机设置好ip，子网掩码，路由地址就可以上外网了，至于dns可以设置为8.8.8.8.</p>
<h3 id="Host-Only"><a href="#Host-Only" class="headerlink" title="Host-Only"></a><strong>Host-Only</strong></h3><p> 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p>
<p>　　Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a><strong>综述</strong></h3><p>　　在VMware的3中网络模式中，NAT模式是最简单的，基本不需要手动配置IP地址等相关参数。至于桥接模式则需要额外的IP地址，如果是在内网环境中还很容易，如果是ADSL宽带就比较麻烦了，ISP一般是不会大方的多提供一个公网IP的。</p>
<h2 id="安装centos7"><a href="#安装centos7" class="headerlink" title="安装centos7"></a>安装centos7</h2><p>虚拟机点击新建，新建虚拟机，然后选择下载好的centos7安装包就好了。</p>
<p>设置分配内存的大小为20G</p>
<p>自定义硬件设置</p>
<p>内存建议至少1GB。处理器数量选择1，每个处理器的核心数量选择2，这样相当于1颗物理CPU，2颗逻辑CPU。网络适配器，选择NAT模式，这种网络模式是兼容性最好的。选择下载的ISO镜像文件。</p>
<p>网络部分我选择了桥接模式</p>
<ul>
<li>桥接模式：这种模式下，虚拟机和物理机连的是同一个网络，虚拟机和物理机是并列关系，地位是相当的。比如，你家有路由器，那么你的电脑和你的手机同时连接这个路由器提供的Wi-Fi，那么它们的关系就是这种模式。</li>
<li>NAT模式：这种模式下，物理机会充当一个“路由器”的角色，虚拟机要想上网，必须经过物理机，那物理机如果不能上网，虚拟机也就不能上网了。之所以说这种模式兼容性最好，是因为物理机的网络环境变化时，虚拟机的网络并不会有影响，比如，上班时你把物理机连接在公司的网络环境中，下班后又把物理机连接在你家的路由器上。你公司的网段有可能和你家的网段是不同的。桥接模式下，虚拟机和物理机一样，都要自动获取IP才可以上网，而做实验的时候，是需要把虚拟机设置为静态IP的，这样就导致虚拟机网络不稳定。而设置为NAT模式，虚拟机的网络并不需要依赖你公司的网络环境或者你家的网络环境。</li>
<li>仅主机模式：这种模式下，相当于拿一根网线直连了物理机和虚拟机。</li>
</ul>
<h3 id="安装配置：按需选择。"><a href="#安装配置：按需选择。" class="headerlink" title="安装配置：按需选择。"></a>安装配置：按需选择。</h3><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723144209165.png" alt="image-20200723144209165"></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723144227158.png" alt="image-20200723144227158"></p>
<p>安装位置：我选择自动安装</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE1.png" alt="image-20200723144351201"></p>
<p>设置密码，也可以创建用户，我选择安装完之后在创建</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723152934777.png" alt="image-20200723144448701"></p>
<p>安装完成后重启</p>
<p>同意协议后完成配置</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723153112140.png" alt="image-20200723152934777"></p>
<p>设置用户：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723144448701.png" alt="image-20200723153112140"></p>
<p>安装完成，接下来配置网络</p>
<h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p><strong>子网Ip设置</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200723144351201.png" alt="image-20200817003918081"></p>
<p><strong>Nat设置</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/Nat%E8%AE%BE%E7%BD%AE.png" alt="image-20200817004200255"></p>
<p><strong>DHCP设置</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE.png" alt="image-20200817004238527"></p>
<p>打开控制中心的网络设置，再VMnet8中设置IP地址和网关</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEIp%E5%9C%B0%E5%9D%80.png" alt="image-20200817010918519"></p>
<p>再设置界面中手动设置IP地址</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/ssh%E7%99%BB%E5%BD%95%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="image-20200817005146362"></p>
<p>还有手动配置网卡</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%B9%B3%E5%A4%96%E7%BD%91%E5%92%8C%E6%9C%AC%E6%9C%BA%E5%9C%B0%E5%9D%80.png" alt="image-20200816234553228"></p>
<p>试着ping一下外网和本机地址，发现都能测通，那就没问题了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/DHCP%E8%AE%BE%E7%BD%AE.png" alt="image-20200817010017038"></p>
<p>这样网络就配置好了；也可以手动配置   </p>
<blockquote>
<p>cd /etc/sysconfig/network-scripts/<br>vim ifcfg-ens33 </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static <span class="comment"># 设置静态Ip地址  不然会自动分配（DHCP）</span></span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=2822479b-53eb-45cc-ba8e-78fe5b353ee4</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.80.128   <span class="comment">#手动指定Ip地址</span></span><br><span class="line">GETWAY=192.168.80.1        <span class="comment">#网关</span></span><br><span class="line">NETMASK=255.255.255.0    <span class="comment">#子网掩码</span></span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">HWADDR=00:0C:29:A2:87:C1    <span class="comment">#网卡MAC地址</span></span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.80.1    </span><br><span class="line"></span><br><span class="line"><span class="comment">#最后更新一下网络服务</span></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>

<p>配置完，刷新一下网络，然后就发现外网和主机都能ping通了</p>
<p><a href="https://blog.csdn.net/qqxyy99/article/details/80864862">参考链接</a></p>
<p>ping通之后就可以ssh登录虚拟机来进行远程的操作，</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1.png" alt="image-20200817000006478"></p>
<p>ps：如果没关防火墙记得关</p>
<blockquote>
<p>1.查看状态：service iptables status<br>2.关闭： service iptables stop<br>3.查看启动：chkconfig iptables –list<br>4.禁止启动：chkconfig iptables off</p>
</blockquote>
<ol>
<li>查看防火墙状态  </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>暂时关闭防火墙 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">service  iptables stop</span><br></pre></td></tr></table></figure>

<p>   3.永久关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>

<p>​    4:重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure>

<h3 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h3><p>时间同步插件</p>
<blockquote>
<p> yum -y install ntpdate   时间同步插件</p>
<p> ntpdate cn.pool.ntp.org # 同步时间</p>
<p> hwclock –systohc   将时间写入硬盘</p>
</blockquote>
<h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><p>在原有的虚拟机上右键点击克隆，完整克隆，在新的目录下保存就好了，这一步克隆好了没截图</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="image-20200817020432436"></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%AE%8C%E6%95%B4%E5%85%8B%E9%9A%86.png" alt="image-20200817020701106"></p>
<p>这样另外两台虚拟主机就完成了，只需要将IP地址和主机MAC地址相应的修改一下就好了,对应关系</p>
<blockquote>
<p>Centos01 192.168.80.128</p>
<p>Centos02 192.168.80.129</p>
<p>Centos03 192.168.80.130</p>
</blockquote>
<p>然后测试一下相互之间的网络能通，这样一个linux的网络集群就搭建好了，接下来就是安装软件已经环境配置了，你们也可以先在一部虚拟机上安装好需要的软件和环境在克隆。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E4%B8%BB%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E8%83%BD%E9%80%9A.png" alt="image-20200817124025700"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>jackson 从1.8 升级到 2.9踩坑记录</title>
    <url>/2021/12/28/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/bug-jackson/</url>
    <content><![CDATA[<p>​    JDK1.7 升级到 JDK 1.8，spring 3.x 升级到 spring4.3.x ，SpringMVC 默认使用的 JSON 解析器就是 Jackson，因此 原来版本的 Jackson1.8.x 升级到 2.9.x 踩坑记录。</p>
<p>​    问题：在没改动前端代码的情况下，Post 请求失败。</p>
<a id="more"></a>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>​    发现问题：在 debug 的过程中，发现 spring 的 dispacherServlet 捕获到了异常：JSON parse error: Cannot deserialize instance of <code>java.util.String</code> out of START_OBJECT token，该异常为 JSON 转化异常。在处理请求参数后，直接抓到该异常。</p>
<p><img src="D:\blog\githubBolg\source_posts\踩坑日记\image\image-20211228161715332.png" alt="image-20211228161715332"></p>
<p>​    在前端发现，请求的携带参数为多重嵌套的对象，和后端接口中的 @RequestBody 中对象的成员变量不一一对应。。也就是前后端传递数据时，出现的 JSON 格式转化错误，导致前端请求不到后端接口。</p>
<p>​    该错误在我使用 Jsckson1.8 版本时没有出现，后面升级才出现该问题。</p>
<p><a href="https://github.com/FasterXML/jackson/wiki/JacksonRelease1.8">Jackson1.8 说明</a>  </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112281705876.png" alt="image-20211228170538808"></p>
<p><a href="https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.4">Jackson2.9.4 说明</a></p>
<p><a href="https://juejin.cn/post/6844904166809157639#heading-2">Jackson 使用教程</a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    我的处理方式将前端多重嵌套的对象转化 JSON 格式的字符串传递参数。即通过 JSON.stringify  转化。</p>
<p>其余方式（参考）</p>
<ol>
<li>通过 <code>map&lt;String,Object&gt;</code> 来获取数据，也就是 <code>@RequestBody Map&lt;String, Object&gt; data</code></li>
<li>通过定义对应的对象类型来获取数据。</li>
</ol>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 1.7 升级 到 1.8 出现跨域问题</title>
    <url>/2021/12/28/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/update-jdk1-8/</url>
    <content><![CDATA[<p>​    前后端联调时，在未修改跨域请求处理的代码的情况下，出现  <code>been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code> 的异常。请求不到后端的接口，导致请求失败，初步判断是升级 JDK 导致的。</p>
<a id="more"></a>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><p>在经过 debug 后，spring 接收到请求后，原本是 <strong>POST</strong> 请求的被转化为 <strong>OPTIONS</strong> 请求。导致出现跨域异常。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202112281814649.png" alt="image-20211228181411176"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    由于当时使用的容器为 Jetty6.4.x 和 tomcat 1.7，均为较低版本的容器（均为JDK1.8出现之前），所以定位问题到 Jetty 和 tomcat 容器版本比较低和升级后的 JDK1.8、spring4.x 不兼容导致。在将容器 Jetty 升级为 9.4.x 和 Tocat 升级为 1.8 后该问题解决。</p>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2020/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>这学期上了计算机网络的课程，觉得这门课十分有用，使我对于网络各个方面的内容有了大致的了解，现在暑假来了，准备复习总结，准备开学的考试，还有面试准备。</p>
<h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h3><p> 首先，什么是计算机网络呢？一般认为，计算机网络是一个将分散的/具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。简而言之，计算机网络就是一些互联的、自治的计算机系统的集合。是网络的网络，互联网把许多网络连接在一起。</p>
<a id="more"></a>

<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p> <strong>1、按分布范围</strong></p>
<ul>
<li><p>广域网（WAN），广域网的任务是提供长距离通信，运送主机所发送的数据，覆盖范围通常为几万米到几十万米的区域。</p>
</li>
<li><p>城域网（MAN），城域网的覆盖范围可以跨越几个街区甚至整个城市，范围大概 5-50km。</p>
</li>
<li><p>局域网（LAN），局域网一般是用微机或者工作站通过高速线路相连接，覆盖范围较小，一般几十米到几千米的区域；局域网在计算机配置的数量上没有太多限制，少的可以只有 2 台，多的可以有几百台。传统上，局域网采用广播技术，广域网采用交换技术。、</p>
</li>
<li><p>个人区域网（PAN）。个人区域网是指在个人工作的地方将电子设备用无线技术连接起来的网络，也常常称为无线个人区域网，覆盖直径大小约为 10m。</p>
<p><strong>2、按传输技术分类</strong></p>
</li>
<li><p>广播式网络：所有的联网计算机都共享一个公共的通信信道，当一台计算机利用共享的通信信道发送报文分组时，所有其他的计算机都会收听到这个分组，接收到该分组的计算机通过检查目的地址，来决定是否接受该分组，<code>局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术</code></p>
</li>
<li><p>点对点网络：每条物理线路链接一对计算机。如果通信的两台主机之间没有直接相连的线路，那么他们呢之间的分组传输通过中间结点的接收、存储和转发，直至目的节点。<code>广域网基本属于点对点网络</code></p>
<p><strong>3、按使用者分类</strong></p>
</li>
<li><p>公用网</p>
</li>
<li><p>专用网</p>
<p><strong>4、按拓扑结构分类</strong></p>
</li>
<li><p>星型网络</p>
</li>
<li><p>总线型网络</p>
</li>
<li><p>环形网络</p>
</li>
<li><p>网状型网络</p>
<p><strong>5、按交换技术分类</strong></p>
</li>
<li><p><strong>电路交换网络：</strong>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。适用于数据量很大的实时通信</p>
</li>
<li><p><strong>报文交换网络：</strong>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</p>
</li>
<li><p><strong>分组交换网络：</strong>分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。</p>
<ul>
<li>优点：高效、灵活、迅速、可靠</li>
<li>缺点：时延大、开销大</li>
</ul>
<p>三种交换方式的比较</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="image-20200730194934591"></p>
<p><strong>6、按传输介质分类</strong></p>
</li>
<li><p>有线网和无线网络</p>
</li>
</ul>
<p><strong>几种常用的信道复用技术</strong></p>
<p><img src="G:\JavaNotes\blog\hexo\source_posts\计算机网络概述.assets\信道复用技术.png" alt="image-20200731164608280"></p>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ol>
<li><p>带宽：表示网络通信线路所能传送数据的能力，时数字信道所能传送的<strong>“最高数据率”</strong>。单位时 bit/s 比特每秒。</p>
</li>
<li><p>时延：指一个数据由一段传送到另一端所需要的时间，由以下四部分组成</p>
<ol>
<li><p>发送时延:主机或路由器发送数据帧所需要的时间，即：从发送数据帧的第一个比特算起到该帧的最后一个比特发送完毕所需要的时间。</p>
<blockquote>
<p>计算公式：发送时延=分组长度/信道宽度<img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6.png" alt="image-20200730231153515"></p>
</blockquote>
</li>
<li><p>传播时延:电磁波在信道中传播一定的距离需要花费的时间。</p>
<blockquote>
<p>计算公式：传播时延=信道长度/电磁波传播速率<img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6.png" alt="image-20200730231214312"></p>
</blockquote>
</li>
<li><p>处理时延:主机或路由器在收到分组时要花费一定的时间进行处理。例如：分析分组的首部信息、从分组中提取数据部分、进行差错检验或查找适当的路由等等。</p>
</li>
<li><p>排队时延:分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。排队时延的长短取决于网络中的通信量。</p>
<blockquote>
<p>总时延：排队时延+发送时延+传播时延+处理时延</p>
</blockquote>
</li>
</ol>
</li>
<li><p>时延带宽积：指发送端连续发送的数据且发送的第一个比特发送即将到达终点时，发送端已经发送的比特数、即传播时延*带宽</p>
</li>
<li><p>吞吐量：指单位时间内通过某个网络的数据量</p>
</li>
<li><p>速率：计算机网络在数字信道上的传播速率，b/s（比特每秒）</p>
</li>
<li><p>往返时间(RTT)：从发送方发送数据开始，到发送方收到接收方确认。</p>
<blockquote>
<p>发送时间=数据长度/发送速率</p>
</blockquote>
<blockquote>
<p>有效数据率=数据长度/（发送时间+RTT）</p>
</blockquote>
</li>
</ol>
<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>ISO：国际化标准组织</p>
</li>
<li><p>OSI/RM:互联网<strong>法律上</strong>的国际标准</p>
</li>
<li><p>TCP/IP Suite:因特网<strong>实际上</strong>的国家标准</p>
</li>
<li><p>Network Protocols:数据交换遵守的<strong>标准、规则、约定</strong>。</p>
</li>
<li><p>网络体系结构：计算机网络<strong>各层及其协议</strong>的<strong>集合</strong>。</p>
<p>计算机网络分层可以使整个计算机网络各层之间<strong>独立</strong>，<strong>灵活性好</strong>，结构上<strong>可分割</strong>开，能<strong>促进标准化</strong>工作，呈现<strong>高内聚和低耦合</strong>，易于<strong>实现和维护</strong>。</p>
</li>
</ul>
<h3 id="OSI-参考模型（7-层）和-TCP-IP-模型"><a href="#OSI-参考模型（7-层）和-TCP-IP-模型" class="headerlink" title="OSI 参考模型（7 层）和 TCP/IP 模型"></a>OSI 参考模型（7 层）和 TCP/IP 模型</h3><h4 id="OSI-参考模型（7-层）"><a href="#OSI-参考模型（7-层）" class="headerlink" title="OSI 参考模型（7 层）"></a>OSI 参考模型（7 层）</h4><ol>
<li><p><strong>应用层</strong>：能够产生<strong>网络流量</strong>和用户交互的程序</p>
</li>
<li><p><strong>表示层</strong>：两个通信系统交换信息的表示方式，加密、压缩等、开发人员需考虑。</p>
</li>
<li><p><strong>会话层：</strong>不同主机之间的各个进程建立会话（netstat -nb 可查看木马程序）</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%9F%A5%E7%9C%8B%E6%9C%A8%E9%A9%AC%E7%A8%8B%E5%BA%8F.png" alt="image-20200730234434048"></p>
</li>
<li><p><strong>传输层：</strong>为主机建立进程间的通信，提供端到端的可靠传输服务，提供流量控制，服务质量，数据传输管理；传输层的协议有 UDP、TCP。</p>
</li>
<li><p><strong>网络层：</strong>IP 地址编址，选择最佳路径</p>
</li>
<li><p><strong>数据链路层：</strong>封装数据、差错控制、添加物理层地址、MAC 地址</p>
</li>
<li><p><strong>物理层：</strong>定义通信设备的数据通信设备和逻辑链接方法，还有电压标准，接口标准，如机械特性，电气特性，功能特性，过程特性。</p>
</li>
</ol>
<h4 id="TCP-IP-模型（四层）"><a href="#TCP-IP-模型（四层）" class="headerlink" title="TCP/IP 模型（四层）"></a>TCP/IP 模型（四层）</h4><ul>
<li>应用层：包括 OSI 模型的应用层、表示层、会话层</li>
<li>传输层：对应 OSI 的传输层</li>
<li>网络层：对于 OSI 的网络层</li>
<li>网络接口层：对于 OSI 接口的数据链路层和物理层</li>
</ul>
<p>两个模型的比较：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/JavaNote/IO%E5%AD%A6%E4%B9%A0/OSI%E5%92%8CTCP%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="OSI和TCP模型的比较"></p>
<p>学习计算机网络时，我们往往采用折中的办法，即综合 OSIhe TCP/Ip 的优点，如图所示</p>
<p><strong>五层协议对应的数据单元：</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.png" alt="image-20200731124844123"></p>
<h3 id="OSI-与-TCP-IP-各层的结构与功能、协议"><a href="#OSI-与-TCP-IP-各层的结构与功能、协议" class="headerlink" title="OSI 与 TCP/IP 各层的结构与功能、协议"></a>OSI 与 TCP/IP 各层的结构与功能、协议</h3><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE.png" alt="三种协议"></p>
<p>在应用层交互的数据叫报文，报文经过运输层（TCP/UDP）转换成段，然后在网络层经过路径选择，在首部添加 IP 地址变成数据包（也叫<strong>IP 数据报</strong>），在数据链路层加上 MAC 地址组装成<strong>帧</strong>，在物理层传输时加上帧头帧位变成比特流。</p>
<h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>下面为两个主机之间发送数据的整个过程：</p>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B.png" alt="image-20200731125226123"></p>
<p><strong>计算机 2 的物理层收到比特流后交给数据链路层</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B1.png" alt="image-20200731125355111"></p>
<p><strong>数据链路层剥去帧首部和帧尾部后把帧的数据部分交给网络层</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B2.png" alt="image-20200731125407631"></p>
<p><strong>网络层剥去分组首部后把分组的数据部分交给运输层</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B3.png" alt="image-20200731125427613"></p>
<p><strong>应用层剥去应用层 PDU 首部后把应用程序数据交给应用进程</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B4.png" alt="image-20200731125441438"></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B5.png" alt="image-20200731125455193"></p>
<p>这样就收取到了主机 AP1 发来的应用程序数据</p>
<h2 id="重要的知识点总结"><a href="#重要的知识点总结" class="headerlink" title="重要的知识点总结"></a>重要的知识点总结</h2><ol>
<li>计算机网络把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</li>
<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</li>
<li>大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>
<li>路由器是实现分组交换的关键构件，其任务是转发收到的分别，这是网络的核心部分最重要的功能。分组交换采用存储转发的技术，表示把一个报文分成几个分组后在进行传送，在发送报文之前，先把报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组，分组又称为包，分组时在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要的控制信息，每一个分组才能在互联网中独立选择传输路径，并且正确的交付分组传输的终点。</li>
<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理，由大量的网络和连接这些网络的路由器组成核心部分，其作用是提供联通性和交换。</li>
<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>
<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>
<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>
<li>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</li>
<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>
<li>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-线程池</title>
    <url>/2021/11/23/JUC/JavaThreadPool/</url>
    <content><![CDATA[<h1 id="1-概念与设计"><a href="#1-概念与设计" class="headerlink" title="1. 概念与设计"></a>1. 概念与设计</h1><blockquote>
<p>参考技术文章 <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">参考链接</a></p>
<p>《Java 并发编程的艺术 》</p>
<p>本节通过学习理论知识，并通过相关的源代码实现进行学习。</p>
</blockquote>
<h2 id="1-1-线程池的概念"><a href="#1-1-线程池的概念" class="headerlink" title="1.1 线程池的概念"></a>1.1 线程池的概念</h2><p>线程池是一种基于池化思想的线程管理工具。</p>
<a id="more"></a>

<p>线程过多会带来额外的开销，其中包括线程销毁、创建、调度等，降低了计算机的性能。线程管理者管理和维护线程，等待使用者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p>池化技术现在已经屡见不鲜了，如线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<p>线程池的作用：</p>
<ul>
<li><p>降低了资源消耗，通过线程池管理可以重复利用已经创建好的线程，无需重复创建和销毁，降低了系统资源的消耗。</p>
</li>
<li><p>提高响应速度，任务到达后，无需等待线程创建既可执行</p>
</li>
<li><p>提高线程的可管理性，使用线程池可以统一的分配、调优和监控线程</p>
</li>
<li><p>线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池<code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定行。</p>
</li>
</ul>
<h2 id="1-2-Java中的线程池实现类"><a href="#1-2-Java中的线程池实现类" class="headerlink" title="1.2 Java中的线程池实现类"></a>1.2 Java中的线程池实现类</h2><p>Java中的线程池核心实现类是<code>ThreadPoolExecutor</code>,该类在Java中的继承关系如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22926677/1635938710209-058cdf9a-93d6-4948-9f31-1a4d5d7961e6.png" alt="img"></p>
<p>ThreadPoolExecutor 实现的顶层接口是 Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService 接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService 则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor 实现最复杂的运行部分，ThreadPoolExecutor 将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22926677/1635939051924-d80d6f71-3d20-40fc-9cbf-0105e053b816.png" alt="img"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p>那么线程运行的机制主要有三点，</p>
<p>1、线程池自身的状态维护；</p>
<p>2、线程池的任务维护；</p>
<p>3、线程池的线程维护；</p>
<p>查看 ThreadPoolExecutor 的构造方法可以看出，线程池由7个核心的参数来决定。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 核心线程数</li>
<li><code>maximumPoolSize</code> 最大线程数</li>
<li><code>keepAliveTime</code> 存活时间</li>
<li><code>unit</code> 时间单位</li>
<li><code>BlockingQueue</code> 阻塞队列</li>
<li><code>defaultThreadFactory</code> 线程工厂</li>
<li><code>defaultHandler</code>  线程处理策略</li>
</ul>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量，ThreadPoolExecutor 类中的线程状态变量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer.Size 的值为 32</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高三位为 111 表示接收新任务，同时处理任务队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 高三为为 000 表示不接收新任务，但是处理队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 高三位为 001 表示中断正在执行的任务，同时抛弃阻塞队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 高三位为 010 表示任务执行完毕，活动线程为 0 时，即将进入终结阶段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 高三位为011 表示终结状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程池状态和线程池中线程的数量由一个原子整型 ctl 来共同表示。使用一个数来表示两个值的主要原因是：可以通过一次 CAS 同时更改两个属性的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原子整数，前 3 位保存了线程池的状态，剩余位保存的是线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是有个问题就是 并不是所有平台的 int 都是 32 位。</span></span><br><span class="line"><span class="comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span></span><br><span class="line"><span class="comment">// 高3位为0，剩余位数全为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数 也就是 Int.Size()-3</span></span><br><span class="line"><span class="comment">// CAPACITY 的高3位为 0 ；操作左移相应的位数 再减一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>获取线程池状态、线程数量以及合并两个值的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="comment">// 该操作会让除高3位以外的数全部变为0 与非操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取运行线程数</span></span><br><span class="line"><span class="comment">// 该操作会让高3位为0 与操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 计算ctl新值</span></span><br><span class="line"><span class="comment">// 或运算 合并两个值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码均在 ThreadPoolExcutor 中</p>
<p>线程池状态转化如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="图3 线程池生命周期"></p>
<h3 id="任务运行"><a href="#任务运行" class="headerlink" title="任务运行"></a>任务运行</h3><h4 id="任务调度规则"><a href="#任务调度规则" class="headerlink" title="任务调度规则"></a>任务调度规则</h4><p>任务调度是线程池的核心运行机制。所有的调度任务都由 Execute 完成。可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 execute()方法用于提交不需要返回值的任务，而 submit() 方法用于提交需要返回值的任务。这部分完成的工作时：检查线程池的运行状态、运行数线程、决定接下来的任务运行流程，是运行该任务、缓存到队列中或者是拒绝任务。</p>
<p>其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果 workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果 workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果 workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果 workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         * 1. 首先检查线程池的状态是否为 running，如果不是则拒绝任务加入。否则进行 2</span></span><br><span class="line"><span class="comment">         * 2. 如果工作线程小于核心线程数，那么将尝试新建一个线程分配给任务</span></span><br><span class="line"><span class="comment">         * 3. 如果工作线程大于核心线程数，且工作线程小于最大线程数、工作队列已满，</span></span><br><span class="line"><span class="comment">         *    那么则新建线程执行任务，工作队列未满则加入队列。</span></span><br><span class="line"><span class="comment">         * 4. 如果工作线程数量大于最大线程数，且工作任务队列已满，那么则根据拒绝策略拒绝该任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="任务缓存队列"><a href="#任务缓存队列" class="headerlink" title="任务缓存队列"></a>任务缓存队列</h4><p>任务缓存是线程池管理任务的核心部分。当任务生产者生产任务过多时，为防止任务丢失，需要以队列的形式将任务存放，等待线程消费者进行消费。线程池使用的是阻塞队列来实现缓存任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>
<p><img src="https://p1.meituan.net/travelcube/f4d89c87acf102b45be8ccf3ed83352a9497.png" alt="图5 阻塞队列"></p>
<p>阻塞队列保证，无论并发多高，任意时刻都是线程安全的：即保证只有一个线程入队或出对。JUC中为线程池创建提供了多种阻塞队列供使用。</p>
<p>查看一下阻塞队列的实现队列，如图所示。</p>
<p>​    <img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111241407769.png" alt="image-20211124140751487"></p>
<p>相关队列的具体介绍。</p>
<p><img src="https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png" alt="img"></p>
<h4 id="任务申请获取"><a href="#任务申请获取" class="headerlink" title="任务申请获取"></a>任务申请获取</h4><p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由 getTask 方法实现，其执行流程如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png" alt="图6 获取任务流程图"></p>
<h4 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h4><p>当任务队列满、线程数量大于最大线程数量时，那么线程池就会根据拒绝策略进行拒绝。保护线程池。</p>
<p>拒绝策略的接口如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口有四个实现类，也就是四种拒绝策略。具体如下图所示。</p>
<p><img src="https://p0.meituan.net/travelcube/9ffb64cc4c64c0cb8d38dac01c89c905178456.png" alt="img"></p>
<p>这里比较有意思的就是第四种 CallerRunsPolicy ，会执行所有的任务。查看该源码，发现重写的拒绝策略，只要线程池状态为不为 shutdown，那么就又该线程去处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><h4 id="工作线程-Worker"><a href="#工作线程-Worker" class="headerlink" title="工作线程 Worker"></a>工作线程 Worker</h4><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png" alt="图7 Worker执行任务"></p>
<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张 Hash 表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>Worker是通过继承 AQS( AbstractQueuedSynchronizer )，使用 AQS 来实现独占锁这个功能。没有使用可重入锁 ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 </p>
</li>
<li><p>如果正在执行任务，则不应该中断线程。</p>
</li>
<li><p>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。</p>
</li>
<li><p>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
</li>
<li></li>
</ol>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png" alt="图8 线程池回收过程"></p>
<h4 id="增加线程"><a href="#增加线程" class="headerlink" title="增加线程"></a>增加线程</h4><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png" alt="图9 申请线程执行流程图"></p>
<h4 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h4><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png" alt="图10 线程销毁流程"></p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
<h4 id="执行工作"><a href="#执行工作" class="headerlink" title="执行工作"></a>执行工作</h4><p>在 Worker 类中的 run方法调用了 runWorker 方法来执行任务，runWorker 方法的执行过程如下：</p>
<ol>
<li><p>while 循环不断地通过getTask() 方法获取任务。</p>
</li>
<li><p>getTask() 方法从阻塞队列中取任务。</p>
</li>
<li><p>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</p>
</li>
<li><p>执行任务。</p>
</li>
<li><p>如果 getTask 结果为 null 则跳出循环，执行 processWorkerExit() 方法，销毁线程。</p>
</li>
</ol>
<p>执行流程如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png" alt="图11 执行任务流程"></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-基础</title>
    <url>/2021/08/04/JUC/juc-base/</url>
    <content><![CDATA[<blockquote>
<p>该篇是学习并发编程相关的基础知识</p>
<p>参考 《Java 并发编程的艺术 》 <a href="https://blog.csdn.net/weixin_44630656/article/details/119835383">参考博客</a></p>
<p>万丈高楼平地起，唯有基础扎实才能筑起筑起属于自己的高楼大厦。</p>
</blockquote>
<a id="more"></a>

<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程：线程是 CPU 调度的最小单位也叫轻量级进程（Light  Weight  Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。  </p>
<p>进程：进程是程序的一次执行过程，是 CPU 资源分配的最小单位，每个进程都有自己的独立空间，一个进程可以有多个线程。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>根本区别：进程是操作系统资源分配的基本单位。线程是处理器任务调度和执行的基本单位</li>
<li>资源开销：每个进程都有独立的代码和数据空间。程序之间的切换有比较大的开销。线程可以看做是轻量级的进程，同一类线程共享堆和方法区，每个线程有自己的程序计数器、虚拟机栈、本地方法栈，线程之间切换开销比较小。</li>
<li>包含关系：一般一个进程内有多个线程，执行过程不是一条线的，而是由多个线程共同完成；线程是进程的一部分，所以被称为轻量级进程</li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃可能导致整个进程都死掉。所以多进程要比多线程健壮。</li>
</ul>
<p><strong>并行和并发有什么区别？</strong></p>
<ul>
<li>并行是指两个或者多个事件在<strong>同一时刻发生</strong></li>
<li>并发是指两个或多个事件在<strong>同一时间间隔发生</strong></li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>当线程创建后，并不是启动就进入执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocaked）和死亡（Dead）5种状态。尤其是当线程启动后，不能一直独占 CPU，CPU 需要在多线程之间切换，于是线程会在运行、阻塞之间切换。</p>
<h5 id="新建状态（New）"><a href="#新建状态（New）" class="headerlink" title="新建状态（New）"></a>新建状态（New）</h5><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，虚拟机为其分配内存，并初始化成员变量的值。</p>
<h5 id="就绪状态（Runnable）"><a href="#就绪状态（Runnable）" class="headerlink" title="就绪状态（Runnable）"></a>就绪状态（Runnable）</h5><p>当调用了线程的 start 方法后，该线程处于就绪状态，Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h5 id="运行状态（Running）"><a href="#运行状态（Running）" class="headerlink" title="运行状态（Running）"></a>运行状态（Running）</h5><p>如果处于就绪状态的线程获得了 CPU 分配时间，开始执行 run 方法中的线程执行体，则该线程处于运行状态。</p>
<h5 id="阻塞状态（Blocked）"><a href="#阻塞状态（Blocked）" class="headerlink" title="阻塞状态（Blocked）"></a>阻塞状态（Blocked）</h5><p>阻塞状态是指线程因为某种原因放弃了 CPU 的使用权，让出 CPU 时间片，暂停停止运行，知道线程进入到就绪（Runnable）状态，才有机会再次获得时间片进入运行状态。阻塞的情况分为三种：</p>
<ul>
<li>等待阻塞（0.wait -&gt; 等待队列）：运行中的线程执行 o.wait 方法，JVM 会把线程放入等待队列中</li>
<li>同步阻塞（lock-&gt; 锁池）：运行中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中（ lock pool）</li>
<li>其他阻塞（sleep、Join）：运行中的线程执行 Thread.sleep(long ms) 或 t.join()方法，或者发出了 I/O 请求时，JVM 会把线程置为阻塞状态，当 sleep() 方法超时，join() 等待线程终止或者超时，或者 I/O 处理完毕时，线程重新转入可运行状态。</li>
</ul>
<h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以下面三种方式结束，结束后就是死亡状态</p>
<ul>
<li>正常结束：run() 或 call() 方法执行完成，线程正常结束。</li>
<li>异常结束：线程抛出一个未捕获的 Exception 或 Error。</li>
<li>调用 stop: 直接调用 stop 方法来结束线程，该方法容易导致死锁。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111251456953.png" alt="image-20211125145627824"></p>
<h3 id="Java-线程的创建"><a href="#Java-线程的创建" class="headerlink" title="Java 线程的创建"></a>Java 线程的创建</h3><p>创建线程的方式有很多种，主要有以下四种，代码实现多种多样，我只列举我的仅供参考。</p>
<h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>Thread 类本质上是实现了 Runnable 接口的一个实例。代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法调用了 native 方法，它将启动一个新线程，并执行 run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        threadDemo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start 方法调用的 native 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>如果一个类已经继承了其他的类，那么就无法继承 Thread 接口，此时可以实现 Runnable 接口，重写其中的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">otherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadDemo,<span class="string">&quot;thread&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="Callable有返回值线程"><a href="#Callable有返回值线程" class="headerlink" title="Callable有返回值线程"></a>Callable<Class>有返回值线程</h4><p>有返回值的任务必须实现 Callable 接口，执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;   执行callable的call方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建callable对象</span></span><br><span class="line">        Callable&lt;String&gt; myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 2.由上面的callable对象创建一个FutureTask对象</span></span><br><span class="line">        FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(myCallable);</span><br><span class="line">        <span class="comment">// 3.由FutureTask创建一个Thread对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">        <span class="comment">// 4.开启线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 提交多个线程任务，并执行</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running ..&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable-和-Callable-的区别"><a href="#Runnable-和-Callable-的区别" class="headerlink" title="Runnable 和 Callable 的区别"></a>Runnable 和 Callable 的区别</h4><p>相同点：都是接口、可以编写多线程程序且都才用 Thread.start() 启动线程。</p>
<p>区别：Runnable 接口的 run 方法无返回值；Callable 的 call 方法有返回值，且支持返回泛型，允许抛出异常，返回的结果支持 Furture 的 get 方法异步获取结果。</p>
<h4 id="线程的-run-和-start-的区别"><a href="#线程的-run-和-start-的区别" class="headerlink" title="线程的 run 和 start 的区别"></a>线程的 run 和 start 的区别</h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 多次调用会抛出 java.lang.IllegalThreadStateException 异常</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h4 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep 和 wait 的区别"></a>sleep 和 wait 的区别</h4><ol>
<li>sleep 属于 Thread 中的，wait 属于 Object 类中的，</li>
<li>sleep 方法导致程序暂停指定时间，让出 CPU 给其他线程，但是他的监控状态依然保持着，当指定时间结束又会恢复到运行状态。</li>
<li>当调用 sleep 方法的过程中，线程不会释放对象锁。</li>
<li>当调用 wait 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象的调用 notify 方法后，本线程才进入对象锁池准备获取对象锁进入运行状态。</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>守护线程是 Java 的后台线程，也称为“服务线程”，为用户线程提供公共服务。在没有用户线程可服务时，会自动离开。</p>
</li>
<li><p>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</p>
</li>
<li><p>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程</p>
</li>
</ol>
<p>的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。</p>
<ol start="4">
<li><p>在 Daemon 线程中产生的新线程也是 Daemon 的。</p>
</li>
<li><p>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。</p>
</li>
<li><p>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p>
</li>
<li><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 </p>
</li>
</ol>
<h2 id="并发存在的问题"><a href="#并发存在的问题" class="headerlink" title="并发存在的问题"></a>并发存在的问题</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>多线程执行代码，避免不了线程之间的上下文切换。CPU 通过给每个线程分配 CPU 时间片来实现多线程执行代码，而时间片非常短，所以 CPU 通过不停的切换线程执行，让我们感觉到多个线程是同步执行的。</p>
<p>在线程切换前会保存上一个任务的状态，这个信息由线程的 PC、虚拟机栈等私有内存。因此在每次切换线程都需要保存上一个任务的信息以及读取下一个任务的状态，是影响 CPU 的效率和多线程的执行速度的。</p>
<p>使用多线程可能会带来内存泄漏、死锁、线程不安全等等问题，这些都是需要去解决的。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。 </p>
<ul>
<li><p>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 </p>
</li>
<li><p>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。 </p>
</li>
<li><p>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这 样会造成大量线程都处于等待状态。 </p>
</li>
<li><p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>
<h4 id="产生死锁的原因主要是："><a href="#产生死锁的原因主要是：" class="headerlink" title="产生死锁的原因主要是："></a>产生死锁的原因主要是：</h4><p>（1） 因为系统资源不足。</p>
<p>（2） 进程运行推进的顺序不合适。</p>
<p>（3） 资源分配不当等。</p>
<p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p>
<h4 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h4><p>（1） 互斥条件：一个资源每次只能被一个进程使用。</p>
<p>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>锁的状态共有4种，无锁状态、偏向锁、轻量级锁和重量级锁。将锁进一步的细化，有助于提升程序并发性能。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，。<strong>偏向锁的目的是在某个线程获得锁之后，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</strong>（该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁，而只需简单的测试一下对象头的 Mark Word（对象头的一个标志） 里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 CAS 竞争锁，如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</p>
<p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语， 进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互 斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。 </p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线 程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需 要再进行同步。 </p>
<p>（摘自 《深入理解 Java 虚拟机》）</p>
<h4 id="重量级锁和轻量级锁"><a href="#重量级锁和轻量级锁" class="headerlink" title="重量级锁和轻量级锁"></a>重量级锁和轻量级锁</h4><p><strong>轻量级锁</strong></p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是<strong>线程交替执行同步块</strong>的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀（<strong>互斥</strong>）。为重量级锁。轻量级锁是通过 虚拟机中栈帧标志位 Lock Record 实现的，具体参考《深入Java虚拟机》13章锁优化。而传统的重量级锁使用到了操作系统的互斥变量来实现，消耗资源比较大。</p>
<p><strong>重量级锁（Mutex Lock）</strong></p>
<p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，<strong>这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。</strong>JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁（锁升级的方式是单向的，不会出现降级的情况），这个问题也困扰了我一段时间，尤其是锁是在什么时候会升级。</p>
<p>可以将偏向锁、轻量级锁认为是乐观锁，重量级锁是悲观锁，以下是我对锁升级的理解</p>
<ol>
<li>在一个对象实例化后，如果没有线程访问这个对象时，首先锁会偏向于第一个获取它的线程，如果在接下来的执行过程中，没有其他线程竞争该锁，那么就偏向第一个线程；则这个线程修改对象头称为偏向锁的标志使用 CAS 操作，将对象头的 ID 改成这个线程ID，之后访问该对象的时候，只需要比较线程ID，而不需要进行 CAS 操作。</li>
<li>一旦有第二个线程来访问该锁，第二个锁会查看该锁的偏向状态，检查原来持有该偏向锁的线程的状态。<ol>
<li>如果第一个线程挂了，那么该对象为无锁状态，重新偏向新的线程</li>
<li>如果第一个线程依然存活，则检查该线程的操作栈，<strong>检查其是否继续持有偏向锁，如果持有则升级为轻量级锁</strong>，如果不持有则重新偏向。</li>
<li>轻量级锁认为竞争存在，但是很低，对一个锁的操作会错开或者说可以通过自旋锁的操作进行等待一阵子，另一个锁就会释放锁。该锁就为轻量级锁。</li>
</ol>
</li>
<li>如果<strong>线程自旋超过一定时间，或者此时一个线程在持有轻量级锁、另一个在自旋操作，又有第三个线程来访时</strong>，那么轻量级锁就会膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li>
</ol>
<h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>乐观锁是一种乐观思想，任务<strong>读多写少</strong>，遇到并发写的可能性很低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>（比较跟上一次的版本号，如果一样更新，如果不一样则要重复读-比较-写的操作）。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<p>悲观锁的思想则和乐观锁的思想相反，为悲观思想，认为写多读少，遇到并发写的可能性高，每次去拿数据的时候认为别人都会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁，Java 悲观锁就是 Synchronized，AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转化为悲观锁，如 RetreenLock。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁则是表示如果持有锁的线程在很短的时间内释放资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要等一等（自旋），等待有锁的线程释放锁后既可立即获得锁。这样就避免了用户线程和内核之间的切换。</p>
<p>线程自旋是需要消耗 CPU 的，说白了就是让 CPU 在做无用功，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>公平锁：加锁钱检查是否有排队等待的线程，优先排队等待的线程，先来先得</p>
<p>非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p>
<ul>
<li>非公平锁性能比公平锁搞 5~10倍，因为公平锁需要在多核的情况下维护一个队列。</li>
<li>Java 中的 synchronized 是非公平锁。ReentrantLock 默认的 lock() 方法采用的是非公平锁。</li>
</ul>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>分段锁也是一种锁的思想，意为将数据分段上锁。</p>
<p>具体应用如下：HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是 ConcurrentHashMap 所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<p><strong>读锁</strong></p>
<p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<p><strong>写锁</strong></p>
<p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁</p>
<p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。</p>
<p>读写锁可参考《现代操作系统》中的PV操作-读者写者问题。<a href="https://blog.csdn.net/sinat_40701582/article/details/106729215">参考</a></p>
<h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>Java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p><strong>独占锁</strong></p>
<p>独占锁模式下，每次只能有一个线程持有锁，ReentrantLock 就是以独占的方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他的读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p><strong>共享锁</strong></p>
<p>共享锁则允许多个线程同时获取锁，并发访问共享资源，如 ReadWriteLock，共享锁则是一种乐观锁，放宽了加锁政策，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</li>
<li>Java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源被多个读操作一起访问或者一个写操作访问，但是两者不能同时进行。</li>
</ol>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。<strong>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，,但不受影响，简单来说就是可以重复获取同一把锁。</strong>在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<p>java线程是基于“每线程（per-thread）”，而不是基于“每调用的（per-invocation）”的，也就是说java为每个线程分配一个锁，而不是为每次调用分配一个锁。最大的作用是避免死锁。在很多情况下线程需要多次进入锁内执行任务。</p>
<h3 id="Java-锁的使用"><a href="#Java-锁的使用" class="headerlink" title="Java 锁的使用"></a>Java 锁的使用</h3><h4 id="Synchronize-同步锁"><a href="#Synchronize-同步锁" class="headerlink" title="Synchronize 同步锁"></a>Synchronize 同步锁</h4><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><ol>
<li>实例方法：作用于方法时，锁住的是对象的实例(this)。</li>
<li>静态方法：作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据都存在永久代 PermGen 中（jdk1.8之后则是 metaspace ），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程</li>
<li>同步代码块：作用于一个实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储到不同的容器中。</li>
</ol>
<p><a href="https://m.imooc.com/wiki/concurrencylesson-synchronized">Synchronized 作用范围详解参考</a></p>
<h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h5 id="synchnized-实现"><a href="#synchnized-实现" class="headerlink" title="synchnized 实现"></a>synchnized 实现</h5><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111261631048.png" alt="这里写图片描述"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify。</p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">锁实现参考</a></p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="Semaphare-信号量"><a href="#Semaphare-信号量" class="headerlink" title="Semaphare 信号量"></a>Semaphare 信号量</h4><h4 id="AtomicInteger-原子操作"><a href="#AtomicInteger-原子操作" class="headerlink" title="AtomicInteger 原子操作"></a>AtomicInteger 原子操作</h4><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3>]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-物理层</title>
    <url>/2020/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p><strong>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体</strong></p>
<p><strong>主要任务：确定与传输媒体接口的一些特性：</strong></p>
<ul>
<li>机械特性：接口形状、大小、引脚 数码</li>
<li>电气特性：如规定电压范围（-5V到+5）</li>
<li>功能特性：如规定-5V表示0.+5V表示1</li>
<li>过程特性：规定连接时各个相关部件的工作步骤</li>
</ul>
<a id="more"></a>

<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol>
<li><p>数据：运送消息的实体</p>
</li>
<li><p>信号：数据的电气的或者电磁的表现，或者说信号时适合在传输介质上传输的对象</p>
<ol>
<li>模拟信号：代表消息的参数的取值时连续的</li>
<li>数字信号：代表消息的参数子在取值时时离散的</li>
</ol>
</li>
<li><p>码元：使用时间域的波形来表示数字信号时，表示不同的离散数值的基本波形。</p>
</li>
<li><p>比特率：单位时间内传送的比特数</p>
</li>
<li><p>波特率：单位时间内载波调制状态改变的次数，针对数据信号对载波的调制速率</p>
</li>
<li><p>奈氏准则：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题。使接收端对码元的判决（即识别）成为不可能。</p>
</li>
<li><p>信噪比：信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）</p>
</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="有关信道的基本概念"><a href="#有关信道的基本概念" class="headerlink" title="有关信道的基本概念"></a>有关信道的基本概念</h3><p><strong>信道</strong>：信号的传输媒体，有以下几种通信方式</p>
<ul>
<li>单工通信（单向通信)：只有一个方向的通信，无反方向的通信（如广播电视）</li>
<li>半双工通信（双向交替通信）：通信双方可以互发消息，但是不能同时发消息（如对讲机）</li>
<li>全双工通信（双向同时通信）：可以同时收发信息（如打电话）</li>
</ul>
<p><strong>基带信号：</strong>来自信源的信号，指没有经过调制的数字信号或模拟信号。如计算机输出的数据信号：文件，</p>
<p><strong>调制：</strong>基带信号中包含了许多低频的成分，甚至直流的成分，许多信道不支持低频或者直流分量，因此必须对基带信号进行调频</p>
<p><strong>带通信号</strong>：基带信号经过载波调制后，把频率范围搬移到较高判断以便在信道中传输（频率高能使信号传输距离更远）<br><strong>几种最基本的调制方法</strong></p>
<ul>
<li>调幅（AM）：载波的振幅随基带数字信号而变化。</li>
<li>调频（FM）：载波的频率随基带的数字信号而变化</li>
<li>调相（PM）：在波的初始相位随基带数字信号而变化</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%9F%BA%E5%B8%A6%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="基带调制方法"></p>
<p><strong>常用编码</strong></p>
<ul>
<li>单极性不归零码：只使用一个电压值，高电平表示1，没电压表示0（如图a）</li>
<li>双极性不归零码：用正电平和负电平分别表示二进制数据的0和1，正负幅值相等(如图b)</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.png" alt="单极不归零与双极不归零"></p>
<ul>
<li>单极性归零码：只使用一个电压值，高电平表示1，没电压表示0（如图a）</li>
<li>双极性归零码：用正电平和负电平分别表示二进制数据的0和1，正负幅值相等(如图b)</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%8D%95%E6%9E%81%E4%B8%8D%E5%BD%92%E9%9B%B6%E4%B8%8E%E5%8F%8C%E6%9E%81%E4%B8%8D%E5%BD%92%E9%9B%B6.png" alt="单极归零与双极归零"></p>
<ul>
<li>曼彻斯特编码：位周期中心向上跳代表0，向下跳代表1</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%8D%95%E6%9E%81%E5%BD%92%E9%9B%B6%E4%B8%8E%E5%8F%8C%E6%9E%81%E5%BD%92%E9%9B%B6.png" alt="曼彻斯特编码"></p>
<ul>
<li>差分曼彻斯特编码：位中心始终有跳变，边界有跳变代表0，无跳变代表1</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%B7%AE%E5%88%86%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.png" alt="差分曼彻斯特编码"></p>
<blockquote>
<p>差分曼彻斯特编码与曼彻斯特编码相同，但是抗干扰性能强于曼彻斯特编码</p>
<p>曼彻斯特编码与前两种相比能够表示没有数据传输，具有自同步能力</p>
</blockquote>
<h3 id="奈氏准则和和香农定理"><a href="#奈氏准则和和香农定理" class="headerlink" title="奈氏准则和和香农定理"></a>奈氏准则和和香农定理</h3><p>因为在任何实际的信道中，在传输信号的适合会产生各种失真以及带来多种干扰， 码元传输的速率越高，或者传输的距离越远，在信道中输出端的波形的失真就越严重</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4%E5%92%8C%E5%8D%95%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="信道干扰图"></p>
<p><strong>奈氏准则</strong>：在任何信道中，码元传输的速率是有<strong>上限</strong>的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。如果信道的<strong>频带越宽</strong>，也就是能够通过的信号<strong>高频分量</strong>越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p>
<p> 理想低通信道最高码元传输速率=2WBaud（无干扰）</p>
<ul>
<li>W是理想低通信道的带宽，单位是Hz</li>
<li>Baud是波特，是码元传输速率的单位</li>
</ul>
<p><strong>波特和比特的区别</strong></p>
<blockquote>
<p>Bit是信息量，如果一个码元含有三个Bit的信息量，1波特=3Bit/s （000-111）</p>
</blockquote>
<p><strong>香农定理</strong></p>
<blockquote>
<p>香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限，无差错的信息传输速率</p>
</blockquote>
<p><strong>定义为：</strong><br>$$<br>C=Wlog2(1+S/N)   b/s<br>$$</p>
<ul>
<li>W为信道的带宽（Hz）</li>
<li>S为信道内所传信号的平均功率</li>
<li>N为信道内部的高斯噪声功率</li>
</ul>
<p>信噪比：信号的平均规律和噪声的平均功率之比。记为S/N，用dB为度量单位。<br>香农公式表明：信道的<strong>带宽</strong>或信道中的<strong>信噪比越大</strong>，信息的<strong>极限传输速率就越高。</strong><br>香农公式和奈氏准则适用范围：<br>香农公式：仅模拟信<br>奈氏准则：模拟信号、数字信号都可。</p>
<p><strong>奈氏准则和香农定理应用范围：</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E4%BF%A1%E9%81%93%E5%B9%B2%E6%89%B0%E5%9B%BE.png" alt="奈氏准则和香农定理应用范围"></p>
<h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>传输媒体分两大类</p>
<ol>
<li>导引型传输媒体：通过固定媒体（铜线或者光纤）传播</li>
<li>非导引型传输媒体：在自由空间中传播（无线传播）</li>
</ol>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p><strong>双绞线</strong></p>
<ul>
<li>屏蔽双绞线STP</li>
<li>无屏蔽双绞线UTP</li>
</ul>
<p><strong>同轴电缆</strong></p>
<ul>
<li>50欧同轴电缆：用于数字传输，多用于基带传输</li>
<li>70欧同轴电缆：用于模拟传输</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%90%84%E7%A7%8D%E7%94%B5%E7%BC%86.png" alt="各种电缆"></p>
<p><strong>光纤</strong>（外部干扰对其影响比较小）</p>
<p><strong>光线在光纤中的反折射</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A41.png" alt="光纤1"></p>
<p>光纤内部工作原理</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4.png" alt="光纤2"></p>
<p>多模光纤和单模光纤</p>
<ul>
<li>单模光纤：光纤直径较小到一定的范围，使光线在传播中不产生多次反射，传播性能好</li>
<li>多模光纤：多条不同角度入射的光线在同一条光纤中传输（适合近距离）</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="多模光纤和单模光纤"></p>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><ul>
<li>无线传输所使用的<strong>频段很广</strong>。</li>
<li>短波通信主要是靠电离层的反射，但短波信道的<strong>通信质量较差</strong>。</li>
<li>微波在空间主要是直线传播<ul>
<li>地面微波接力通信</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A42.png" alt="复用技术"></p>
<h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E5%9B%BE.png" alt="频分复用"></p>
<h3 id="时分复用（Time-Diviion-Mutiplexing）"><a href="#时分复用（Time-Diviion-Mutiplexing）" class="headerlink" title="时分复用（Time Diviion Mutiplexing）"></a>时分复用（Time Diviion Mutiplexing）</h3><p>时分复用技术则是将时间划分为一段段等长的<strong>时分复用帧</strong>（TDM帧）。每一个时分复用的用户在每一个TMD帧中占用了固定的时间段，时分复用的所有用户是在不同的时间占用同样的<strong>频带宽度</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF.png" alt="image-20200731211519780"></p>
<p>对于一些用户没使用信道时，则会造成资源浪费。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF.png" alt="image-20200731211614472"></p>
<p>因此对于这个缺点，出现了改进的时分复用技术：<strong>统计时分复用技术</strong></p>
<p>在数据帧中添加标记，来区分数据来源</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="image-20200731212124057"></p>
<h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><p>波分复用就是对光的频分复用</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E7%BC%BA%E7%82%B9%E5%9B%BE.png" alt="image-20200731212922321"></p>
<h3 id="码分复用CDM-code-Division-multiplexing"><a href="#码分复用CDM-code-Division-multiplexing" class="headerlink" title="码分复用CDM(code Division multiplexing)"></a>码分复用CDM(code Division multiplexing)</h3><p>​    各个用户使用经过挑选的不同码型，靠不同的编码来区分各个用户原始信号的一种复用方式</p>
<p>​    每一个比特时间划分为<strong>m个短的时间间隔</strong>，称为<strong>码片</strong></p>
<p>​    每个站被指派一个唯一的一个m bit码片序列</p>
<ul>
<li><p>如果发送比特1，则发送自己的m bit码片序列</p>
</li>
<li><p>如果发送比特0，则发送该码片序列的二进制反码</p>
<p><strong>特点</strong></p>
</li>
<li><p>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。</p>
</li>
<li><p>在实用的系统中是使用伪随机码序列。</p>
</li>
<li><p>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0：</p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E8%A7%84%E6%A0%BC%E5%8C%96%E5%86%85%E7%A7%AF1.png" alt="image-20200731235013658"> </p>
<p>示例：</p>
<p>令向量 S 为(–1 –1 –1 +1 +1 –1 +1 +1)，向量 T 为(–1 –1 +1 –1 +1 +1 +1 –1)。<br>把向量 S 和 T 的各分量值代入(2-3)式就可看出这两个码片序列是正交的。 </p>
<p>他们每个位数相乘，除于8结果为0</p>
<p>另一个特点就是任何一个码片向量和该码片向量自己的规格化内积都是1 。<br>一个码片向量和该码片反码的向量的规格化内积值是 –1。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E8%A7%84%E6%A0%BC%E5%8C%96%E5%86%85%E7%A7%AF.png" alt="image-20200731235358104"></p>
<p><strong>CDMA的工作原理</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/CMDA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image-20200731235456843"></p>
<p>分析：在S站发送1时，与<strong>S站的码片序列与扩频序列Sx的内积为1</strong>，<strong>发送0时内积为-1.**而其他站</strong>（T）<strong>的发送信号与</strong>S站<strong>的码片序列</strong>内积都为0**，就会被过滤掉，因此最终就能得到我们需要的接受的站的信号。（可以对照着图看格式化内积的公式，动手运算一遍就理解了）</p>
<p>例题：如下面四个码片序列</p>
<p> A：（-1，-1，-1，+1，+1，-1，+1，+1）</p>
<p> B：（-1，-1，+1，-1，+1，+1，+1，-1）</p>
<p> C：（-1，+1，-1，+1，+1，+1，-1，-1）</p>
<p> D：（-1，+1，-1，-1，-1，-1，+1，+1）</p>
<p>收到的码片序列为R：（-1，+1，-3，+1，-1，-3，+1，+1）</p>
<p>A*R=(1-1+3+1-1+3+1+1)/8=1                   </p>
<p> B*R=(1-1-3-1-1-3+1-1)/8=-1          </p>
<p>C和R的格式化内积为0，D和R的格式化内积为1 </p>
<p>由结果可知，C没收到信号，其他的均收到了这个格式化内积的信号</p>
<h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>早期数字传输系统主要有两个缺点：</p>
<ul>
<li><p>速率标准不统一</p>
<ul>
<li>如果不对高次群的数字传输速率进行标准化，国际范围的高速数据传输就很难实现。 </li>
</ul>
</li>
<li><p>不是同步传输</p>
<ul>
<li>在过去相当长的时间，为了节约经费，各国的数字网主要是采用<strong>准同步方式。</strong> </li>
</ul>
</li>
</ul>
<p>脉码调制 PCM 体制最初是为了在电话局之间的中继线上传送多路的电话。</p>
<ul>
<li><p>由于历史上的原因，PCM 有两个互不兼容的国际标准，即北美的 24 路PCM（简称为 T1）和欧洲的 30 路 PCM（简称为 E1）。我国采用的是欧洲的 E1 标准。</p>
</li>
<li><p>E1 的速率是 2.048 Mb/s，而 T1 的速率是 1.544Mb/s。</p>
</li>
<li><p>当需要有更高的数据率时，可采用复用的方法</p>
</li>
</ul>
<p>1、<strong>同步光纤网络</strong>SONET。整个同步光纤网络的主时钟来自于一个非常昂贵的铯原子钟；其基础传输速率是51.82Mbit/s，此速率对电信号称为<strong>第1级同步传送信号</strong>，即STS-1；对光信号称为第1级<strong>光载波</strong>，即OC-1。</p>
<p>2、<strong>同步数字系列</strong>SDH（以SONET为基础），一般认为SDH和SONET是同义词，不同点在于 SDH的基本速率是155.52Mbit/s，称为<strong>第1级同步传送模块</strong>，即STM-1，相当于SONET中OC-3的速率。</p>
<h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p>ADSL(Asymmetric Digital Subscriber Line)：非对称</p>
<p>xDSL技术就时用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务（DSL 就是数字用户线(Digital Subscriber Line)的缩写。而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。 ）</p>
<p>如图，该技术将0-4kHz的地段频率谱段留给传统的电话使用，而原来没有使用的高端频率谱段留给用户上网使用。其中，26-108Hz的频谱留给用户上传数据、138-1104留给用户下载数据使用</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/xDSL%E7%9A%84%E6%8E%A5%E5%85%A5%E5%88%86%E9%A2%91%E5%9B%BE.png" alt="image-20200801104806430"></p>
<p>而接入则使用分离器分离信号，低频的信号则接电话，高频的接电脑。（一般在用户的两端都有ADSL调制解调器）</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/xDLS.png" alt="image-20200801105143843"></p>
<h3 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h3><ol>
<li>DMT 调制技术采用<strong>频分复用</strong>的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。</li>
<li>每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</li>
</ol>
<p>![image-20200801105743973](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/DMT">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/2.物理层/DMT</a> 技术的频谱分布.png)</p>
<h3 id="光纤同轴混合网（HFC）Hybrid-Fiber-Coax"><a href="#光纤同轴混合网（HFC）Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网（HFC）Hybrid Fiber Coax"></a>光纤同轴混合网（HFC）Hybrid Fiber Coax</h3><p>HFC网是在目前覆盖很广的有线电视网CATV的基础上开发的一种居民宽带接入网。</p>
<p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p>
<p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造，  </p>
<p><strong>HFC的主要特点</strong></p>
<ul>
<li>HFC网的主干线路采用<strong>光纤</strong>，HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用<strong>模拟光纤技术。</strong></li>
<li>在模拟光纤中采用光的<strong>振幅调制 AM</strong>，这比使用数字光纤更为经济。</li>
<li>模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E9%9B%86%E7%BA%BF%E5%99%A8.png" alt="image-20200801111107789"></p>
<h3 id="FTTx-技术-（光纤到……）"><a href="#FTTx-技术-（光纤到……）" class="headerlink" title="FTTx 技术 （光纤到……）"></a>FTTx 技术 （光纤到……）</h3><p>FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。</p>
<ul>
<li>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</li>
<li><strong>光纤到大楼 FTTB</strong> (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li>
<li>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。 </li>
</ul>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>​    中继器又称转发器，主要工作内容是将信号放大再转发出去，以消除信号经过一段长时间的电缆后，因为噪声或者其他原因而造成的失真和衰减。（增加信号强度），他工作于物理层，只是起到扩展传输距离的作用，对高层协议是透明的。</p>
<p>优点</p>
<ul>
<li>扩大了通信距离。</li>
<li>增加了节点的最大数目。</li>
<li>各个网段可使用不同的通信速率。</li>
<li>提高了可靠性。当网络出现故障时，一般只影响个别网段。</li>
<li>性能得到改善</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于中继器对收到被衰减的信号再生（恢复）到发送时的状态，并转发出去，增加了延时。</li>
<li>CAN总线的MAC子层并没有流量控制功能。当网络上的负荷很重时，可能因中继器中缓冲区的存储空间不够而发生溢出，以致产生帧丢失的现象。</li>
<li>中继器若出现故障，对相邻两个子网的工作都将产生影响。</li>
</ul>
<h3 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h3><p>集线器实质上是一个多端口的中继器，Hub主要使用双绞线组建共享网络，集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/HFC%E7%BD%91%E7%82%B9%E7%BB%93%E6%9E%84.png" alt="s"></p>
<h2 id="几种基本的调制方法"><a href="#几种基本的调制方法" class="headerlink" title="几种基本的调制方法"></a>几种基本的调制方法</h2><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。</p>
<p>最基本的二元制调制方法有以下几种：</p>
<ul>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。 </li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM) ：载波的初始相位随基带数字信号而变化。  </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="image-20200801112308991"></p>
<p>最近访客</p>
<div class="ds-recent-visitors" data-num-items="39" data-avatar-size="40" id="ds-recent-visitors"></div>]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-2-链路层</title>
    <url>/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><p><strong>一些基本概念</strong></p>
<p><strong>数据链路层的信道</strong>主要有以下两种类型：</p>
<ul>
<li><p><strong>点对点信道：</strong>这种信道使用一对一的点对点通信方式。</p>
</li>
<li><p><strong>广播信道：</strong>这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专业的共享信道协议来协调这些主机的数据发送</p>
</li>
</ul>
<p><strong>主机1向主机二发送数据</strong>，数据从应用层向下流动，到达物理层变成比特流，经过路由器转发，通过检查MAC地址，查看IP地址，然后选择路由，找到下一个地址，再向下到物理层，这样经过路由器转发，到达H2。</p>
<a id="more"></a>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%B8%BB%E6%9C%BA1%E5%90%91%E4%B8%BB%E6%9C%BA2%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE.png" alt="image-20200801215734585"></p>
<p>而从数据链路层的角度来看，我们只需要关心协议栈中水平方向中的各个数据链路层，我们想象数据链路层是从左到右沿水平方向传输的。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="image-20200801221147722"></p>
<h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1  使用点对点信道的数据链路层"></a>3.1  使用点对点信道的数据链路层</h2><h3 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h3><p><strong>数据链路层的模型和帧</strong></p>
<ul>
<li>链路是一条无源的点到点的物理线路段，中间没有任何其他的交换节点<ul>
<li>一条链路只是一条通路的一个组成部分</li>
</ul>
</li>
<li>数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<ul>
<li>现在最常用的方法是使用适配器（网卡）来实现这些协议的硬件和软件。</li>
<li>一般的适配器都包括了数据链路层和物理层这两层的功能。</li>
</ul>
</li>
<li>帧：在数据链路层上传送的就是帧</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" alt="image-20200801222101461"></p>
<h3 id="3-1-2-三个基本问题"><a href="#3-1-2-三个基本问题" class="headerlink" title="3.1.2 三个基本问题"></a>3.1.2 三个基本问题</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li>封装成帧就是在一段数据的前后分别添加首部和尾部，然后构成一个帧，确定帧的界限</li>
<li>首部和尾部的一个重要作用就是进行帧定界</li>
</ul>
<blockquote>
<p>MTU  最大传送单元&lt;=1500个字节</p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7.png" alt="image-20200801224539546"></p>
<p>计算机在接受一个帧时，收到了帧的首部和尾部才能认为这个帧是一个完整的数据帧，若没有收到一个完整的数据帧，则认为他是不完整的，则会将其丢弃。</p>
<p>帧定界符</p>
<ul>
<li>控制字符SOH（Start Of Header）：放在帧的最前面，表示帧的首部</li>
<li>控制字符EOT（End Of Transmission）：表示帧的结束</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="image-20200801224926459"></p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p><strong>问题</strong></p>
<p>在封装成帧后，我们传输的数据中如果在数据中间出现部分EOT或者SOH这样的帧定界控制字符时，可能会导致数据意外的被丢弃，这时我们需要透明传输。如图所示</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/CRC%E5%8E%9F%E7%90%86.png" alt="image-20200801225403512"></p>
<p>解决问题：<strong>实现透明传输</strong></p>
<p>透明传输指数据中可能实际存在帧定界符，但是不被我们处理，就好像透明一样，我们采用的方法是在发送端的数据链路层在数据中长线<strong>控制字符时</strong>在前面插入转义字符<strong>”ESC“</strong>，</p>
<p>而在<strong>接收端</strong>的数据链路层在把数据传往网络层之前<strong>删除插入的转义字符</strong> </p>
<p>如果转义字符也出现数据当中，那么应在<strong>转义字符前面插入一个转义字符</strong>。当<strong>接收端</strong>收到连续的两个转义字符时，就删除其中前面的一个。 </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E5%AE%9A%E7%95%8C%E5%9B%BE.png" alt="image-20200801233726229"></p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>在传输过程中，可能会产生比特差错，1可能变成0，0可能变成1，在一段时间内传输错误他比特占所传输毕业总数的比率称为<strong>误码率BER</strong>。</p>
<p>数据链路层广泛使用<strong>循环冗余检验CRC</strong>：</p>
<ol>
<li>在发送端，先把数据划分为组。假定每组 k 个比特。</li>
<li>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。  </li>
<li>用二进制的模 2 运算进行 2的n次方 乘 M 的运算，这相当于在 M 后面添加 n 个 0（如n=3，M=101001000）。</li>
<li>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。 </li>
<li>在接收端接受到数据后，进行CRC校验，将发送端发送的数据除于余数R（异或运算），运算的<strong>余数为0</strong>则说明没有差错，就<strong>接受</strong>；如果余数R<strong>不等于0，</strong>就说明这个帧有差错就<strong>丢弃</strong>。</li>
</ol>
<blockquote>
<p>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。<br>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 </p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<p>仅用循环冗余检验 CRC 差错检测技术只能做到<strong>无差错接受(accept)。</strong><br>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。  </p>
</blockquote>
<p>例题：</p>
<ul>
<li>现在 k = 6, M = 101001。</li>
<li>设 n = 3, 除数 P = 1101（除数n+1位）</li>
<li>被除数是 2nM = 101001000。 </li>
<li>模 2 运算的结果是：商 Q = 110101，余数 R = 001。</li>
<li>把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R ，   即：101001001，共 (k + n) 位。 </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85.png" alt="image-20200802112614613"></p>
<p>传送的数据为101001+余数R=101001001  接收端收到数据则使用该数据除于1101（P），余数为0，则无误，余数不为0，则说明传送过程中出错。</p>
<blockquote>
<p>除数是由数据链路层的协议实现的，我们不用关心这个除数是多少和余数是</p>
</blockquote>
<h2 id="3-2-点对点协议-PPP-Point-to-Point-Protocol-。"><a href="#3-2-点对点协议-PPP-Point-to-Point-Protocol-。" class="headerlink" title="3.2  点对点协议 PPP (Point-to-Point Protocol)。"></a>3.2  点对点协议 PPP (Point-to-Point Protocol)。</h2><p>点对点协议PPP（Point-to-Point Protocol）是目前<strong>使用最广泛</strong>的数据链路层协议</p>
<h3 id="3-2-1-PPP-协议的特点"><a href="#3-2-1-PPP-协议的特点" class="headerlink" title="3.2.1 PPP 协议的特点"></a>3.2.1 PPP 协议的特点</h3><h4 id="1-PPP-协议应满足的需求"><a href="#1-PPP-协议应满足的需求" class="headerlink" title="1. PPP 协议应满足的需求"></a>1. PPP 协议应满足的需求</h4><ul>
<li>简单——这是首要的要求</li>
<li>封装成帧 </li>
<li>透明性 </li>
<li>多种网络层协议 </li>
<li>多种类型链路 </li>
<li>差错检测 </li>
<li>检测连接状态 </li>
<li>最大传送单元 </li>
<li>网络层地址协商 </li>
<li>数据压缩协商  </li>
</ul>
<h4 id="2-PPP-协议不需要的功能"><a href="#2-PPP-协议不需要的功能" class="headerlink" title="2. PPP 协议不需要的功能"></a>2. PPP 协议不需要的功能</h4><ul>
<li>纠错 </li>
<li>流量控制 </li>
<li>序号 </li>
<li>多点线路 </li>
<li>半双工或单工链路 </li>
</ul>
<h4 id="3-PPP-协议的组成"><a href="#3-PPP-协议的组成" class="headerlink" title="3.  PPP 协议的组成"></a>3.  PPP 协议的组成</h4><p>ppp协议由三个部分组成</p>
<ol>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP (Link Control Protocol)。</li>
<li>网络控制协议 NCP (Network Control Protocol)。   </li>
</ol>
<h3 id="3-2-2-PPP-协议的帧格式"><a href="#3-2-2-PPP-协议的帧格式" class="headerlink" title="3.2.2 PPP 协议的帧格式"></a>3.2.2 PPP 协议的帧格式</h3><p>PPP帧的首部和尾部分别有四个字段和两个字段</p>
<ul>
<li>首部的第一个字段和尾部第二个字段是标志字段F=0x7E(0111 1110)</li>
<li>地址字段地址字段 A 只置为 0xFF。地址字段实际上并不起作用。控制字段 C 通常置为 0x03。</li>
</ul>
<p>协议字段：</p>
<ul>
<li>当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。</li>
<li>若为 0xC021, 则信息字段是 PPP 链路控制数据。</li>
<li>若为 0x8021，则表示这是网络控制数据。  </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="image-20200802135713449"></p>
<p><strong>PPP帧实现透明传输问题：</strong></p>
<ol>
<li><p>字节填充</p>
<ol>
<li>当信息部分出现了0x7E时，将0x7E变成2字节的序列（0x7D,0x5E)</li>
<li>若信息部分出现了0x7D字节时，将其变为2字节的序列（0x7D,0x5D）</li>
<li>若信息部分出现了ASCII码的控制字符（即数值小于0x20的字符），则在字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。</li>
</ol>
</li>
<li><p>零比特填充</p>
<ol>
<li>PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送，不是字节）。这时 PPP 协议采用零比特填充方法来实现透明传输。</li>
<li>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，</li>
</ol>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png" alt="image-20200802150345153"></p>
</li>
</ol>
<p>PPP 协议之所以<strong>不使用序号和确认机制</strong>是出于以下的考虑：</p>
<ul>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受</li>
</ul>
<h3 id="3-2-3-PPP-协议的工作状态"><a href="#3-2-3-PPP-协议的工作状态" class="headerlink" title="3.2.3 PPP 协议的工作状态"></a>3.2.3 PPP 协议的工作状态</h3><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。    </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/0%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85.png" alt="image-20200802151340359"></p>
<h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3  使用广播信道的数据链路层"></a>3.3  使用广播信道的数据链路层</h2><h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><p><strong>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。</strong> </p>
<p><strong>局域网具有如下的一些主要优点：</strong></p>
<ol>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ol>
<p><strong>局域网的网络拓扑</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="image-20200802161720284"></p>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>网络接口板又称为通信适配器（adapter）或网络接口卡NIC（Network Interface Card）或网卡。<br>功能：</p>
<ul>
<li>进行数据串行传输和并行传输的转换</li>
<li>对数据进行缓存</li>
<li>在计算机的操作系统中安装设备驱动程序</li>
<li>实现以太网协议</li>
</ul>
<p><img src="G:\计算机网络笔记\2-链路层.assets\适配器与局域网通信" alt="image-20200802214027858"></p>
<h4 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a>数据链路层的两个子层</h4><ul>
<li>为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层：<ul>
<li>逻辑链路控制 LLC (Logical Link Control)</li>
<li>子层媒体接入控制 MAC (Medium Access Control)子层。</li>
</ul>
</li>
<li>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的 </li>
</ul>
<p>![image-20200802213914491](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AF%B9">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.链路层/局域网对</a> LLC 子层来说都是透明.png)</p>
<blockquote>
<p>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。<br>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 </p>
</blockquote>
<h3 id="3-3-2-CSMA-CD-协议"><a href="#3-3-2-CSMA-CD-协议" class="headerlink" title="3.3.2 CSMA/CD 协议"></a>3.3.2 CSMA/CD 协议</h3><h4 id="载波监听多点接入-碰撞检测-CSMA-CD"><a href="#载波监听多点接入-碰撞检测-CSMA-CD" class="headerlink" title="载波监听多点接入/碰撞检测  CSMA/CD"></a>载波监听多点接入/碰撞检测  CSMA/CD</h4><ul>
<li><strong>CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。</strong></li>
<li>“<strong>多点接入</strong>”表示许多计算机以多点接入的方式连接在一根总线上。</li>
<li>“<strong>载波监听</strong>”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 </li>
<li>总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。  </li>
</ul>
<h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><ul>
<li><strong>“碰撞检测”</strong>就是计算机边发送数据边检测信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会<strong>增大</strong>（互相叠加）。</li>
<li>当一个站检测到的信号电压摆动值<strong>超过一定的门限值时</strong>，就认为总线上至少有两个站同时在发送数据，表明产生了<strong>碰撞。</strong></li>
<li>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为<strong>“冲突检测”。</strong></li>
</ul>
<p><strong>检测到碰撞后</strong></p>
<p>在发生碰撞时，总线上传输的信号产生了<strong>严重的失真</strong>，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即<strong>停止发送</strong>，免得继续浪费网络资源，然后等待一段随机时间后<strong>再次发送。</strong></p>
<p><strong>电磁波在总线上的有限传播速率的影响</strong> </p>
<p>当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。<br>A 向 B 发出的信息，要经过一定的时间后才能传送到 B。<br>B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。<br>碰撞的结果是两个帧都变得无用。  </p>
<p>如图所示，电磁波在1KM电缆的传播时延为5us，单程端到端的传播时延为τ，从图中可知，判断是否发送碰撞的时间<strong>最多为2τ</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%94%B5%E7%A3%81%E6%B3%A2%E5%9C%A8%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%89%E9%99%90%E4%BC%A0%E6%92%AD%E9%80%9F%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt="image-20200802223813715"></p>
<blockquote>
<p> 在使用CSMA/CD协议时，一个站不能同时发送与接收信息（必须边发送边监听信道），因此以太网使用的是<strong>半双工通信</strong>。</p>
</blockquote>
<h4 id="争用期与退避算法"><a href="#争用期与退避算法" class="headerlink" title="争用期与退避算法"></a>争用期与退避算法</h4><p>最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2τ 称为<strong>争用期</strong>，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>对于10Mb/s的以太网，通常取 2τ也就是51.2微秒作为争用期的长度，在争用期内可以发送512bit，也就是64字节，以太网发送数据时如果64字节未发生冲突，则后续的数据也不会发生冲突，因此以太网有规定<strong>最短的有效帧的长度</strong></p>
<p><strong>最短有效帧长</strong></p>
<ul>
<li>如果发生冲突，就一定时在发送前64字节之内</li>
<li>由于一检测到冲突就立即停止发送，这时已经发出去的数据一定时64字节</li>
<li>以太网规定了最短有效帧长度为64字节，但凡小于64字节的帧长度是由于冲突异常而中止的无效帧。</li>
</ul>
<p><strong>截止二进制指数退避算法</strong></p>
<p>发生碰撞的站在停止发送数据后，要推迟退避一个随机时间才能再发送数据。</p>
<ul>
<li>确定基本退避时间，一般是取为争用期 2τ。</li>
<li>定义重传次数 k ，k &lt;= 10，即k = Min[重传次数, 10]</li>
<li>从整数集合[0,1,…, (2k −1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。</li>
<li>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告</li>
</ul>
<p><strong>强化碰撞</strong></p>
<p>当发送数据的站一旦发现发生了碰撞时：</p>
<ul>
<li>立即停止发送数据；</li>
<li>再继续发送若干比特（32或48比特）的人为干扰信号(jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li>
</ul>
<h2 id="3-4-使用广播信道的以太网"><a href="#3-4-使用广播信道的以太网" class="headerlink" title="3.4  使用广播信道的以太网"></a>3.4  使用广播信道的以太网</h2><p><strong>以太网的两个标准：</strong></p>
<ul>
<li>DIX Ethernet V2：世界上第一个局域网产品的规约</li>
<li>IEEE 802.3：第一个IEEE的以太网标准</li>
</ul>
<p>以太网严格来说，是指符合DIX Ethernet V2标准打的局域网<br>IEEE802委员会把局域网数据链路层拆成两个子层，即<strong>逻辑链路控制LLC子层</strong>和<strong>媒体接入控制MAC子层</strong>。与接入到传输媒体相关的内容都放在MAC子层上，而LLC子层与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。</p>
<ul>
<li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li>
<li>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</li>
<li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li>
</ul>
<p>以太网发送的数据都使用曼彻斯特编码</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="image-20200802214850998"></p>
<p>以太网的共享信道划分<br><strong>静态划分信道</strong>：频分复用、时分复用波分复用和玛分复用等，这种方式不适合局域网。<br><strong>动态媒体接入控制</strong>（多点接入）：</p>
<ul>
<li>随机接入</li>
<li>受控接入 如多点线路探询或轮询</li>
</ul>
<h3 id="3-4-1-使用集线器的星形拓扑"><a href="#3-4-1-使用集线器的星形拓扑" class="headerlink" title="3.4.1  使用集线器的星形拓扑"></a>3.4.1  使用集线器的星形拓扑</h3><p>物理上是星型，逻辑上是总线型。<br>为了降低成本，最初由粗的同轴电缆变成细的<strong>同轴电缆</strong>最后变成<strong>无屏蔽双绞线</strong>。每个站需要用两对双绞线，分别用于发送和接收；<br>在星形的中心增加了一种可靠性高的设备，为集线器(hub)。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81-%E4%BB%A5%E5%A4%AA%E7%BD%91.png" alt="image-20200803112623727"></p>
<h4 id="集线器的特点"><a href="#集线器的特点" class="headerlink" title="集线器的特点"></a>集线器的特点</h4><ul>
<li>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。 </li>
<li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。 </li>
<li>集线器很像一个多接口的转发器，工作在物理层。 </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%8F%91%E9%80%81%E4%B8%80%E5%B8%A7%E7%9A%84%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%9B%BE.png" alt="image-20200803113137698"></p>
<h4 id="10Base-T-基于集线器的以太网标准"><a href="#10Base-T-基于集线器的以太网标准" class="headerlink" title="10Base-T 基于集线器的以太网标准"></a>10Base-T 基于集线器的以太网标准</h4><ul>
<li>它的通信距离稍短，每个站到集线器的距离不超过100m。</li>
<li>这种10MB/s的无屏蔽双绞线星形网的出现，能降低成本和提高可靠性。</li>
<li>10Base-T的出现有很大的意义，类似标准有100Base-FX，10Base-T，100Base-T4.</li>
</ul>
<h4 id="以太网在局域网中的统治地位"><a href="#以太网在局域网中的统治地位" class="headerlink" title="以太网在局域网中的统治地位"></a>以太网在局域网中的统治地位</h4><ul>
<li><p>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100 m。</p>
</li>
<li><p>这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 </p>
</li>
<li><p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。 </p>
<h3 id="3-4-2-以太网的信道利用率"><a href="#3-4-2-以太网的信道利用率" class="headerlink" title="3.4.2  以太网的信道利用率"></a>3.4.2  以太网的信道利用率</h3></li>
</ul>
<p>以太网的信道被占用的情况：<br>争用期长度为 2t，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>帧长为 L (bit)，数据发送速率为 C (b/s)，因而帧的发送时间为 L/C = T0 (s)。</p>
<p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间 t 使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p>
<p> <img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9.png" alt="image-20200803125401169"></p>
<p>定义信道利用率a=t/T0,是单纯端到端时延t和帧发送时间T0的比值</p>
<ul>
<li><p>a→0 表示一发生碰撞就立即可以检测出来，<br>并立即停止发送，因而信道利用率很高。</p>
</li>
<li><p>a 越大，表明争用期所占的比例增大，每发<br>生一次碰撞就浪费许多信道资源，使得信道<br>利用率明显降低。 </p>
</li>
<li><p>在理想状态下，发送一针需要T0+t的时间，所以理想状态下，极限信道的利用率<strong>Amax=T0/（T0+t）=1/（1+a）</strong>，也就是帧发送时间和检测碰撞的时间</p>
<h3 id="3-4-3-以太网的-MAC-层"><a href="#3-4-3-以太网的-MAC-层" class="headerlink" title="3.4.3  以太网的 MAC 层"></a>3.4.3  以太网的 MAC 层</h3></li>
</ul>
<p>​    在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>，或者<strong>MAC地址</strong></p>
<p>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。</p>
<p>地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址。一个地址块可以生成224个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是EUI-48。“MAC地址”实际上就是适配器地址或适配器标识符EUI-48。</p>
<p>查看本机的MAC地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig  &#x2F;all   如下图的物理地址</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%9F%A5%E7%9C%8BMAC%E5%9C%B0%E5%9D%80.png" alt="image-20200803142127091"></p>
<p>**适配器检查 MAC 地址 **</p>
<ul>
<li>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.<ul>
<li>如果是发往本站的帧则收下，然后再进行其他的处理。</li>
<li>否则就将此帧丢弃，不再进行其他的处理。</li>
</ul>
</li>
<li>“发往本站的帧”包括以下三种帧： <ul>
<li>单播(unicast)帧（一对一）</li>
<li>广播(broadcast)帧（一对全体）</li>
<li>多播(multicast)帧（一对多）</li>
</ul>
</li>
</ul>
<p><strong>MAC帧格式</strong></p>
<p>常用的以太网MAC帧格式有两种标准 ：</p>
<ul>
<li>DIX Ethernet V2 标准</li>
<li>IEEE 的 802.3 标准</li>
</ul>
<p>最常用的 MAC 帧是以太网 V2 的格式。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="image-20200803134222510"></p>
<p>由于以太网要求帧长度最小为64字节，所以数据部分最小长度为46字节（64-6-6-4-2）</p>
<p>类型两个字节，指明数据部分是什么协议。</p>
<p>由于以太网使用的是<strong>曼彻斯特编码</strong>，在帧开始部分插入帧开始的标志符，结尾无信号则表示传输结束。在帧的前面插入的 8 字节中的第一个字段共 7 个字节，是<strong>前同步码</strong>，用来迅速实现 MAC 帧的<strong>比特同步</strong>。第二个字段是<strong>帧开始定界符</strong>，表示后面的信息就是<strong>MAC 帧</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="曼彻斯特编码-以太网"></p>
<p><strong>使用WireShark抓包查看MAC地址</strong></p>
<p>笔主下载百度云的一个20Kb的小文件来进行抓包</p>
<p>如图为目的地址和本机的物理地址（可以参考上面查看本机的MAC地址），以及使用的类型：IPv4协议。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%8A%93%E5%8C%851.png" alt="image-20200803142336902"></p>
<p><strong>无效的MAC帧</strong></p>
<ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
<li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </li>
</ul>
<p><strong>帧间最小间隔</strong></p>
<ul>
<li>帧间最小间隔为 9.6 us，相当于 96 bit 的发送时间。</li>
<li>一个站在检测到总线开始空闲后，还要等待 9.6 s 才能再次发送数据。</li>
<li>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </li>
</ul>
<h2 id="3-5-扩展的以太网"><a href="#3-5-扩展的以太网" class="headerlink" title="3.5 扩展的以太网"></a>3.5 扩展的以太网</h2><h3 id="3-5-1-在物理层扩展以太网"><a href="#3-5-1-在物理层扩展以太网" class="headerlink" title="3.5.1  在物理层扩展以太网"></a>3.5.1  在物理层扩展以太网</h3><ul>
<li><strong>主机使用光纤和一对光纤调制解调器连接到集线器</strong> </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%9C%A8%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8A%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91.png" alt="image-20200803145708318"></p>
<ul>
<li><strong>用多个集线器可连成更大的局域网</strong></li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="image-20200803145826789"></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%A2%B0%E6%92%9E%E5%9F%9F.png" alt="image-20200803145901473"></p>
<p><strong>用集线器扩展局域网</strong> </p>
<p><strong>优点</strong></p>
<ul>
<li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了局域网覆盖的地理范围。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>碰撞域增大了，但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。  </li>
</ul>
<h3 id="3-5-2-在数据链路层扩展以太网"><a href="#3-5-2-在数据链路层扩展以太网" class="headerlink" title="3.5.2  在数据链路层扩展以太网"></a>3.5.2  在数据链路层扩展以太网</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>在数据链路层扩展局域网是<strong>使用网桥</strong>。</p>
<ul>
<li>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。</li>
<li>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口 </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%BD%AC%E5%8F%91%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%E4%B8%BE%E4%BE%8B.png" alt="image-20200803152003144"></p>
<p><strong>网桥使各网段成为隔离开的碰撞域</strong> </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E6%A1%A5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="image-20200803171321845"></p>
<h4 id="网桥的优点与缺点"><a href="#网桥的优点与缺点" class="headerlink" title="网桥的优点与缺点"></a>网桥的优点与缺点</h4><p><strong>使用网桥带来的好处</strong> </p>
<ul>
<li>过滤通信量。 </li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。  </li>
</ul>
<p><strong>使用网桥带来的缺点</strong></p>
<ul>
<li>存储转发增加了时延。 (存储转发)</li>
<li>在MAC 子层并没有流量控制功能。 </li>
<li>具有不同 MAC 子层的网段桥接在一起时时延更大。</li>
<li>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过的广播信息而产生网络拥塞。这就是所谓的<strong>广播风暴</strong>。</li>
</ul>
<p>网桥与集线器（转发器）的区别</p>
<ul>
<li>集线器在转发帧时，不对传输媒体进行检测。</li>
<li>网桥在转发帧之前必须执行 CSMA/CD 算法。<ul>
<li>若在发送过程中出现碰撞，就必须停止发送和进行退避。</li>
</ul>
</li>
</ul>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><ul>
<li>目前使用得最多的网桥是透明网桥(transparent bridge)。 </li>
<li>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。 </li>
<li>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。 </li>
</ul>
<h4 id="网桥的自学习算法"><a href="#网桥的自学习算法" class="headerlink" title="网桥的自学习算法"></a>网桥的自学习算法</h4><ul>
<li>若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。</li>
<li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li>
<li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。</li>
<li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li>
</ul>
<h4 id="网桥的自学习和转发帧的步骤归纳"><a href="#网桥的自学习和转发帧的步骤归纳" class="headerlink" title="网桥的自学习和转发帧的步骤归纳"></a>网桥的自学习和转发帧的步骤归纳</h4><ol>
<li>在网桥的转发表中写入的信息除了<strong>地址和接口</strong>外，还有帧进入该网桥的<strong>时间</strong>。</li>
<li>这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。另外，以太网上的工作站并非总是接通电源的。</li>
<li>把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的<strong>最新状态信息</strong>。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。 </li>
<li><strong>网桥收到一帧后先进行自学习</strong>。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。</li>
<li>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<ol>
<li>如没有，则通过所有其他接口（但进入网桥的接口除外）按进行转发。</li>
<li>如有，则按转发表中给出的接口进行转发。</li>
<li>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</li>
</ol>
</li>
</ol>
<h4 id="转发表的建立过程举例："><a href="#转发表的建立过程举例：" class="headerlink" title="转发表的建立过程举例："></a>转发表的建立过程举例：</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%8F%E6%98%8E%E7%BD%91%E6%A1%A5%E4%BD%BF%E7%94%A8%E4%BA%86%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95.png" alt="image-20200803192844313"></p>
<h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><p>透明网桥使用了生成树算法，这是为了避免产生转发的帧在网络中不断地兜圈子。 </p>
<p><strong>生成树的得出</strong></p>
<ul>
<li>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即<strong>在任何两个站之间只有一条路径。</strong> </li>
<li>为了避免产生转发的帧在网络中不断地兜圈子。</li>
<li>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。  </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9A%94%E7%A6%BB%E7%BD%91%E6%AE%B5-%E7%BD%91%E6%A1%A5.png" alt="image-20200803202049310"></p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>随着网桥的接口的增加， 后来网桥和集线器合并了，计算机可以直接和交换机连接，这就是交换机。交换机就是网桥和集线器的合并升级版，能全双工，安全通信。端口带宽独享；</p>
<h4 id="交换节的特点"><a href="#交换节的特点" class="headerlink" title="交换节的特点"></a>交换节的特点</h4><ul>
<li>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式。</strong></li>
<li>交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行<strong>无碰撞地传输数据</strong>。 </li>
<li>以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。    </li>
<li><strong>独占传输媒体的带宽</strong> <ul>
<li>对于普通 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。</li>
<li>使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是<strong>独占</strong>而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N=10 Mb/s。这正是交换机的最大优点。 </li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E8%8A%82.png" alt="image-20200803193902141"></p>
<h3 id="3-5-3-虚拟局域网（VLAN）"><a href="#3-5-3-虚拟局域网（VLAN）" class="headerlink" title="3.5.3 虚拟局域网（VLAN）"></a>3.5.3 虚拟局域网（VLAN）</h3><p>虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，虚拟局域网其实知识局域网给用户提供的一种服务，并不是一种新型的局域网。<strong>利用以太网交换机可以很方便地实现虚拟局域网</strong> </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="image-20200803214522049"></p>
<p>如图</p>
<p>当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到广播的信息。</p>
<p>B1 发送数据时，工作站 A1, A2 和 C1都不会收到 B1 发出的广播信息。 </p>
<p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即“广播风暴”)而引起性能恶化。 </p>
<p><strong>虚拟局域网使用的以太网帧格式</strong></p>
<p>虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。 </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="image-20200803214756925"></p>
<h2 id="3-6-高速以太网"><a href="#3-6-高速以太网" class="headerlink" title="3.6 高速以太网"></a>3.6 高速以太网</h2><h3 id="3-6-1-100BASE-T-以太网"><a href="#3-6-1-100BASE-T-以太网" class="headerlink" title="3.6.1  100BASE-T 以太网"></a>3.6.1  100BASE-T 以太网</h3><ul>
<li>速率达到或超过 100 Mb/s 的以太网称为高速以太网。</li>
<li>在双绞线上传送 100 Mb/s 基带信号的星型拓扑以太网，仍使用 IEEE 802.3 的CSMA/CD 协议。100BASE-T 以太网又称为快速以太网(Fast Ethernet)。 </li>
</ul>
<h4 id="100BASE-T-以太网的特点"><a href="#100BASE-T-以太网的特点" class="headerlink" title="100BASE-T 以太网的特点"></a>100BASE-T 以太网的特点</h4><ul>
<li>可在全双工方式下工作而无冲突发生。因此，不使用 CSMA/CD 协议。</li>
<li>MAC 帧格式仍然是 802.3 标准规定的。</li>
<li>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 m。</li>
<li>帧间时间间隔从原来的 9.6 us 改为现在的 0.96 us。</li>
</ul>
<h4 id="三种不同的物理层标准"><a href="#三种不同的物理层标准" class="headerlink" title="三种不同的物理层标准"></a>三种不同的物理层标准</h4><ul>
<li><strong>100BASE-TX</strong><ul>
<li>使用 2 对 UTP 5 类线或屏蔽双绞线 STP。</li>
</ul>
</li>
<li><strong>100BASE-FX</strong> <ul>
<li>使用 2 对光纤。 </li>
</ul>
</li>
<li><strong>100BASE-T4</strong><ul>
<li>使用 4 对 UTP 3 类线或 5 类线。 </li>
</ul>
</li>
</ul>
<h3 id="3-6-2-吉比特以太网"><a href="#3-6-2-吉比特以太网" class="headerlink" title="3.6.2  吉比特以太网"></a>3.6.2  吉比特以太网</h3><ul>
<li>允许在 1 Gb/s 下全双工和半双工两种方式工作。</li>
<li>使用 802.3 协议规定的帧格式。</li>
<li>在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。</li>
<li>与 10BASE-T 和 100BASE-T 技术向后兼容。</li>
</ul>
<h4 id="吉比特以太网的物理层"><a href="#吉比特以太网的物理层" class="headerlink" title="吉比特以太网的物理层"></a>吉比特以太网的物理层</h4><h3 id="3-6-3-10-吉比特以太网"><a href="#3-6-3-10-吉比特以太网" class="headerlink" title="3.6.3  10 吉比特以太网"></a>3.6.3  10 吉比特以太网</h3><ul>
<li>1000BASE-X      基于光纤通道的物理层：<ul>
<li>1000BASE-SX   SX表示短波长</li>
<li>1000BASE-LX   LX表示长波长</li>
<li>1000BASE-CX   CX表示铜线</li>
</ul>
</li>
<li>1000BASE-T <ul>
<li>使用 4对 5 类线 UTP </li>
</ul>
</li>
</ul>
<h4 id="吉比特以太网的配置举例"><a href="#吉比特以太网的配置举例" class="headerlink" title="吉比特以太网的配置举例"></a>吉比特以太网的配置举例</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8E%A5%E5%85%A5%E4%B8%BE%E4%BE%8B.png" alt="image-20200803215414474"></p>
<h3 id="3-6-4-使用高速以太网进行宽带接入"><a href="#3-6-4-使用高速以太网进行宽带接入" class="headerlink" title="3.6.4  使用高速以太网进行宽带接入"></a>3.6.4  使用高速以太网进行宽带接入</h3><ul>
<li>以太网已成功地把速率提高到 1 ~ 10 Gb/s ，所覆盖的地理范围也扩展到了城域网和广域网，因此现在人们正在尝试使用以太网进行宽带接入。</li>
<li>以太网接入的重要特点是它可提供双向的宽带通信，并且可根据用户对带宽的需求灵活地进行带宽升级。</li>
<li>采用以太网接入可实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率和降低了传输的成本。  </li>
</ul>
<h2 id="3-7-其他类型的高速局域网接口"><a href="#3-7-其他类型的高速局域网接口" class="headerlink" title="3.7  其他类型的高速局域网接口"></a>3.7  其他类型的高速局域网接口</h2><h3 id="3-7-1-10-吉比特以太网"><a href="#3-7-1-10-吉比特以太网" class="headerlink" title="3.7.1 10 吉比特以太网"></a>3.7.1 10 吉比特以太网</h3><ul>
<li>10 吉比特以太网与 10 Mb/s，100 Mb/s 和 1 Gb/s 以太网的帧格式完全相同。</li>
<li>10 吉比特以太网还保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。</li>
<li>10 吉比特以太网不再使用铜线而只使用光纤作为传输媒体。</li>
<li>10 吉比特以太网只工作在全双工方式，因此没有争用问题，也不使用 CSMA/CD 协议。    </li>
</ul>
<h3 id="3-7-2-吉比特以太网的物理层"><a href="#3-7-2-吉比特以太网的物理层" class="headerlink" title="3.7.2 吉比特以太网的物理层"></a>3.7.2 吉比特以太网的物理层</h3><ul>
<li>局域网物理层 LAN PHY。局域网物理层的数据率是 10.000 Gb/s。</li>
<li>可选的广域网物理层 WAN PHY。广域网物理层具有另一种数据率，这是为了和所谓的“Gb/s”的 SONET/SDH（即OC-192/STM-64）相连接。<ul>
<li>为了使 10 吉比特以太网的帧能够插入到 OC-192/STM-64 帧的有效载荷中，就要使用可选的广域网物理层，其数据率为 9.95328 Gb/s。   </li>
</ul>
</li>
</ul>
<h3 id="3-7-3-端到端的以太网传输"><a href="#3-7-3-端到端的以太网传输" class="headerlink" title="3.7.3 端到端的以太网传输"></a>3.7.3 端到端的以太网传输</h3><ul>
<li>10 吉比特以太网的出现，以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了端到端的以太网传输。</li>
<li>这种工作方式的好处是： <ul>
<li>成熟的技术</li>
<li>互操作性很好</li>
<li>在广域网中使用以太网时价格便宜。</li>
<li>统一的帧格式简化了操作和管理。     </li>
</ul>
</li>
</ul>
<h3 id="3-7-4-以太网从-10-Mb-s-到10-Gb-s-的演进"><a href="#3-7-4-以太网从-10-Mb-s-到10-Gb-s-的演进" class="headerlink" title="3.7.4 以太网从 10 Mb/s 到10 Gb/s 的演进"></a>3.7.4 以太网从 10 Mb/s 到10 Gb/s 的演进</h3><p>以太网从 10 Mb/s 到 10 Gb/s 的演进证明了以太网是：</p>
<ul>
<li>可扩展的（从 10 Mb/s 到 10 Gb/s）。</li>
<li>灵活的（多种传输媒体、全/半双工、共享/交换）。</li>
<li>易于安装。</li>
<li>稳健性好。 </li>
</ul>
<p><strong>以太网接入举例</strong></p>
<p>![image-20200803215940931](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%90%89%E6%AF%94%E7%89%B9%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%BE%E4%BE%8B">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.链路层/吉比特以太网的配置举例</a> .png)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-3-网络层</title>
    <url>/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1  网络层提供的两种服务"></a>4.1  网络层提供的两种服务</h2><h3 id="4-1-1-虚电路服务"><a href="#4-1-1-虚电路服务" class="headerlink" title="4.1.1 虚电路服务"></a>4.1.1 虚电路服务</h3><ul>
<li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li>请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。 </li>
</ul>
<a id="more"></a>

<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1-1596974404572.png" alt="image-20200804151506884"></p>
<h3 id="4-1-2-数据报服务"><a href="#4-1-2-数据报服务" class="headerlink" title="4.1.2 数据报服务"></a>4.1.2 数据报服务</h3><p><strong>因特网采用的设计思路</strong></p>
<ul>
<li>网络层向上只提供<strong>简单灵活的、无连接的、尽最大努力交付的</strong>数据报服务。</li>
<li>网络在发送分组时<strong>不需要先建立连接</strong>。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li>
<li>网络层<strong>不提供服务质量</strong>的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </li>
</ul>
<p><strong>尽最大努力交付的好处</strong></p>
<ul>
<li>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器做的可以比较简单，而且价格低廉，节省成本。</li>
<li>如果主机中的进程之间的通信时需要可靠传输的，那么就由网络的主机中的运输层负责，（差错管理，和流量控制）</li>
<li>降低成本，运行方式灵活，能够适应多种应用。</li>
</ul>
<p>如图，主机H1发送给主机H2的分组可以不同的路径传送数据报给H2.</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1-1596974404573.png" alt="数据报服务"></p>
<h3 id="4-1-3-数据报服务和虚电路的比较"><a href="#4-1-3-数据报服务和虚电路的比较" class="headerlink" title="4.1.3 数据报服务和虚电路的比较"></a>4.1.3 数据报服务和虚电路的比较</h3><p>![数据报服务和虚电路的比较](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/网际协议</a> IP-1596974404574.png)</p>
<h2 id="4-2-网际协议-IP"><a href="#4-2-网际协议-IP" class="headerlink" title="4.2  网际协议 IP"></a>4.2  网际协议 IP</h2><p>网际协议IP是TCP/IP体系中两个最主要的协议之一；与IP协议配套时延的还有四个协议：</p>
<ol>
<li>地址解析协议<strong>ARP</strong>（Address Resolution Protocol）</li>
<li>逆地址解析协议<strong>RARP</strong>（Reverse Address Resolution Protocol）</li>
<li>网络控制报文协议<strong>ICMP</strong>(Internet Group Management Protocol)</li>
<li>网际组管理协议<strong>IGMP</strong>（Internet Group Management Protocol）</li>
</ol>
<p>![网际协议 IP](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%99%9A%E6%8B%9F%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/互连网络与虚拟互连网络</a> -1596974404574.png)</p>
<h3 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1  虚拟互连网络"></a>4.2.1  虚拟互连网络</h3><p><strong>意义</strong></p>
<ul>
<li>所谓虚拟互联网络也就是逻辑互联网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络从用户看来就好像使一个统一的网络</li>
<li>使用了IP协议的虚拟互联网络可以简称为IP网。</li>
<li>使用虚拟互联网络的好处使：当互联网上的主机进行通信时，就好像时在一个网络上通信一样，而看不见互联的各个具体的网络异构细节。</li>
</ul>
<p>![互连网络与虚拟互连网络](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/IP</a> 地址中的网络号字段和主机号字段-1596974404574.png)</p>
<h3 id="4-2-2-分类的-IP-地址"><a href="#4-2-2-分类的-IP-地址" class="headerlink" title="4.2.2  分类的 IP 地址"></a>4.2.2  分类的 IP 地址</h3><p>​    IP地址就是每个连接因特网的主机（或者路由器）分配一个在全世界范围内是唯一的32位的标识符。IP 地址现在由<strong>因特网名字与号码指派公司</strong>ICANN (Internet Corporation for Assigned Names and Numbers)进行分配  。</p>
<p>​     <strong>IP地址的编址方法</strong></p>
<ul>
<li>分类的 IP 地址。这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li>
<li>子网的划分。这是对最基本的编址方法的改进，其标准[RFC 950]在 1985 年通过。</li>
<li>构成超网。这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li>
</ul>
<h4 id="分类-IP-地址"><a href="#分类-IP-地址" class="headerlink" title="分类 IP 地址"></a>分类 IP 地址</h4><ul>
<li>每一类的地址都由两个固定长度的字段组成，其中一个字段是网络号（net-id），它标志主机或者路由器所连接到的网络，而另一个字段则是主机号（host-id），它标志着主机或者路由器    </li>
<li>两级的IP地址表示：IP地址::={&lt;&gt;网络号,&lt;主机号&gt;}</li>
</ul>
<p><strong>IP 地址中的网络号字段和主机号字段</strong> </p>
<p>![IP 地址中的网络号字段和主机号字段](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/IP</a> 地址与硬件地址（MAC地址）-1596974404574.png)</p>
<p>A类地址：0000 0000 - 0111 1111   0-127</p>
<p>B类地址：1000 0000 - 1011 1111 128-191</p>
<p>C类地址：1100 0000 - 1101 1111 192-223</p>
<p>D类地址：1110 0000 - 1110 1111 224 -239</p>
<p>E类地址：1111 0000 - 1111 1111 240-255</p>
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大网络数</th>
<th>第一个可用的网络号</th>
<th>最后一个可用的网络号</th>
<th>每个网络中最大的主机数</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>126</td>
<td>1</td>
<td>126</td>
<td>256*256*256=16777214</td>
</tr>
<tr>
<td>B</td>
<td>16,383</td>
<td>128.1</td>
<td>191.255</td>
<td>65535</td>
</tr>
<tr>
<td>C</td>
<td>2097151</td>
<td>192.0.1</td>
<td>233.255.255</td>
<td>254</td>
</tr>
</tbody></table>
<p> <strong>几个特殊的地址</strong></p>
<p>127.0.0.1  本机环回地址 169.254.0.0 </p>
<p>保留的私网地址 10.0.0.0</p>
<p>172.16.0.0 — 172.31.0.0</p>
<p>192.168.0.0 - 192.168.255.0</p>
<h3 id="4-2-3-IP-地址与硬件地址（MAC地址）"><a href="#4-2-3-IP-地址与硬件地址（MAC地址）" class="headerlink" title="4.2.3  IP 地址与硬件地址（MAC地址）"></a>4.2.3  IP 地址与硬件地址（MAC地址）</h3><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B-1596974404574.png" alt="IP 地址与硬件地址（MAC地址）"></p>
<p>两个计算机之间的通信过程（从MAC帧和IP数据包的层面来看）</p>
<ol>
<li>交换机基于数据帧来转发地址，路由器基于数据包的IP地址来转发数据包</li>
<li>数据包在传输过程中不变，过网络设备的数据帧要用新的物理地址来重新封装</li>
<li>MAC地址决定了下一条哪个设备接收，而IP地址决定了数据包的起点和终点</li>
</ol>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AF%94%E8%BE%83-1596974404574.png" alt="计算机的通信过程"></p>
<h3 id="4-2-4-地址解析协议-ARP-与逆地址解析协议RARP"><a href="#4-2-4-地址解析协议-ARP-与逆地址解析协议RARP" class="headerlink" title="4.2.4  地址解析协议 ARP 与逆地址解析协议RARP"></a>4.2.4  地址解析协议 ARP 与逆地址解析协议RARP</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul>
<li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 </li>
<li>每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li>
<li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。 </li>
</ul>
<p>ARP协议通过广播解析本网段的计算机MAC地址</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F-1596974404574.png" alt="查看本机MAC地址"></p>
<h4 id="逆地址解析协议-RARP"><a href="#逆地址解析协议-RARP" class="headerlink" title="逆地址解析协议 RARP"></a>逆地址解析协议 RARP</h4><ul>
<li><p>逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。</p>
</li>
<li><p>这种主机往往是无盘工作站。 因此 RARP协议目前已很少使用。 </p>
</li>
</ul>
<h3 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5  IP 数据报的格式"></a>4.2.5  IP 数据报的格式</h3><p>一个IP数据报由首部和数据两部分组成，首部是的前一部分是固定长度，<strong>共20字节</strong>，是所有的IP数据包所必须具有的；在首部的固定部分的后面是一些可选字节，其长度是可变的。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87-1596974404574.png" alt="IP数据报的格式"></p>
<h4 id="IP数据包各个字段"><a href="#IP数据包各个字段" class="headerlink" title="IP数据包各个字段"></a>IP数据包各个字段</h4><ul>
<li>版本：占4位，即IP协议的版本，目前的版本号为4，IPv4协议</li>
<li>首部字长：占4位，可表示的最大数值是15个单位（一个单位为4个字节），因此IP首部长度最大值为60字节。</li>
<li>区分服务：8位，用来获得更好的服务，来设置数据包传送的优先级，表示这个数据包发送的紧急程度（实时性要求）</li>
<li>总长度：占16位，首部和数据之和的长度，单位为字节，因此数据报的最大长度为65535个字节（2的16次方），总长度必须不超过最大传送单元MTU</li>
<li>标识：占 16 位，它是一个计数器，用来产生数据报的标识。</li>
<li>标志：占3位，目前只有前两位有意义，用来告诉数据包是否分片，MF=1表示还有分片，MF=0表示最后一个分片，但是标志的中间的DF=0时才允许分片</li>
<li>片位移：占12位，较长的分组在分片后，片位移以8字节为偏移单位</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/ping%E6%9C%AC%E6%9C%BA-1596974404574.png" alt="IP数据报分片"></p>
<ul>
<li>生存时间：占8位，记为TTL（Time to live）数据报在网络中可通过路由器数的最大值。Windows默认为128</li>
</ul>
<p>如图ping本机的TTL为128</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E6%9C%BAMAC%E5%9C%B0%E5%9D%80-1596974404574.png" alt="image-20200806135338405"></p>
<p>当我ping一下p站，TTL就54，说明经过了74个路由器。</p>
<p>想上p站学习的同学可以看下这个注册一下，一直在用，很稳定</p>
<p><a href="https://www.cuuc.club//auth/register?code=UZ97">https://www.cuuc.club//auth/register?code=UZ97</a></p>
<pre><code>                               ![pingP站的地址](https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/4协议字段-1596974404574.png) </code></pre>
<ul>
<li>协议：占8位，字段指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/42%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90IP%E6%95%B0%E6%8D%AE%E6%8A%A5-1596974404574.png" alt="4协议字段"></p>
<ul>
<li>首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。如下图为首部校验和的运算方法</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E9%A6%96%E9%83%A8%E6%A0%A1%E9%AA%8C%E5%92%8C-1596974404574.png" alt="首部校验和"></p>
<p>例子：</p>
<p> <strong>IP头：</strong></p>
<p> 45 00  00 31</p>
<p> 89 F5  00 00</p>
<p> 6E 06  00 00（校验字段）</p>
<p> DE B7  45 5D    -&gt;  222.183.69.93  (源IP地址)</p>
<p> C0 A8  00 DC    -&gt;  192.168.0.220 (目的IP地址)</p>
<p> 计算： </p>
<p> 4500 + 0031 +89F5 + 0000 + 6e06+0000 + DEB7 + 455D + C0A8 + 00DC =3 22C4 （结果大于4bit,继续迭代计算)</p>
<p> 0003 + 22C4 = 22C7 </p>
<p> ~22C7 = DD38   -&gt;即为应填充的校验和</p>
<p> 当接受到IP数据包时，要检查IP头是否正确，则对IP头进行检验，方法同上：</p>
<p> 计算：</p>
<p> 4500 + 0031 +89F5 + 0000 + 6E06+DD38 + DEB7 + 455D + C0A8 + 00DC =3 FFFC</p>
<p> 0003 + FFFC = FFFF</p>
<p> 得到的结果是全1（取反为0），正确。</p>
<ul>
<li>可变部分：n选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。n增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</li>
</ul>
<h4 id="使用WireShark抓包分析"><a href="#使用WireShark抓包分析" class="headerlink" title="使用WireShark抓包分析"></a>使用WireShark抓包分析</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/pingP%E7%AB%99%E7%9A%84%E5%9C%B0%E5%9D%80-1596974404574.png" alt="42抓包分析IP数据报"></p>
<h3 id="4-2-6-IP-层转发分组的流程"><a href="#4-2-6-IP-层转发分组的流程" class="headerlink" title="4.2.6  IP 层转发分组的流程"></a>4.2.6  IP 层转发分组的流程</h3><p>根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p>
<ul>
<li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li>
<li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li>
</ul>
<p>![IP 层转发分组的流程](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/IP</a> 层转发分组的流程-1596974404575.png)</p>
<p><strong>分组转发算法</strong></p>
<p>(1) 从数据报的首部<strong>提取目的主机的 IP 地址 <em>D</em></strong>, 得出<strong>目的网络地址为 <em>N</em></strong>。</p>
<p>(2) 若网络 <em>N</em> <strong>与此路由器直接相连</strong>，则把数据报<strong>直接交付</strong>目的主机 <em>D</em>；否则是<strong>间接交付</strong>，执行(3)。</p>
<p>(3) 若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。</p>
<p>(4) 若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。</p>
<p>(5) 若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。</p>
<p>(6) 报告<strong>转发分组出错</strong>。 </p>
<p><strong>默认路由</strong></p>
<ul>
<li>路由器还可采用默认路由以<strong>减少路由表所占用的空间和搜索路由表所用的时间</strong>。</li>
<li>这种转发方式在一个网络只有<strong>很少的对外连接</strong>时是很有用的。</li>
<li>默认路由在主机发送 IP 数据报时往往更能显示出它的好处。</li>
<li>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的</li>
</ul>
<h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3  划分子网和构造超网"></a>4.3  划分子网和构造超网</h2><h3 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1  划分子网"></a>4.3.1  划分子网</h3><h4 id="划分子网的基本思路"><a href="#划分子网的基本思路" class="headerlink" title="划分子网的基本思路"></a>划分子网的基本思路</h4><ul>
<li>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<blockquote>
<p>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;} </p>
</blockquote>
<ul>
<li>B类地址，有两级结构，划分子网后变成了三级结构 </li>
<li>划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号 net-id。 </li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1-1596974404575.png" alt="image-20200807010522805"></p>
<p><strong>添加静态路由</strong></p>
<p>Windows网关就是默认路由<br>查看Windows本地路由表</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/windows%E6%9C%AC%E5%9C%B0%E8%B7%AF%E7%94%B1%E8%A1%A8-1596974404575.png" alt="image-20200807012827710"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>​        从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。 </p>
<blockquote>
<p>(IP 地址) AND (子网掩码) =网络地址</p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%B8%8E%E8%BF%90%E7%AE%97-1596974404575.png" alt="IP地址与子网掩码进行与运算"></p>
<p><strong>默认子网掩码</strong> </p>
<p>![默认子网掩码 ](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E9%BB%98%E8%AE%A4%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/默认子网掩码</a> -1596974404575.png)</p>
<h4 id="对B类地址进行子网划分"><a href="#对B类地址进行子网划分" class="headerlink" title="对B类地址进行子网划分"></a>对B类地址进行子网划分</h4><p>对 172.16.0.0  进行划分成两个子网</p>
<table>
<thead>
<tr>
<th>子网一</th>
<th>172.16.0.1 - 172.16.127.254</th>
</tr>
</thead>
<tbody><tr>
<td>子网二</td>
<td>172.16.128.1 - 172.16.255.254</td>
</tr>
<tr>
<td>子网掩码</td>
<td>255.255.128.0</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意： 划分主机时，主机号不能全为0或者全为1</strong></p>
<p>使用点到点网络，子网掩码最好是252</p>
</blockquote>
<h4 id="对C类地址进行等长子网划分"><a href="#对C类地址进行等长子网划分" class="headerlink" title="对C类地址进行等长子网划分"></a>对C类地址进行等长子网划分</h4><p>对192.168.0.0 255.255.255.0 这个C类地址分别进行等分2、4、8个子网</p>
<p>等分成两个子网   </p>
<table>
<thead>
<tr>
<th>192</th>
<th>168</th>
<th>0</th>
<th>0</th>
<th>000 0000 - 0111 1111</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td><strong>1</strong></td>
<td>000 0000 - 1111 1111</td>
</tr>
</tbody></table>
<p>可分配的主机号和划分的子网</p>
<table>
<thead>
<tr>
<th>192.168.0.1 - 192.168.0.126</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.128 - 192.168.0.254</td>
</tr>
</tbody></table>
<p>子网掩码</p>
<table>
<thead>
<tr>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1000 0000</th>
</tr>
</thead>
<tbody><tr>
<td>255</td>
<td>255</td>
<td>255</td>
<td>128</td>
</tr>
</tbody></table>
<p>等分成四个子网   拿出两位主机Id来进行划分</p>
<table>
<thead>
<tr>
<th>192</th>
<th>168</th>
<th>0</th>
<th><strong>0</strong>0</th>
<th>00 0000 - 0011 1111</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>01</td>
<td>00 0000 - 0111 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>10</td>
<td>00 0000 - 1011 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>11</td>
<td>00 0000 - 1111 1111</td>
</tr>
</tbody></table>
<p>可分配的主机号和划分的子网</p>
<table>
<thead>
<tr>
<th>192.168.0.1 - 192.168.0.62</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.65 - 192.168.0.126</td>
</tr>
<tr>
<td>192.168.0.128 - 192.168.0.190</td>
</tr>
<tr>
<td>192.168.0.193 - 192.168.0.254</td>
</tr>
</tbody></table>
<p>子网掩码</p>
<table>
<thead>
<tr>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1100 0000</th>
</tr>
</thead>
<tbody><tr>
<td>255</td>
<td>255</td>
<td>255</td>
<td>192</td>
</tr>
</tbody></table>
<p>等分成八个子网    拿出三位主机Id来进行划分</p>
<table>
<thead>
<tr>
<th>192</th>
<th>168</th>
<th>0</th>
<th><strong>0</strong>00</th>
<th>0 0000 - 0001 1111</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>001</td>
<td>0 0000 - 0011 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>010</td>
<td>0 0000 - 0101 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>011</td>
<td>0 0000 - 0111 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>100</td>
<td>0 0000 - 1001 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>101</td>
<td>0 0000 - 1011 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>110</td>
<td>0 0000 -  1101 1111</td>
</tr>
<tr>
<td>192</td>
<td>168</td>
<td>0</td>
<td>111</td>
<td>0 0000 -  1111 1111</td>
</tr>
</tbody></table>
<p>可分配的主机号和划分的子网</p>
<table>
<thead>
<tr>
<th>192.168.0.1 - 192.168.0.30</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.33 - 192.168.0.62</td>
</tr>
<tr>
<td>192.168.0.65 - 192.168.0.94</td>
</tr>
<tr>
<td>192.168.0.97 - 192.168.0.126</td>
</tr>
<tr>
<td>192.168.0.129 - 192.168.0.158</td>
</tr>
<tr>
<td>192.168.0.161 - 192.168.0.190</td>
</tr>
<tr>
<td>192.168.0.193 - 192.168.0.222</td>
</tr>
<tr>
<td>192.168.0.225 - 192.168.0.254</td>
</tr>
</tbody></table>
<p>子网掩码</p>
<table>
<thead>
<tr>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1111 1111</th>
<th>1110 0000</th>
</tr>
</thead>
<tbody><tr>
<td>255</td>
<td>255</td>
<td>255</td>
<td>224</td>
</tr>
</tbody></table>
<h4 id="对C类地址进行变长子网划分"><a href="#对C类地址进行变长子网划分" class="headerlink" title="对C类地址进行变长子网划分"></a>对C类地址进行变长子网划分</h4><p>如将192.168.0.0这个C类子网划分为子网一有50个主机，子网二有100个主机</p>
<p>子网二有100台主机小于128-2  所以 分配192.168.0.0/25的第一个网段供其使用</p>
<table>
<thead>
<tr>
<th align="left">192</th>
<th>168</th>
<th>0</th>
<th>0</th>
<th>000 0000 - 0111 1111</th>
</tr>
</thead>
<tbody><tr>
<td align="left">子网掩码</td>
<td>192.</td>
<td>168.</td>
<td>0.</td>
<td>128</td>
</tr>
</tbody></table>
<p>子网一有50个主机小于64-2   将  192.168.0.128 -   192.168.0.192  这个网段提供给他使用</p>
<table>
<thead>
<tr>
<th>192</th>
<th>168</th>
<th>0</th>
<th>10</th>
<th>00 0000 - 1011 1111</th>
</tr>
</thead>
<tbody><tr>
<td>子网掩码</td>
<td>192.</td>
<td>168.</td>
<td>0.</td>
<td>192</td>
</tr>
</tbody></table>
<h4 id="利用超网合并网段"><a href="#利用超网合并网段" class="headerlink" title="利用超网合并网段"></a>利用超网合并网段</h4><p>如图，将两个C类子网 192.168.0.0和 192.168.0.1两个C位地址合并成一个网段，两边的计算机就能通信，相当于在一个子网下，</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B6%85%E7%BD%91%E5%90%88%E5%B9%B6-1596974404575.png" alt="超网合并"></p>
<p>我们可以看到将子网掩码往左移动一位，网络部分就一样了，这两个网段就在一个网段了。</p>
<table>
<thead>
<tr>
<th>192</th>
<th>168</th>
<th>0000 0000</th>
<th>0000 0000</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>168</td>
<td>0000 0001</td>
<td>0000 0000</td>
</tr>
<tr>
<td>1111 1111</td>
<td>1111 1111</td>
<td>1111 1110</td>
<td>0000 0000</td>
</tr>
<tr>
<td>255</td>
<td>255</td>
<td>254</td>
<td>0</td>
</tr>
</tbody></table>
<p>合并规律总结</p>
<p>判断一个C类网络能不能合并为一个超网，可参照图中规则，若两个C类网络合并为一个网络，则可以将两个网络的第三部分对4区域，看是否在0、1或者23区域内，不在则说明不可合并。</p>
<p>![合并规律总结](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/ICMP</a> 报文的格式-1596974404575.png)</p>
<h3 id="4-3-2-使用子网时分组转发"><a href="#4-3-2-使用子网时分组转发" class="headerlink" title="4.3.2  使用子网时分组转发"></a>4.3.2  使用子网时分组转发</h3><p>使用子网划分后，路由器必须包括以下三项内容：<strong>目的网络地址</strong>、<strong>子网掩码</strong>和<strong>下一跳地址</strong>。<br>路由器转发分组算法：</p>
<ol>
<li>从收到的分组的首部提取目的 IP 地址 D。</li>
<li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。</li>
<li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。</li>
<li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。</li>
<li>报告转发分组出错</li>
</ol>
<h3 id="4-3-3-无分类编址-CIDR（构造超网）"><a href="#4-3-3-无分类编址-CIDR（构造超网）" class="headerlink" title="4.3.3  无分类编址 CIDR（构造超网）"></a>4.3.3  无分类编址 CIDR（构造超网）</h3><h4 id="网络前缀"><a href="#网络前缀" class="headerlink" title="网络前缀"></a>网络前缀</h4><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而在 1992 年因特网仍然面临三个必须尽早解决的问题，这就是：</p>
<ul>
<li><p>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</p>
</li>
<li><p>因特网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</p>
</li>
<li><p>整个 IPv4 的地址空间最终将全部耗尽。</p>
</li>
</ul>
<h4 id="IP-编址问题的演进"><a href="#IP-编址问题的演进" class="headerlink" title="IP 编址问题的演进"></a>IP 编址问题的演进</h4><ul>
<li><p>1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用变长子网掩码 VLSM (Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率。</p>
</li>
<li><p>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是无分类域间路由选择 CIDR (Classless Inter-Domain Routing)。 </p>
</li>
</ul>
<h4 id="CIDR-最主要的特点"><a href="#CIDR-最主要的特点" class="headerlink" title="CIDR 最主要的特点"></a>CIDR 最主要的特点</h4><ul>
<li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li>
<li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。 </li>
</ul>
<h4 id="无分类的两级编址"><a href="#无分类的两级编址" class="headerlink" title="无分类的两级编址"></a>无分类的两级编址</h4><ul>
<li>无分类的两级编址的记法是： <ul>
<li>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}      (4-3) </li>
</ul>
</li>
<li>CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。</li>
<li>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。 </li>
</ul>
<h4 id="CIDR-地址块"><a href="#CIDR-地址块" class="headerlink" title="CIDR 地址块"></a>CIDR 地址块</h4><ul>
<li>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。</li>
<li>这个地址块的起始地址是 128.14.32.0。</li>
<li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li>
<li>128.14.32.0/20 地址块的最小地址：128.14.32.0</li>
<li>128.14.32.0/20 地址块的最大地址：128.14.47.255</li>
<li>全 0 和全 1 的主机号地址一般不使用。</li>
</ul>
<h4 id="构造超网"><a href="#构造超网" class="headerlink" title="构造超网"></a>构造超网</h4><ul>
<li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。</li>
<li>这些 C 类地址合起来就构成了超网。</li>
<li>CIDR 地址块中的地址数一定是 2 的整数次幂。</li>
<li>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长</li>
</ul>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><ul>
<li><p>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。 </p>
</li>
<li><p>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配(longest-prefix matching)。</p>
</li>
<li><p>网络前缀越长，其地址块就越小，因而路由就越具体(more specific) 。</p>
</li>
<li><p>最长前缀匹配又称为最长匹配或最佳匹配。  </p>
</li>
</ul>
<h4 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h4><p>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong>(binary trie)。</p>
<h2 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4  网际控制报文协议 ICMP"></a>4.4  网际控制报文协议 ICMP</h2><ul>
<li><p>为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p>
</li>
<li><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
</li>
<li><p>ICMP 不是高层协议，而是 IP 层的协议。</p>
</li>
<li><p>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。  </p>
</li>
</ul>
<p>![image-20200806223915536](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/ICMP</a> 差错报告报文的数据字段的内容-1596974404575.png)</p>
<h3 id="4-4-1-ICMP-报文的种类"><a href="#4-4-1-ICMP-报文的种类" class="headerlink" title="4.4.1  ICMP 报文的种类"></a>4.4.1  ICMP 报文的种类</h3><h4 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h4><p>ICMP 差错报告报文共有 5 种 </p>
<ul>
<li><p>终点不可达 </p>
</li>
<li><p>源点抑制(Source quench)  </p>
</li>
<li><p>时间超过 </p>
</li>
<li><p>参数问题 </p>
</li>
<li><p>改变路由（重定向）(Redirect)  </p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/ping%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-1596974404575.png" alt="image-20200806224019338"></p>
<p><strong>不应发送 ICMP 差错报告报文的几种情况</strong> </p>
<ul>
<li><p>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</p>
</li>
<li><p>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</p>
</li>
<li><p>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</p>
</li>
<li><p>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</p>
</li>
</ul>
<h4 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h4><p>ICMP 询问报文有两种 </p>
<ul>
<li><p>回送请求和回答报文</p>
</li>
<li><p>时间戳请求和回答报文</p>
</li>
</ul>
<p>下面的几种 ICMP 报文不再使用</p>
<ul>
<li><p>信息请求与回答报文</p>
</li>
<li><p>掩码地址请求和回答报文</p>
</li>
<li><p>路由器询问和通告报文 </p>
</li>
</ul>
<h3 id="4-4-2-ICMP-的应用举例"><a href="#4-4-2-ICMP-的应用举例" class="headerlink" title="4.4.2  ICMP 的应用举例"></a>4.4.2  ICMP 的应用举例</h3><ul>
<li><p>PING 用来测试两个主机之间的连通性。</p>
</li>
<li><p>PING 使用了 ICMP 回送请求与回送回答报文。</p>
</li>
<li><p>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 </p>
</li>
</ul>
<p>ping的应用举例</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%90%88%E5%B9%B6%E8%A7%84%E5%BE%8B%E6%80%BB%E7%BB%93-1596974404575.png" alt="image-20200806230556248"></p>
<p>Traceroute 的应用举例</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BD%BF%E7%94%A8pathping%E8%B7%9F%E8%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E8%B7%AF%E5%BE%84-1596974404575.png" alt="image-20200806230632531"></p>
<p><strong>使用pathping跟踪数据包的路径。</strong></p>
<p>使用pathping能够判断网络通还是不通，比如请求超时，你就不能判断在什么位置出现的网络故障造成的请求超时，使用pathping就可以跟踪数据包的路径，查出故障点，计算路由器的转发丢包率和链路丢包率和延迟，据此判断出网络拥塞的情况。如图所示</p>
<p>![image-20200807001047280](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/Traceroute">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/Traceroute</a> 的应用举例-1596974404575.png)</p>
<h2 id="4-5-因特网的路由选择协议"><a href="#4-5-因特网的路由选择协议" class="headerlink" title="4.5  因特网的路由选择协议"></a>4.5  因特网的路由选择协议</h2><h3 id="4-5-1-有关路由选择协议的几个基本概念"><a href="#4-5-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.5.1  有关路由选择协议的几个基本概念"></a>4.5.1  有关路由选择协议的几个基本概念</h3><h4 id="1-理想的路由选择"><a href="#1-理想的路由选择" class="headerlink" title="1.理想的路由选择"></a>1.理想的路由选择</h4><ol>
<li>完整与正确</li>
<li>计算简单</li>
<li>能适应通信量与网络拓扑的变化，有自适应性（稳健性）</li>
<li>具有稳定性</li>
<li>应是最佳的，相对于某种特定需求下较为合理的选择</li>
</ol>
<p>从路由算法的自适应性考虑分两大类：</p>
<ul>
<li>静态路由选择策略（非自适应路由选择）：简单，开销小，但不能适应网络状态的变化</li>
<li>动态路由选择策略（自适应路由选择）：能较好适应网络状态的变化，但实现较为复杂，开销大</li>
</ul>
<h4 id="2-分层次的路由选择协议"><a href="#2-分层次的路由选择协议" class="headerlink" title="2.分层次的路由选择协议"></a>2.分层次的路由选择协议</h4><p>将互联网划分为许多小的自治系统，记为AS，一个AS对其他AS表现出<strong>单一的和一致的路由选择策略</strong>。<br>互联网把路由选择协议划分为两大类：</p>
<ol>
<li><strong>内部网关协议IGP</strong>：自治系统内部使用的路由选择协议，如<strong>RIP和OSPF</strong></li>
<li><strong>外部网关协议EGP</strong>：当源主机与目的主机处在不同的自治系统中所使用的路由选择协议，目前使用最多的是<strong>BGP-4</strong></li>
</ol>
<p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong>(interdomain routing)，<br>在自治系统内部的路由选择叫做<strong>域内路由选择</strong>(intradomain routing)</p>
<p>分析：<br>本路由器与相邻路由器相距为1，通过相邻路由表可知，本路由器经过相邻路由器到达目的地址的距离会加1，所以d+1，下一跳设置为X。然后对路由表进行比较，目的地址未知则直接添加，目的地址已知，看本路由表下一跳是否为X，如果是，则更新，因为这是最新消息。如果不是，比较距离，距离比原来小可添加。如果长时间收不到更新路由表，则自动标记为不可达。</p>
<p><strong>RIP2 协议的报文格式</strong></p>
<p>RIP 协议的优缺点</p>
<ul>
<li>RIP 存在的一个问题是当网络出现故障时，要经过<strong>比较长的时间</strong>才能将此信息传送到所有的路由器。</li>
<li>RIP 协议最大的优点就是<strong>实现简单，开销较小</strong>。</li>
<li>RIP 限制了网络的规模，它能使用的<strong>最大距离为 15</strong>（16 表示不可达）</li>
</ul>
<h3 id="4-5-2-内部网关协议-RIP"><a href="#4-5-2-内部网关协议-RIP" class="headerlink" title="4.5.2  内部网关协议 RIP"></a>4.5.2  内部网关协议 RIP</h3><p>RIP是一种分布式的基于距离向量的路由选择协议，网关就是默认路由<strong>“距离”的定义</strong>：</p>
<ul>
<li>从一路由器到直接连接的网络的距离定义为 1。从一个路由器到非直接连接的网络的距离定义为<strong>所经过的路由器数加 1</strong>。</li>
<li>RIP 协 议 中 的 **“ 距 离 ” 也 称 为 “ 跳数”(hop count)**，因为每经过一个路由器，跳数就加 1。</li>
<li>RIP 允许一条路径最多只能包含 15 个路由器。<strong>“距离”的最大值为16 时即相当于不可达</strong>。可见 RIP 只适用于小型互联网。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">路由选择算法</span><br><span class="line">已知地址为X的相邻路由器发来RIP报文，先将收到的报文下一跳该为X，</span><br><span class="line">所有距离加<span class="number">1</span>，再对该表与自身路由表逐条进行比较。</span><br><span class="line"><span class="keyword">if</span>（原路由表无目的网络N）&#123;</span><br><span class="line">    将该项目添加到路由表中&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">else</span>（本机路由表下一跳为X）&#123;</span><br><span class="line">    将该条更新原本的项目&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">else</span>（距离&lt;原来）&#123;</span><br><span class="line">    更新该条到路由表&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    不做更新操作&#125;</span><br><span class="line"><span class="keyword">if</span>（三分钟收不到更新路由表）&#123;</span><br><span class="line">    将此相邻路由表距离设置为<span class="number">16</span>（不可达）&#125;</span><br></pre></td></tr></table></figure>

<p>分析：<br>本路由器与相邻路由器相距为1，通过相邻路由表可知，本路由器经过相邻路由器到达目的地址的距离会加1，所以d+1，下一跳设置为X。然后对路由表进行比较，目的地址未知则直接添加，目的地址已知，看本路由表下一跳是否为X，如果是，则更新，因为这是最新消息。如果不是，比较距离，距离比原来小可添加。如果长时间收不到更新路由表，则自动标记为不可达。</p>
<p><strong>RIP协议缺点</strong>：<br>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。<br>RIP 协议的<strong>三个要点</strong>：</p>
<ul>
<li>仅和<strong>相邻路由器</strong>交换信息。</li>
<li>交换的信息是<strong>当前本路由器所知道的全部信息</strong>，即自己的路由表。</li>
<li><strong>按固定的时间间隔交换路由信息</strong>，例如，<strong>每隔 30 秒</strong>（广播）。</li>
</ul>
<p><strong>RIP2协议的报文格式</strong></p>
<p>![image-20200807124436611](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/RIP2">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/RIP2</a> 协议的报文格式-1596974404575.png)</p>
<ul>
<li><p>RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</p>
</li>
<li><p>路由标记填入自治系统的号码，这是考虑使RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。 nRIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。</p>
</li>
</ul>
<h3 id="4-5-3-内部网关协议-OSPF"><a href="#4-5-3-内部网关协议-OSPF" class="headerlink" title="4.5.3  内部网关协议 OSPF"></a>4.5.3  内部网关协议 OSPF</h3><p><strong>开放的最短路径优先</strong>OSPF，主要特征是使用分布式的<strong>链路状态协议</strong>。<br>要点：</p>
<ol>
<li>使用<strong>泛洪法</strong>，向本自治系统所有·路由器发送信息</li>
<li>发送的是有本路由器<strong>相邻的所有路由器的链路状态</strong></li>
<li>只有<strong>链路状态改变</strong>时才使用泛洪发送信息</li>
</ol>
<p>OSPF 将一个自治系统再划分为若干个更小的范围，叫作<strong>区域</strong>。区域也不能太大，在一个区域内的路由器最好<strong>不超过 200 个</strong>。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/OSPF%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86-1596974404575.png" alt="image-20200807125441219"></p>
<p>OSPF建立<strong>网络拓扑结构图</strong>的方式：</p>
<ol>
<li>首先每个路由器会每10s对相邻的路由器<strong>发送问候（Hello）分组</strong>，来维持相邻路由器的可达性。</li>
<li>通过交换得到的链路状态信息，建立<strong>链路状态数据库</strong>，构造全网的拓扑结构图。</li>
<li>当链路状态发生改变时，每个路由器都能及时<strong>更新同步数据库</strong>。</li>
</ol>
<p>OSPF 直接用 IP 数据报传送，OSPF 不用 UDP 而是直接用 IP 数据报传送。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p>
<p><strong>OSPF 分组</strong> </p>
<p> <img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/OSPF%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%84-1596974404575.png" alt="image-20200807133033231"></p>
<p>OSPF 的五种分组类型 </p>
<ul>
<li><p>类型1，问候(Hello)分组。</p>
</li>
<li><p>类型2，数据库描述(Database Description)分组。</p>
</li>
<li><p>类型3，链路状态请求(Link State Request)分组。</p>
</li>
<li><p>类型4，链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态。</p>
</li>
<li><p>类型5，链路状态确认(Link State Acknowledgment)分组。 </p>
</li>
</ul>
<p><strong>洪泛法</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%B4%AA%E6%B3%9B%E6%B3%95-1596974404575.png" alt="image-20200807133244795"></p>
<h3 id="4-5-4-外部网关协议-BGP"><a href="#4-5-4-外部网关协议-BGP" class="headerlink" title="4.5.4  外部网关协议 BGP"></a>4.5.4  外部网关协议 BGP</h3><p>边界网关协议 BGP 只能是力求寻找一条能够<strong>到达目的网络且比较好的路由</strong>（不能兜圈子），而并非要寻找一条最佳路由。每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ <strong>BGP 发言人</strong>” ，一般为BGP边界路由器。</p>
<p>![image-20200807133927638](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/BGP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/BGP</a> 发言人和自治系统 AS 的关系 -1596974404575.png)</p>
<p>通过BGP协议可将上图的网络看做是如下形式：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/BGP%E5%8D%8F%E8%AE%AE%E5%9B%BE%E5%BD%A2%E5%BC%8F-1596974404575.png" alt="image-20200807134023803"></p>
<p>进而实现多级ISP的网络多级结构</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/BGP%E8%BF%9B%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7ISP%E7%9A%84%E7%BD%91%E7%BB%9C%E5%A4%9A%E7%BA%A7%E7%BB%93%E6%9E%84-1596974404575.png" alt="image-20200807134118898"></p>
<h3 id="4-5-6-路由器的构成"><a href="#4-5-6-路由器的构成" class="headerlink" title="4.5.6  路由器的构成"></a>4.5.6  路由器的构成</h3><ul>
<li><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。</p>
</li>
<li><p>下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。 </p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84-1596974404575.png" alt="image-20200807145119474"></p>
<h2 id="4-6-IP-多播"><a href="#4-6-IP-多播" class="headerlink" title="4.6  IP 多播"></a>4.6  IP 多播</h2><h3 id="4-6-1-IP-多播的基本概念"><a href="#4-6-1-IP-多播的基本概念" class="headerlink" title="4.6.1  IP 多播的基本概念"></a>4.6.1  IP 多播的基本概念</h3><p>![image-20200807145417131](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/IP</a> 多播的基本概念-1596974404576.png)</p>
<p>多播可明显地减少网络中资源的消耗</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%A4%9A%E6%92%AD%E5%8F%AF%E6%98%8E%E6%98%BE%E5%9C%B0%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%B5%84%E6%BA%90%E7%9A%84%E6%B6%88%E8%80%97-1596974404576.png" alt="image-20200807145455747"></p>
<p>IP 多播的一些特点 </p>
<p>(1) 多播使用组地址—— IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址。 </p>
<p>(2) 永久组地址——由因特网号码指派管理局 IANA 负责指派。</p>
<p>(3) 动态的组成员 </p>
<p>(4) 使用硬件进行多播</p>
<h3 id="4-6-2-在局域网上进行硬件多播"><a href="#4-6-2-在局域网上进行硬件多播" class="headerlink" title="4.6.2  在局域网上进行硬件多播"></a>4.6.2  在局域网上进行硬件多播</h3><ul>
<li><p>因特网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5E。</p>
</li>
<li><p>因此 TCP/IP 协议使用的以太网多播地址块的范围是：从 00-00-5E-00-00-00到 00-00-5E-FF-FF-FF </p>
</li>
<li><p>D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。</p>
</li>
</ul>
<p>![image-20200807145632540](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/D">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/D</a> 类 IP 地址与以太网多播地址的映射关系 -1596974404576.png)</p>
<h3 id="4-6-2-因特网组管理协议-IGMP-和多播路由选择协议"><a href="#4-6-2-因特网组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="4.6.2  因特网组管理协议 IGMP 和多播路由选择协议"></a>4.6.2  因特网组管理协议 IGMP 和多播路由选择协议</h3><p><strong>IP多播需要两种协议</strong></p>
<ul>
<li><p>为了使路由器知道多播组成员的信息，需要利用网际组管理协议 IGMP (Internet Group Management Protocol)。</p>
</li>
<li><p>连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。 </p>
</li>
</ul>
<p>![image-20200807145731350](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%94%A8%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/用隧道技术实现虚拟专用网</a> -1596974404576.png)</p>
<p><strong>IGMP</strong></p>
<p> IGMP是一个单独的协议，属于整个网际协议 IP 的一个组成部分。 </p>
<p><strong>IGMP 可分为两个阶段</strong> </p>
<p>第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。</p>
<p>第二阶段：因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p>
<h2 id="4-7-虚拟专用网-VPN-和网络地址转换-NAT"><a href="#4-7-虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="4.7  虚拟专用网 VPN 和网络地址转换 NAT"></a>4.7  虚拟专用网 VPN 和网络地址转换 NAT</h2><h3 id="4-7-1-虚拟专用网-VPN"><a href="#4-7-1-虚拟专用网-VPN" class="headerlink" title="4.7.1  虚拟专用网 VPN"></a>4.7.1  虚拟专用网 VPN</h3><ul>
<li>本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</li>
<li>全球地址——全球唯一的IP地址，必须向因特网的管理机构申请</li>
</ul>
<p>![image-20200807150147018](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IGMP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/3.网络层/IGMP</a> 使多播路由器知道多播组成员信息 -1596974404576.png)</p>
<p>A与B内部的通信本来不经过互联网，如果两者之间想要通信，可使用VPN技术，A将数据报作为内部数据发给路由器R1，路由器R1收到数据报后，对内部数据报加密（保证数据安全），然后重新加上数据报的首部，封装成互联网的外部数据报，到达R2，然后在进行解密，从而实现两者间的通信</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="4-7-2-网络地址转换-NAT"><a href="#4-7-2-网络地址转换-NAT" class="headerlink" title="4.7.2  网络地址转换 NAT"></a>4.7.2  网络地址转换 NAT</h3><p>NAT原理：<br>内部主机 X 用本地地址 IPX 和因特网上主机 Y 通信所发送的数据报必须经过 NAT 路由器。NAT 路由器将<strong>数据报的源地址 IPX 转换成全球地址 IPG</strong>，但目的地址 IPY 保持不变，然后发送到因特网。NAT 路由器收到主机 Y 发回的数据报时，知道数据报中的源地址是 IPY 而目的地址是 IPG。根据 NAT 转换表，NAT 路由器将目的地址 IPG转换为 IPX，转发给最终的内部主机 X。</p>
<p>现常用的NAT转换表利用<strong>运输层的端口号</strong>，使得多个拥有本地地址的主机共用一个路由器上的全球IP地址，使用端口号的NAT也叫网络地址与端口号转换NAPT。</p>
<p>使用<strong>netstat -n</strong> 可查看建立会话的目<strong>标端口</strong>和<strong>源端口</strong></p>
<p><img src="3-%E7%BD%91%E7%BB%9C%E5%B1%82.assets/%E6%9F%A5%E7%9C%8B%E5%BB%BA%E7%AB%8B%E4%BC%9A%E8%AF%9D%E7%9A%84%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3%E5%92%8C%E6%BA%90%E7%AB%AF%E5%8F%A3.png" alt="image-20200807150340268"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-4-运输层</title>
    <url>/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code> 回顾</code></pre>
<p><strong>应用层</strong>  Http Https  ftp DNS SMTP PoP3 RDP</p>
<p><strong>传输层</strong>     TCP    UDP</p>
<p><strong>网络层</strong>    IP（RIP OSPF    BGP）     ICMP IGMP ARP</p>
<a id="more"></a>

<h3 id="传输层的两个应用场景"><a href="#传输层的两个应用场景" class="headerlink" title="传输层的两个应用场景"></a>传输层的两个应用场景</h3><p><strong>TCP</strong>  分段传输，给每段数据编号，接收端按照编号检查，丢哪个包就叫发送端重传），流量控制，是可靠性传输，建立会话：netstat -n可查看会话。例：下载文件，（发送方要把数据分成多个数据包并编上号，接收端收到之后检查编号是否完整，再把所有数据包按编号串起来才能完整接受）、访问网站、上传文件。</p>
<p><strong>UDP</strong> 不编号，一个数据包就能完成数据通信，只扔出一个数据包，丢了就连接失败，不建立会话，是不可靠传输。例如：qq聊天、多播（老师把自己的电脑画面播到每个学生电脑上）；</p>
<h3 id="运输层与应用层之间的关系"><a href="#运输层与应用层之间的关系" class="headerlink" title="运输层与应用层之间的关系"></a>运输层与应用层之间的关系</h3><ul>
<li>http协议，使用80端口，HTTP=TCP+80</li>
<li>使用https安全传输时，使用443端口，https=TCP+443</li>
<li>ftp=TCP+21</li>
<li>SMTP=TCP+25</li>
<li>POP3=TCP+110</li>
<li>RDP=TCP+3389</li>
<li>共享文件夹=TCP+445</li>
<li>SQL=TCP+1433</li>
<li>DNS=UDP+53 or TCP+53;</li>
</ul>
<p>应用层协议其实就是传输层的两种主要协议加上相应端口来表示是哪一种应用层协议。其实就是传输层协议加上一个使用的端口号就表示一种应用。比如可以这样命名一个应用层协议：KON=TCP+4000 。</p>
<h3 id="应用层协议和服务之间的关系"><a href="#应用层协议和服务之间的关系" class="headerlink" title="应用层协议和服务之间的关系"></a>应用层协议和服务之间的关系</h3><p>服务（对外提供的服务）运行后在TCP或UDP的某个端口侦听客户端请求。</p>
<p>一台计算机上可能运行有多种服务，但是只有一个IP地址。</p>
<ul>
<li>Web：80；</li>
<li>ftp：21；</li>
<li>smtp：25；</li>
<li>pop3：110；</li>
</ul>
<p>假设IP地址为：101.100.0.0，用端口来定位服务，用IP地址来定位计算机。</p>
<p>查看自己计算机侦听的端口：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3.png" alt="监听端口"></p>
<p>测试远程计算机打开的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 10.7.1.53 21</span><br></pre></td></tr></table></figure>

<p>端口代表服务，如果telnet命令返回提示端口失败，说明不能访问这个服务。</p>
<h3 id="更改端口增加服务器安全"><a href="#更改端口增加服务器安全" class="headerlink" title="更改端口增加服务器安全"></a>更改端口增加服务器安全</h3><p>黑客可能会使用端口扫描工具，扫描到用户计算机打开侦听的端口，以此判断用户计算机提供的哪种服务，以展开攻击。</p>
<p>可以通过更改服务对应的端口增加服务器的安全性能。</p>
<h3 id="Windows防火墙的作用"><a href="#Windows防火墙的作用" class="headerlink" title="Windows防火墙的作用"></a>Windows防火墙的作用</h3><ul>
<li>计算机的服务对应着一个端口。比如装上ftp服务，该计算机就在网卡上侦听21端口，是可见的，可用netstat -an查看侦听端口，安装Web服务，计算机就打开80端口侦听客户端的请求，若没有启用该服务，使用netstat -an命令查看时看不到80端口的。客户端要连接时，数据包要写上目标端口，比如目标端口为21，服务器就知道客户端访问的是ftp服务，也就是上面所说的用端口来区分服务。</li>
<li>如果把计算机的所有端口都关闭，那么该计算机相当于在互联网上隐身了，谁也访问不了它。但是它却可以访问其他计算机，因为Windows防火墙不拦截出去的流量，拦截进来的流量（计算机与外界通信完毕，端口关闭，是动态的）。例如：你ping别人不通，别人ping你通，说明别人设置了防火墙。</li>
<li>如果该计算机装了许多服务，但是只向外提供Web服务，只需要在网卡上打开80端口，关闭其余端口，发送过来的数据包只能访问80端口服务，若数据包目标端口为21端口，网卡会进行拦截，这样即使服务器本身运行了ftp服务，打开了21端口侦听，外面也访问不了，即使ftp服务有漏洞外面用户也攻击不了。也就是说在服务器上<strong>只开必要的端口</strong>，其实是增加了服务器的安全。</li>
<li>Win10则是设置防火墙，对对应的端口进行入站和出站的规则设置。如图进入防火墙设置，点击高级设置</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE.png" alt="防火墙设置"></p>
<p>点击出站或者入站规则，右击新建规则</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E9%98%B2%E7%81%AB%E5%A2%99%E7%82%B9%E5%87%BB%E5%87%BA%E7%AB%99%E6%88%96%E8%80%85%E5%85%A5%E7%AB%99%E8%A7%84%E5%88%99.png" alt="防火墙点击出站或者入站规则"></p>
<p>点击端口、下一步，进入防火墙设置出站入站端口，可以对一些特定的端口进行连接设置。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="防火墙设置出站入站端口"></p>
<p>总的来说，防火墙对于外部的主动访问时拒绝的，但是对于内部访问外部则是不理会。许多木马程序时依据此来进行入侵。</p>
<h3 id="网络安全的一些应用"><a href="#网络安全的一些应用" class="headerlink" title="网络安全的一些应用"></a>网络安全的一些应用</h3><ol>
<li>使用网络层安全设置，严格控制流量的出入。如果该计算机只提供Web服务，那么该计算机只允许目标地址或源地址为80端口的数据包通过，从而达到严格管控其他目标地址或源地址非80端口的数据包的出入。比如灰鸽子木马使用的是8000端口，即使用户主动下载并安装了木马程序，由于出去的相关数据包源地址为8000端口（非80端口），所以会被拦截，以此在网络层实现信息安全。</li>
<li>再如：一个放在公网公开的服务器A，只要能猜对该计算机的用户名和密码，任何网段的计算机都可以通过远程桌面控制该计算机。可以新增的网络层安全措施为：在服务器A上设置只允许计算机B的IP地址通过远程桌面控制服务器A，这样想要黑服务器A必须先获取计算机B的用户名和密码，再获取服务器A的用户名和密码才能成功黑入服务器A。由此通过网络层提高了服务器A的安全性能。</li>
</ol>
<h2 id="运输层协议-TCP-UDP（重点）"><a href="#运输层协议-TCP-UDP（重点）" class="headerlink" title="运输层协议 TCP/UDP（重点）"></a>运输层协议 TCP/UDP（重点）</h2><h4 id="一、用户数据报UDP"><a href="#一、用户数据报UDP" class="headerlink" title="一、用户数据报UDP"></a>一、用户数据报UDP</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</li>
<li>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</li>
</ul>
<h5 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h5><ol>
<li>无连接，发送数据不需要连接</li>
<li>尽最大努力交付，不保证可靠交付，不使用拥塞控制</li>
<li>面向报文，符合多媒体通信要求</li>
<li>支持一对一、多对多、多对一、和多对多的通信要求</li>
<li>首部开销小只有8字节（IP20 字节）</li>
</ol>
<p><strong>UDP是面向报文的</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E6%98%AF%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%E7%9A%84.png" alt="UDP是面向报文的"></p>
<p>发送方应用程序交下来的报文，无论多长，不拆分也不合并，保留报文边界，一次发送一个报文，应用程序必须选择合适大小的报文。</p>
<h5 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h5><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="UDP首部格式"></p>
<p>可以看出UDP对于首部格式是没有编号字段的，因为UDP协议只传输一个数据包，所以不需要编号。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F2.png" alt="UDP首部格式2"></p>
<p>用户数据报 UDP 有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。</p>
<p>计算校验和：临时把“<strong>伪首部</strong>”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
<p>例：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E8%AE%A1%E7%AE%97%E6%A0%A1%E9%AA%8C%E5%92%8C.png" alt="UDP计算校验和"></p>
<p>明确需要计算“校验和”来检验UDP报文的准确性即可</p>
<p><strong>UDP基于端口的分用</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/UDP%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%88%86%E7%94%A8.png" alt="UDP基于端口的分用"></p>
<hr>
<h4 id="二、传输控制协议TCP"><a href="#二、传输控制协议TCP" class="headerlink" title="二、传输控制协议TCP"></a>二、传输控制协议TCP</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>TCP是<strong>面向连接</strong>的协议，要先确保网络畅通才能传数据（如电话），每个TCP连接只有两个点，是<strong>点到点</strong>的通信，TCP提供<strong>可靠的交互</strong>、<strong>全双工通信</strong>，并且<strong>面向字节流。</strong></p>
<p><strong>TCP字节的概念</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%AD%97%E8%8A%82%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="TCP字节的概念"></p>
<p>注意：</p>
<ol>
<li><p>连接为虚连接</p>
</li>
<li><p>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</p>
</li>
<li><p>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
</li>
<li><p>每一条 TCP 连接有两个端点。</p>
</li>
<li><p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字</strong>(socket)或<strong>插口</strong>。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt="TCP套接字"></p>
</li>
<li><p>端口号拼接到(contatenated with) IP 地址即构成了套接字。即端点=IP地址+端口号。</p>
</li>
<li><p>每一条 <strong>TCP</strong> 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：</p>
</li>
</ol>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E6%8E%A5%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt="TCP连接等于两个套接字"></p>
<h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h2><ul>
<li><p>TCP首部包括20字节的固定首部以及可变字长的其他选项，所以TCP首部长度可变。20个字节又分为5部分，每部分4个字节32位，如图中的5行，每行表示32位。</p>
</li>
<li><p>在<strong>传输层</strong>，TCP报文段包括：TCP首部和TCP数据部分；在<strong>网络层</strong>，TCP报文段成为IP数据部分，加上IP首部组成IP数据报；在<strong>数据链路层</strong>，还要在IP数据报前面加上数据链路层的首部。</p>
</li>
<li><p><strong>源端口和目的端口</strong>字段——各占 2 字节（16位）。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</p>
</li>
<li><p><strong>序号</strong>字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。比如分组的第一个数据包由文件的1<del>4个字节数据组成，那么该数据包所添加的序号就是1，同理第二个数据包由文件的5</del>9个字节数据组成，那么该数据包所添加的序号就是5；</p>
</li>
<li><p><strong>确认号</strong>字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。比如接收端收到由文件1<del>4个字节数据+TCP首部组成的数据包后，删除首部提取1</del>4个字节数据，返回的确认号为5，即告诉发送端下一次应该发送文件的第5个字节及其之后字节组成的数据包过来</p>
</li>
<li><p><strong>数据偏移</strong>（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，也就是TCP首部的长度。“数据偏移”的单位是 32 位字（以 4 字节为计算单位），最大1111表示15x4=60个字节，即表示TCP首部最大长度为60个字节，因此“选项”部分最多40个字节。</p>
</li>
<li><p><strong>保留</strong>字段——占 6 位，保留为今后使用，但目前应置为 0。</p>
</li>
<li><p>这里的六位二进制位，分别表示不同含义：</p>
<ul>
<li><p><strong>紧急 URG</strong> —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 即URG=1的数据包不用排队直接优先传输。</p>
</li>
<li><p><strong>同步 SYN</strong> —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。即A想与B建立连接，发送过去的第一个数据包（第一次握手）中SYN=1；B返回的数据包（第二次握手）中SYN=1表示同意建立连接。</p>
</li>
<li><p><strong>确认 ACK</strong> —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</p>
<p>ACK是对已接受数据的确认，当A与B还在请求连接阶段，A向B发送的第一个数据包（第一次握手）中ACK=0，无效，所以数据包中不显示，表示还没从B中接收到数据；序号Seq也为0，表示A还未向B发送数据；SYN=1，表示正在建立连接。</p>
<p>同理，B向A返回一个数据包（第二次握手）中，确认号ACK=1，表示B收到了A序号为0的数据包；序号Seq=0，也表示B还未向A发送数据；SYN=1表示同意建立连接。</p>
<p>A再向B发送一个数据包（第三次握手）中，确认号ACK=1，表示A收到了B发出的数据包；序号Seq=1，表示A已向B发送了1个数据包（即第一次握手）；SYN=0，表示已建立连接。</p>
</li>
</ul>
</li>
<li><p>选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</p>
</li>
<li><p>紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  </p>
</li>
<li><p>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
</li>
<li><p>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E7%AA%97%E5%8F%A3%E5%AD%97%E6%AE%B5%E5%A4%A7%E5%B0%8F.png" alt="TCP首部格式"></p>
<h3 id="抓包分析TCP首部"><a href="#抓包分析TCP首部" class="headerlink" title="抓包分析TCP首部"></a>抓包分析TCP首部</h3><p>我打开惠州学院的官网 <a href="https://www.hzu.edu.cn/">https://www.hzu.edu.cn/</a></p>
<p>刚开始，先建立连接，seq（序号=0），同步 SYN = 1 表示这是一个连接请求或连接接受报文。</p>
<p>这边的主机请求连接，目的主机给予回应，主机在确认，如图，为三次握手的过程，期间，主机和目的服务器协商TCP缓存、请求连接的事情</p>
<p>服务端同意连接，确认号ACK=1，Win是TCP连接缓存，相互告知自己TCP连接的缓存大小</p>
<p>主机发送确认号ACK=1，确认连接，序号Seq=1。然后就正式开始通信。可以看出请求通信是post请求。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E6%8A%93%E5%8C%85%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP抓包首部格式"></p>
<p>可以看到计算机发出的第一个数据包（第一次握手）中，SYN=1，Seq=1，ACK=0无效，所以在蓝色框内只能看到序号Seq，看不到确认号ACK；</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8A%93%E5%8C%85-TCP%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="抓包-TCP第一次握手"></p>
<p>而在第三次握手中，请求建立连接的过程结束，SYN=0，ACK都为1</p>
<p>所以，抓包时看到大量的SYN数据包，说明计算机在大量建立会话。另外在建立连接（三次握手）时，SYN与ACK的值与正常通讯时不一样。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE%E5%87%BA%E7%AB%99%E5%85%A5%E7%AB%99%E7%AB%AF%E5%8F%A3.png" alt="抓包-TCP第三次握手"></p>
<p><strong>有一种攻击就是针对建立连接时SYN同步的机制</strong></p>
<p>比如地址为102的计算机B想要与地址为101的计算机A建立连接，B向A发送请求连接数据包，并设置数据包中的源地址为不存在，A收到之后向该不存在的地址发出同意连接的数据包，发送完之后需要等待回复。于是B继续上述操作，以此类推A不断发出同意连接数据包并不断等待，由此大量耗费系统资源。</p>
<p>下图为使用SYN同步攻击软件攻击XP系统过程中，捕获的数据包：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/SYN%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%94%BB%E5%87%BB.png" alt="SYN同步机制攻击"></p>
<p>红色框中的地址是攻击软件瞎编的不存在的地址，蓝色框中显示建立的会话全是请求连接的TCP报文。</p>
<p>可以看到在Land攻击时捕获的数据包，都是请求同步SYN数据包且源地址和目标地址都为攻击对象地址 192.168.80.66 。</p>
<ul>
<li><p><strong>推送 PSH</strong> (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p>
</li>
<li><p><strong>复位 RST</strong> (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p>
</li>
<li><p><strong>终止 FIN</strong> (FINis) —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</p>
</li>
<li><p><strong>窗口</strong>字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B9%B3%E5%9D%87%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4.png" alt="image-20200811135332709"></p>
<p>TCP全部格式</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%85%A8%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg" alt="image-20200811134720414"></p>
<h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><p>使用确认和重传机制，我们在不可靠的网络上建立可靠传输的机制。这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</p>
<h4 id="工作原理—停止等待"><a href="#工作原理—停止等待" class="headerlink" title="工作原理—停止等待"></a>工作原理—停止等待</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="TCP工作原理-停止等待协议"></p>
<ul>
<li>在发送完分组之后，需要保留已经发送的分组副本</li>
<li>对分组和确认分组都必须进行编号</li>
<li>超时重传的时间比数据在分组传输的平均往返时间长一些</li>
</ul>
<p>![image-20200811091209918](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/运输层/TCP工作原理-确认丢失和确认迟到</a> .png)</p>
<h4 id="缺点：信道利用率太低"><a href="#缺点：信道利用率太低" class="headerlink" title="缺点：信道利用率太低"></a>缺点：信道利用率太低</h4><p>停止等待协议的优点是简单，但缺点是信道利用率太低。 </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E5%A4%AA%E4%BD%8E.png" alt="image-20200811091914058"></p>
<p>TD表示发送分组数据包用的时间，RTT是数据包传输往返的时间，TA是接受确认用的时间。</p>
<p>信道的利用率 <em>U</em> ：<img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="信道利用率"></p>
<h4 id="解决信道利用率太低—-使用连续传输机制（流水线）"><a href="#解决信道利用率太低—-使用连续传输机制（流水线）" class="headerlink" title="解决信道利用率太低—-使用连续传输机制（流水线）"></a>解决信道利用率太低—-使用连续传输机制（流水线）</h4><p><strong>连续ARQ协议</strong></p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E7%BB%AD%E4%BC%A0%E8%BE%93.png" alt="image-20200811092447090"></p>
<p>ACK表示确认报文。</p>
<p>现在大多采用这种方式，那如何保证可靠传输呢？采用连续ARQ协议。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8A%93%E5%8C%85-TCP%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="连续ARQ协议"></p>
<ul>
<li>假设发送窗口是5，也就是发送方一次性能发5个数据包。当发送方收到数据包1的接收确认后表示接收方接收了数据包1，之后发送窗口向前滑动一个数据包，在发送窗口中删除数据包1的缓存。</li>
<li>即如果发送了5个数据包后没有收到确认信息就会停止继续发送数据包。</li>
<li>滑动窗口方式仍需每个数据包对应一个确认，效率不高，接收端可采用累积确认。</li>
</ul>
<p><strong>累积确认</strong></p>
<ul>
<li>接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：<strong>到这个分组为止的所有分组都已正确收到了</strong>。</li>
<li>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的有分组的信息。</li>
</ul>
<p><strong>回退</strong></p>
<ul>
<li>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</li>
<li>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 <em>N</em> 个分组。</li>
<li>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</li>
</ul>
<h4 id="TCP-可靠通信的具体实现（这部分并不是很详细，可参照书上的内容来学）"><a href="#TCP-可靠通信的具体实现（这部分并不是很详细，可参照书上的内容来学）" class="headerlink" title="TCP 可靠通信的具体实现（这部分并不是很详细，可参照书上的内容来学）"></a>TCP 可靠通信的具体实现（这部分并不是很详细，可参照书上的内容来学）</h4><ul>
<li>TCP 连接的每一端都必须设有两个窗口——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。</li>
<li>TCP 的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP 所有的确认都是<strong>基于序号</strong>而不是基于报文段。</li>
<li>TCP 两端的四个窗口经常处于<strong>动态变化</strong>之中。</li>
<li>TCP连接的往返时间 RTT 也<strong>不是固定不变</strong>的。需要使用特定的算法估算较为合理的重传时间。</li>
</ul>
<p><strong>超时重传时间的选择</strong></p>
<p>加权平均往返时间RTT</p>
<p>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</p>
<p>由于网络的通畅情况随时间变化，所以数据往返时间RTT是变化的。采用以下公式计算新的平均往返时间。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png" alt="image-20200811151416601"></p>
<ul>
<li>式中RTTs表示<strong>加权平均往返时间</strong> （又称为<strong>平滑的往返时间</strong>），即传输数据时多次往返时间RTT的平均值。</li>
<li>式中，0 &lt; a &lt; 1。若 a 接近于零，表示新RTTs值较依赖旧RTT值，说明 RTT 值更新较慢，网速稳定；若选择 a 接近于 1，表示新RTTs值较依赖新RTT值，说明 RTT 值更新较快，网速不稳定。</li>
<li>RFC 2988 推荐的 a 值为 1/8，即 0.125。</li>
</ul>
<p>超时重传时间 RTO (RetransmissionTime-Out)</p>
<ul>
<li><p>RTO 应略大于上面得出的加权平均往返时间 RTTs。</p>
</li>
<li><p>RFC 2988 建议使用下式计算 RTO：</p>
<p><strong>RTO = RTTs + 4 x RTTd</strong></p>
</li>
<li><p>RTTd 是 <strong>RTT 的偏差的加权平均值</strong>。</p>
</li>
<li><p>RFC 2988 建议这样计算 RTTd。第一次测量时，RTTd 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTd：</p>
</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4.png" alt="选择重传时间"></p>
<p>β 是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p>
<h3 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h3><p><strong>利用滑动窗口实现流量控制</strong></p>
<ul>
<li>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li>
<li><strong>流量控制</strong>(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
<li><strong>流量控制举例：</strong></li>
</ul>
<p>A 向 B 发送数据。在连接建立时，B 告诉 A：“我的接收窗口 rwnd = 400（字节）”。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="流量控制"></p>
<h3 id="TCP如何实避免网络拥塞"><a href="#TCP如何实避免网络拥塞" class="headerlink" title="TCP如何实避免网络拥塞"></a>TCP如何实避免网络拥塞</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生<strong>拥塞</strong>(congestion)。</p>
</li>
<li><p>出现资源拥塞的条件：</p>
<p>对资源需求的总和 &gt; 可用资源</p>
</li>
<li><p><strong>拥塞控制</strong>是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
</li>
<li><p><strong>流量控制</strong>往往指在给定的发送端和接收端之间的点对点通信量的控制，它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
</li>
</ul>
<h4 id="拥塞控制所起的作用"><a href="#拥塞控制所起的作用" class="headerlink" title="拥塞控制所起的作用"></a>拥塞控制所起的作用</h4><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.7.TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/1.png"><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image-20200129215454048"></a></p>
<ul>
<li>吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。比如某网络的带宽为100M，那么该网络的最大吞吐量为100M/s 。</li>
<li>可以看到，理想的拥塞控制为：随着传输数据量（负载）的增加，数据传输速度（吞吐量）越来越快，当吞吐量达到网络的最大带宽时，继续增大传输数据量，传输的速度（吞吐量）也不会再增加，所以这样并不会造成网络拥塞导致传输速度（吞吐量）下降。例如，路由器间的带宽为100M，当传输150M数据时，路由器把处理不过来的50M数据扔掉，继续保持100M的传输速度。</li>
<li>当无拥塞控制时，假设两路由器间的网络带宽为100M，当传输的数据小于100M时，随着数据量（负载）的增加丢包情况越来越明显，此时成为轻度拥塞；当传输的数据量（负载）大于100M时，大量的数据包使路由器无法及时处理，错误情况越来越多，最后路由器死机，无法传输数据导致<strong>死锁</strong>，此时吞吐量为0。</li>
<li>在实际的拥塞控制中，网络设备随着传输的数据量（提供的负载）越来越大，传输的速度（吞吐量）越快，丢包率也越来越大，依靠拥塞控制机制会适当降低数据传输的速度（吞吐量），以减少拥塞。</li>
</ul>
<hr>
<h4 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h4><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>发送方维持一个叫做<strong>拥塞窗口 cwnd</strong> (congestion window)的状态变量。</p>
<p>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</p>
</li>
<li><p>发送方控制拥塞窗口的原则是：</p>
<ul>
<li>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。</li>
<li>只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</li>
</ul>
</li>
</ul>
<h4 id="慢开始和拥塞避免（1988年提出）"><a href="#慢开始和拥塞避免（1988年提出）" class="headerlink" title="慢开始和拥塞避免（1988年提出）"></a>慢开始和拥塞避免（1988年提出）</h4><ul>
<li>慢开始图例：</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%9B%BE%E4%BE%8B.png" alt="image-20200129222757313"></p>
<p>发送窗口一般等于拥塞窗口。</p>
<p>第一轮：刚开始cwnd=1，发送窗口也为1，发送方先发送一个报文M1测试连接通畅程度，当收到对M1报文的确认之后，cwnd+1，即发送窗口变为2，可以同时发送两个报文M2~M3；</p>
<p>第二轮：发送方发送两个报文M2<del>M3，发送方收到了M2报文的确 认后使cwnd+1变为3，收到了M3报文确认后cwnd+1变为4，即每收到一个对新报文的确认（重传的不算在内）就使cwnd+1。由此cwnd=4，即发送窗口也为4，可以同时发送四个报文M4</del>M7 。</p>
<p>以此类推第三轮之后cwnd=8。传输速度由慢开始，每轮翻倍，最后传输速度越来越快。</p>
<blockquote>
<p><strong>传输轮次 (transmission round)</strong></p>
</blockquote>
<ul>
<li>使用慢开始算法后，每经过一个<strong>传输轮次</strong>，拥塞窗口 cwnd 就加倍。</li>
<li>一个传输轮次所经历的时间其实就是往返时间 RTT。</li>
</ul>
<blockquote>
<p><strong>慢开始门限状态变量ssthresh</strong></p>
</blockquote>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢开始算法（cwnd每轮加倍）。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li><strong>拥塞避免算法</strong>的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
<blockquote>
<p><strong>当网络出现拥塞时</strong></p>
</blockquote>
<ul>
<li>无论处于慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认数据包），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方发送窗口值（多数情况下等于cwnd）的一半（但不能小于2）。</li>
<li>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</li>
<li>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</li>
</ul>
<blockquote>
<p>**慢开始和拥塞避免算法的实现举例 **</p>
</blockquote>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%BE%E4%BE%8B.png" alt="image-20200129225121695"></p>
<ul>
<li>可以看到，开始时采用慢开始算法，每经历一轮cwnd翻倍，传输的数据包翻倍，到第4轮时cwnd=16，意味着可以同时发送16个数据包，到达了设定的慢开始门限值ssthresh，随后采用拥塞避免算法。</li>
<li>采用拥塞避免算法期间，每经历一轮cwnd+1。当cwnd=24时，发送方不能准时收到确认数据包（即丢包），判断出现网络拥塞，于是把慢开始门限值ssthresh重新设为当前cwnd值（24）的一半，即12，并把cwnd重置为1 ，再次进入慢开始阶段。</li>
<li>可以看到：采用慢开始算法，cwnd按指数规律增长；采用拥塞避免算法，cwnd按线性规律增长。</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<ul>
<li>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li>
<li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
<h4 id="快重传和快恢复（1990年提出）"><a href="#快重传和快恢复（1990年提出）" class="headerlink" title="快重传和快恢复（1990年提出）"></a>快重传和快恢复（1990年提出）</h4><blockquote>
<p><strong>快重传举例</strong></p>
</blockquote>
<p>当不出现丢包情况时，接收方是每接收多个数据包才给发送方一个确认。例如每收到5个连续的数据包，发送以此确认信息。</p>
<p>当出现丢包情况时：如发送数据包M1~M5，丢失了M3，如按上述规律，接收方要等到接收完M5后才能向发送方反馈丢失M4的信息。实际上，接收方接连收到不连续的数据包M2、M4，就已经发现丢失了M3，可采用以下的快重传方式。</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.7.TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/4.png"><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B.png" alt="image-20200129231323069"></a></p>
<p>快重传举例</p>
<ul>
<li>快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方尽早知道有报文段没有到达接收方。</li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。</li>
</ul>
<blockquote>
<p>**快恢复算法 **</p>
</blockquote>
<ul>
<li><p>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1 。而是将cwnd当前值减半作为新的慢开始门限 ssthresh 值，并让cwnd的值等于这个新的慢开始门限ssthresh值。</p>
<p>也有人认为，由于接收了三个重复的ACK，按照上述规律没收到一个ACK，cwnd+1，所以cwnd=新ssthresh+3，这里采用前一种观点。</p>
<p>随后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 这便是快恢复算法。</p>
</li>
<li><p>下为图例：</p>
</li>
</ul>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.7.TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/5.png">![image-20200129234028843](https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/运输层/快恢复算法 .png)</a></p>
<p>快恢复算法 </p>
<p>可以看到，当发送端收到3个重复的确认后，执行快重传算法，cwnd</p>
<p>快恢复是配套着快重传使用的，快恢复是相对于慢开始算法而言的。使用快恢复算法时，cwnd从较大值开始，通过拥塞避免算法逐渐线性增大，经过较短时间便能恢复比较快的传输速度；使用慢开始算法时，cwnd从1开始，需要较常时间才能达到较快的速度。</p>
<h4 id="2-4-发送窗口的上限值"><a href="#2-4-发送窗口的上限值" class="headerlink" title="2.4.发送窗口的上限值"></a>2.4.发送窗口的上限值</h4><p>前面讲过发送方的发送窗口是由接收方的接收窗口决定的。例如接收方的接收窗口为100字节，那么发送方的发送窗口就为100字节。实际上：</p>
<ul>
<li>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%8A%E9%99%90%E5%80%BC.png" alt="image-20200129234256008"></p>
<ul>
<li>即刚开始发送数据时，由于网络情况未知cwnd的值由1开始按指数规律增大，而接收窗口的是固定的假设为100字节。此时 cwnd &lt; rwnd ，网络的拥塞窗口cwnd限制了发送窗口的最大值。</li>
<li>之后cwnd的值越来越大，最后被限制在接收方的接收窗口大小100字节上。此时此时 cwnd &gt; rwnd ，接收方的接收能力限制了发送窗口的最大值。</li>
</ul>
<h2 id="TCP传输连接管理-三次握手与四次挥手"><a href="#TCP传输连接管理-三次握手与四次挥手" class="headerlink" title="TCP传输连接管理:三次握手与四次挥手"></a>TCP传输连接管理:三次握手与四次挥手</h2><h3 id="一、传输连接的三个阶段"><a href="#一、传输连接的三个阶段" class="headerlink" title="一、传输连接的三个阶段"></a>一、传输连接的三个阶段</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1.概述"></a>1.1.概述</h4><ul>
<li>传输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。</li>
<li>连接建立过程中要解决以下三个问题：<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</li>
<li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。</li>
</ul>
</li>
<li>TCP 连接的建立都是采用<strong>客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>客户</strong>(client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>服务器</strong>(server)。</li>
</ul>
<hr>
<h3 id="二、TCP-的连接建立"><a href="#二、TCP-的连接建立" class="headerlink" title="二、TCP 的连接建立"></a>二、TCP 的连接建立</h3><h4 id="2-1-用三次握手建立-TCP-连接"><a href="#2-1-用三次握手建立-TCP-连接" class="headerlink" title="2.1.用三次握手建立 TCP 连接"></a>2.1.用三次握手建立 TCP 连接</h4><p>当客户端A想要访问服务器B上的服务，需要与B建立连接了，就要经历如下三次握手过程：</p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.8.TCP%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/1.png"><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt="image-20200130170026670"></a></p>
<ul>
<li><p>第一次握手：A先向B发送一个同步数据包（报文）。</p>
<p>在报文的TCP首部中：标志位：<strong>同步SYN</strong>为1，表示这是一个请求建立连接的数据包；确认标记位ACK为0，说明该数据包的确认号无效，所以该标志位可省略；序号<code>Seq=x</code>，<code>x</code>为所传送数据的第一个字节的序号。</p>
</li>
<li><p>第二次握手：B收到A发送的第一个数据包后，根据标志位SYN=1与ACK=1，判断出为主动建立连接的数据包。若B同意连接，则B发送一个数据包进行回应。</p>
<p>在数据包的TCP首部中：标志位：<strong>同步SYN</strong>=1；标志位：<strong>确认ACK</strong>=1；序号seq=y，y的值由B指定表示B发送数据时的第一个数据字节的序号；确认号ack=x+1，表示已经收到A发送的x个字节数据，并告诉A下次应从数据的第x+1个字节开始发送。</p>
</li>
</ul>
<blockquote>
<p>注意区分ACK和ack：在TCP首部中前者为标志位<strong>确认 ACK</strong> ——占 1 字节，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。；后者为<strong>确认号</strong>字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
</blockquote>
<ul>
<li><p>第三次握手：A收到B的确认之后，再给A发送一个数据包。</p>
<p>在数据包的TCP首部中：已经没有有效的标志位：<strong>同步SYN</strong>了（即SYN=0），表示双方已同意建立连接；标志位<strong>确认ACK</strong>=1，表示收到B的确认数据包；序号seq=x+1，表示发出的数据包就是数据的第x+1个字节；确认号ack=y+1，表示收到了B发送y字节数据，并告诉B下次应从数据的第y+1个字节开始发送。</p>
</li>
</ul>
<h4 id="2-2-为何有第三次握手？"><a href="#2-2-为何有第三次握手？" class="headerlink" title="2.2.为何有第三次握手？"></a>2.2.为何有第三次握手？</h4><p>客户端向服务器发出建立连接的请求以及服务器向客户端确认这个请求，这两个数据包（前两次握手）足以证明客户端与服务器之间的网络是畅通的，并且协商数据通信所需要的参数。比如协商接收窗口大小，所支持的数据包最大字节数等。</p>
<p>如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包，于是发出第二个建立连接的请求数据包，这次网路通畅，数据包很快到达B，B的确认数据包也很快就到达A。于是A与B开始传输数据，过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。</p>
<p>第三次握手（第三个数据包）作用在于，告诉B计算机，B第二次握手发给A的确认数据包A收到了，是有效的。<strong>避免B计算机等待造成资源浪费。</strong>随后A与B可进行下一步的通信。</p>
<h4 id="2-3-三次握手建立TCP连接过程的各状态"><a href="#2-3-三次握手建立TCP连接过程的各状态" class="headerlink" title="2.3.三次握手建立TCP连接过程的各状态"></a>2.3.三次握手建立TCP连接过程的各状态</h4><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.8.TCP%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/2.png"><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E7%9A%84%E5%90%84%E7%8A%B6%E6%80%81.png" alt="image-20200130165906308"></a></p>
<ul>
<li>A发出请求建立连接的数据包之后进入<strong>SYN-SENT</strong>状态，表示发送了请求建立连接的同步数据包。</li>
<li>B收到A发出的请求建立连接的数据包之后，结束<strong>LISTEN</strong>状态，进入<strong>SYN-RCVD</strong>状态并向A发出确认数据包。</li>
<li>A收到确认数据包之后，结束SYN-SENT状态，进入<strong>ESTABLISHED</strong>状态，并向B发送确认数据包。</li>
<li>B收到A的确认数据包之后，结束SYN-RCVD状态，进入<strong>ESTABLISHED</strong>状态。</li>
</ul>
<p>A与B都进入<strong>ESTABLISHED</strong>状态之后，开始传输数据，由此完成三次握手。</p>
<p><strong>查看这些状态</strong></p>
<p>可通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -n</span><br></pre></td></tr></table></figure>

<p>在命令行窗口查看计算机建立的会话的装态。由于建立TCP连接的三次握手过程非常快，我们可以通过访问一个不存在的网址来查看：比如<a href="http://192.168.80.200/">http://192.168.80.200</a></p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.8.TCP%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/3.png"><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%9F%A5%E7%9C%8BSYN-RCVD%E7%8A%B6%E6%80%81.png" alt="image-20200130171444612"></a></p>
<p>可以看到建立TCP连接时，本计算机访问了该地址的80端口（对应Web服务），并且TCP连接状态为SYN-SENT。此外本计算机还有其他已经建立的TCP连接，状态为ESTABLISHED。</p>
<p>如何查看<strong>SYN-RCVD</strong>状态呢？可通过模拟SYN攻击（大量模拟虚构地址与本计算机建立会话）即可查看该状态：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E4%BD%BF%E7%94%A8%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BETCP%E8%BF%9E%E6%8E%A5.png" alt="image-20200130172613268"></p>
<p>框内为SYN攻击虚构的地址，可看到建立TCP连接的会话都处于SYN-RECEIVED状态。</p>
<p>那么平常如果看到计算机有大量处于SYN-RECEIVED状态的会话说明有人利用SYN攻击器在攻击你的电脑。</p>
<hr>
<h3 id="三、TCP的连接释放"><a href="#三、TCP的连接释放" class="headerlink" title="三、TCP的连接释放"></a>三、TCP的连接释放</h3><h4 id="3-1-使用四次挥手释放TCP连接"><a href="#3-1-使用四次挥手释放TCP连接" class="headerlink" title="3.1.使用四次挥手释放TCP连接"></a>3.1.使用四次挥手释放TCP连接</h4><p>数据传输结束后，通信的双方都可主动释放连接。下为A主动释放TCP连接。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%9F%A5%E7%9C%8B%E5%BB%BA%E7%AB%8B%E4%BC%9A%E8%AF%9D%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="image-20200130183903175"></p>
<ul>
<li><p>第一次挥手：首先A向B发送连接释放请求报文（数据包），并停止发送数据。</p>
<p>在连接释放报文（数据包）的TCP首部中：标志位：<strong>终止FIN</strong>=1，意味着A要主动释放A—&gt;B的TCP连接；序号位seq为u，u值由A指定。随后等待B的确认。</p>
</li>
<li><p>第二次挥手：B收到连接释放报文之后，给A发送确认报文，此时TCP服务器进程通知高层应用进程，这样从A到B这个方向上的连接就释放了，TCP连接处于半关闭状态。此时A没有数据要发给B了，但是B还有数据要发送给A，A仍可以接收。</p>
<p>在确认报文的TCP首部中：标志位：<strong>确认ACK</strong>=1，表示收到了A发送的数据包，同意A释放连接；序号位seq=v，v值由B指定；确认号ack=u+1，表示已经收到A发送的u个字节数据，并告诉A下次应从数据的第u+1个字节开始发送，下面同理；此时B还可以向A传输数据。</p>
</li>
<li><p>第三次握手：若B已经没有向A发送的数据了，其应用进程就通知TCP释放连接，并向A发送确认报文。</p>
<p>在确认报文的TCP首部中：标志位：<strong>确认ACK</strong>=1，表示B已经把需要发给A的数据发完了；标志位：<strong>终止FIN</strong>=1，意味着B要释放B—&gt;A的TCP连接；序号seq=w，w值由B指定；确认号ack=u+1；此后B不再向A发送数据，但能接收数据。</p>
</li>
<li><p>第四次挥手：A收到B的连接释放报文段后，向B发出确认报文。</p>
<p>在确认报文的TCP首部中：标志位：<strong>确认ACK</strong>=1，表示收到B的确认报文，并同意B释放连接；序号seq=u+1；确认号ack=w+1；</p>
</li>
</ul>
<p>由此通过四次挥手释放了TCP连接。</p>
<p>查看会话连接状态</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%BF%90%E8%BE%93%E5%B1%82/%E6%9F%A5%E7%9C%8B%E4%BC%9A%E8%AF%9D%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81.png" alt="image-20200811165349507"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-5-应用层</title>
    <url>/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="6-1-域名系统-DNS"><a href="#6-1-域名系统-DNS" class="headerlink" title="6.1 域名系统 DNS"></a>6.1 域名系统 DNS</h2><p>域名的作用：负责解析域名，将域名解析成IP地址</p>
<ul>
<li><p>许多应用层软件经常直接使用域名系统 DNS (Domain Name System)，但计算机的用户只是间接而不是直接使用域名系统。 </p>
</li>
<li><p>因特网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。</p>
</li>
<li><p>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。  </p>
</li>
</ul>
<p>域名解析测试：</p>
<p>nslookup <a href="http://www.91xueit.com/">www.91xueit.com</a></p>
<a id="more"></a>



<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%B5%8B%E8%AF%95.png" alt="image-20200811202615059"></p>
<h3 id="6-1-2-因特网的域名结构"><a href="#6-1-2-因特网的域名结构" class="headerlink" title="6.1.2 因特网的域名结构"></a>6.1.2 因特网的域名结构</h3><ul>
<li>因特网采用了层次树状结构的命名方法。</li>
<li>任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</li>
<li>域名的结构由标号序列组成，各标号之间用点隔开：</li>
</ul>
<p>​       … <strong>.</strong> 三级域名 <strong>.</strong> 二级域名 <strong>.</strong> 顶级域名</p>
<ul>
<li>各标号分别代表不同级别的域名。 </li>
</ul>
<p>如<a href="http://www.baidu.com/">www.baidu.com</a></p>
<p><strong>顶级域名 TLD (Top Level Domain)</strong></p>
<p>(1) 国家顶级域名 nTLD：如: .cn 表示中国，.us 表示美国，.uk 表示英国，等等。</p>
<p>(2) 通用顶级域名 gTLD：最早的顶级域名是：</p>
<p>  .com （公司和企业）</p>
<p>  .net （网络服务机构）</p>
<p>  .org （非赢利性组织）</p>
<p>  .edu （美国专用的教育机构（）</p>
<p>  .gov （美国专用的政府部门）</p>
<p>  .mil  （美国专用的军事部门）</p>
<p>  .int   （国际组织）</p>
<p>因特网的域名空间 </p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="image-20200811200734951"></p>
<h3 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h3><p>域名的解析过程</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%AE%89%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="域名的解析过程"></p>
<p>安装自己的域名服务器（需求）</p>
<ol>
<li>解析内网自己的域名</li>
<li>降低到Internet的域名解析流量</li>
<li>域环境</li>
</ol>
<p>在打开的控制面板窗口，选择“网络和Internet项”图标，在打开的窗口中点击“查看网络状态和任务”快捷链接，点击“更改适配器设置”快捷链接，在打开的网络连接窗口，就可以看到电脑中本地连接的列表了，然后右键点击正在使用的本地链接，在弹出菜单中选择“属性”菜单项，在打开的本地连接属性窗口，找到“Internet协议4（TCP/IPV4）”项，双击该项，或是选择后点击“属性”按钮，在打开的属性设置窗口，选择“使用下面的IP地址”项，在下面输入你的IP地址、子网掩码及网关就可以了</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%9F%E5%90%8D%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="image-20200811204456933"></p>
<h3 id="DHCP协议-动态主机配置"><a href="#DHCP协议-动态主机配置" class="headerlink" title="DHCP协议- 动态主机配置"></a>DHCP协议- 动态主机配置</h3><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/FTP%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F1.png" alt="DHCP协议- 动态主机配置"></p>
<p>在dos命令行下，使用  （在本网段自动分配地址）</p>
<blockquote>
<p>ipconfig /release   释放Ip租约</p>
<p>ipconfig /renew    重新请求地址</p>
</blockquote>
<p>跨网段自动分配地址使用到了DHCP中继代理，</p>
<ul>
<li>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP <strong>中继代理</strong>，它配置了 DHCP 服务器的 IP 地址信息。</li>
<li>当 DHCP 中继代理收到主机发送的发现报文后，就以<strong>单播方式</strong>向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</li>
</ul>
<p><strong>跨网段地址分配</strong></p>
<p>![跨网段地址分配](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/DHCP%E5%8D%8F%E8%AE%AE-">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/6-应用层/DHCP协议-</a> 动态主机配置.png)</p>
<p>如图三个网段：192.168.1.0 、192.168.2.0 、192.168.3.0 只有一台DHCP服务器。可以更改如下配置使一台DHCP服务器给三个网段地计算机分配地址。</p>
<ul>
<li>在DHCP服务器中创建三个网段：192.168.1 、 192.168.2 、 192.168.3 的作用域（地址池）。</li>
<li>在路由器的 6/1 和 6/0 端口分别配置如下命令：</li>
</ul>
<blockquote>
<p>ip helper-address 192.168.1.9</p>
</blockquote>
<p>这条命令便可实现跨网段的地址分配。注意要在路由器对应网段的端口处配置。192.168.1.9为DHCP服务器的地址。</p>
<p>配置了该命令的路由器也称为<strong>DHCP中继代理</strong>。</p>
<ul>
<li><p><strong>过程</strong><br>192.168.1网段的计算机通过广播的形式向DHCP服务器请求地址；通过配置路由器中连接其他网段的端口上述命令，这些网段中的计算机可通过单播的形式通过路由器转发向DHCP服务器请求地址。</p>
<p>DHCP服务器通过区分收到的请求地址信息是单播还是广播来判定是本网段计算机请求地址还是其他网段计算机请求地址。</p>
<p>最后DHCP服务器从三个网段的地址池中选出地址分别分配给三个网段。</p>
</li>
</ul>
<blockquote>
<p><strong>DHCP服务器必须是静态地址</strong></p>
</blockquote>
<p>因为DHCP服务器是根据该静态地址为本网段的计算机分配地址的。</p>
<p><strong>补充</strong></p>
<p>可以发现计算机向本网段的DHCP服务器请求地址时采用的是广播的方式，相当于知道MAC地址请求IP地址。这与之前讲的ARP协议通过IP地址请求MAC地址正好相反，可以说是逆向ARP协议，即RARP（反向地址转换）协议。</p>
<h2 id="6-2-文件传送协议（File-Transfer-Porofer-Protocol）"><a href="#6-2-文件传送协议（File-Transfer-Porofer-Protocol）" class="headerlink" title="6.2 文件传送协议（File Transfer Porofer Protocol）"></a>6.2 文件传送协议（File Transfer Porofer Protocol）</h2><h3 id="6-2-1-FTP-概述"><a href="#6-2-1-FTP-概述" class="headerlink" title="6.2.1 FTP 概述"></a>6.2.1 FTP 概述</h3><ul>
<li><strong>文件传送协议</strong> FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。</li>
<li>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</li>
</ul>
<h3 id="6-2-2-FTP-的基本工作原理"><a href="#6-2-2-FTP-的基本工作原理" class="headerlink" title="6.2.2 FTP 的基本工作原理"></a>6.2.2 FTP 的基本工作原理</h3><p><strong>特点</strong></p>
<ul>
<li>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 <strong>TCP</strong> 可靠的运输服务。</li>
<li>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li>
<li>FTP 使用<strong>客户服务器方式</strong>。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求，主进程与从属进程的处理是并发地进行。</li>
</ul>
<p><strong>FTP传输模式</strong></p>
<ul>
<li>文本模式：ASCII模式，以文本序列传输数据；</li>
<li>二进制模式：Binary模式，以二进制序列传输数据；</li>
</ul>
<h4 id="FTP-使用的两个-TCP-连接"><a href="#FTP-使用的两个-TCP-连接" class="headerlink" title="FTP 使用的两个 TCP 连接"></a>FTP 使用的两个 TCP 连接</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E8%B7%A8%E7%BD%91%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png" alt="image-20200201151257498"></p>
<ul>
<li>第一个TCP连接为<strong>控制连接</strong>，客户端标准端口为21，用于发送FTP命令信息；</li>
<li>第二个TCP连接为<strong>数据连接</strong>， 服务器端标准端口为20，用于上传、下载数据。</li>
</ul>
<p>数据连接的建立类型：</p>
<ul>
<li><strong>主动模式：</strong>服务器端从<strong>20端口</strong>主动向客户端发起连接；</li>
<li><strong>被动模式：</strong>服务器端打开指定范围内的某个端口被动等待客户端发起连接。（此时服务器端不使用标准端口20）</li>
<li>客户进程使用**熟知端口(21)**与服务器进程建立控制连接；使用另一个端口建立数据连接。</li>
<li>服务器进程使用**熟知端口(20)**与客户进程所提供的端口建立数据传送连接；使用另一个端口与客户端进程建立控制连接。</li>
<li>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱；在传输文件结束时客户端还可以利用控制连接发送请求终止传输信息。</li>
</ul>
<h4 id="FTP主动模式与被动模式"><a href="#FTP主动模式与被动模式" class="headerlink" title="FTP主动模式与被动模式"></a>FTP主动模式与被动模式</h4><p>主动模式下防护墙需要打开21和20端口。ftp客户端告诉ftp服务器使用什么端口监听，ftp服务器和客户端的这个端口建立什么连接</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/FTP%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F2.png" alt="image-20200201154412140"></p>
<p>被动模式下ftp服务器只打开一个端口，等待ftp客户端的连接，ftp服务器，如果有防火墙，需要在防火墙开21和20的端口，使用主动模式进行数据连接。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/FTP%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AATCP%E8%BF%9E%E6%8E%A5.png" alt="image-20200201154828739"></p>
<h3 id="6-2-3-简单文件传送协议-TFTP"><a href="#6-2-3-简单文件传送协议-TFTP" class="headerlink" title="6.2.3 简单文件传送协议 TFTP"></a>6.2.3 简单文件传送协议 TFTP</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>  (1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</p>
<p>  (2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。</p>
<p>  (3) 支持 ASCII 码或二进制传送。</p>
<p>  (4) 可对文件进行读或写。</p>
<p>  (5) 使用很简单的首部。 </p>
<ul>
<li><p>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</p>
</li>
<li><p>发完数据后在规定时间内收不到确认就要重发数据 PDU。</p>
</li>
<li><p>发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。 </p>
</li>
<li><p>在一开始工作时。TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为 69。</p>
</li>
<li><p>TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。</p>
</li>
<li><p>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。</p>
</li>
<li><p>若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满512字节，这正好可作为文件结束的标志。</p>
</li>
</ul>
<h2 id="6-3-远程终端协议-TELNET"><a href="#6-3-远程终端协议-TELNET" class="headerlink" title="6.3 远程终端协议 TELNET"></a>6.3 远程终端协议 TELNET</h2><ul>
<li><p>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。</p>
</li>
<li><p>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</p>
</li>
<li><p>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 </p>
</li>
</ul>
<h4 id="客户服务器方式"><a href="#客户服务器方式" class="headerlink" title="客户服务器方式"></a>客户服务器方式</h4><ul>
<li>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。</li>
<li>TELNET 使用网络虚拟终端 NVT 格式：</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/NVT%E6%A0%BC%E5%BC%8F.png" alt="NVT格式"></p>
<p>客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。</p>
<p>服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。</p>
<p>向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。</p>
<h4 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h4><p>可以使用telnet命令测试某计算机是否开启相应端口的服务，相当于端口扫描工具。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3.png" alt="image-20200812212319131"></p>
<h3 id="6-3-1-远程桌面RDP（Remote-Desktop-Protocol）"><a href="#6-3-1-远程桌面RDP（Remote-Desktop-Protocol）" class="headerlink" title="6.3.1 远程桌面RDP（Remote Desktop Protocol）"></a>6.3.1 远程桌面RDP（Remote Desktop Protocol）</h3><p>通过mstsc客户端远程连接计算机，并对其进行管理等操作。</p>
<p>与TELNET的区别在于，TELNET显示的是远程计算机的命令行窗口，而RDP为该计算机的图形界面，这样显得更加直观。</p>
<p>RDP=TCP+3389端口。</p>
<p>在运行界面输入mstsc，打开远程桌面登录界面，输入相应信息即可连接远程计算机。</p>
<p>Server是多用户操作系统，启用远程桌面可以多用户同时使用服务器。而Window xp和Window7是单用户系统，不能多个用户同时使用。</p>
<h2 id="6-4-万维网-WWW"><a href="#6-4-万维网-WWW" class="headerlink" title="6.4 万维网 WWW"></a>6.4 万维网 WWW</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><ul>
<li><strong>万维网</strong> WWW (World Wide Web)是一个大规模的、联机式的信息储藏所。</li>
<li>万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li>这种访问方式称为“<strong>链接</strong>”。</li>
<li>万维网提供分布式服务：</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E4%B8%87%E7%BB%B4%E7%BD%91%E6%9C%8D%E5%8A%A1.png" alt="万维网服务"></p>
<h4 id="超媒体与超文本"><a href="#超媒体与超文本" class="headerlink" title="超媒体与超文本"></a>超媒体与超文本</h4><ul>
<li>万维网是<strong>分布式超媒体</strong>(hypermedia)系统，它是<strong>超文本</strong>(hypertext)系统的扩充。</li>
<li>一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在因特网上的超文本系统中。超文本是万维网的基础。</li>
<li>超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</li>
</ul>
<h4 id="万维网的工作方式"><a href="#万维网的工作方式" class="headerlink" title="万维网的工作方式"></a>万维网的工作方式</h4><ul>
<li>万维网以<strong>客户服务器</strong>方式工作。</li>
<li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li>
<li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li>
<li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong>(page)。</li>
</ul>
<h4 id="万维网必须解决的问题"><a href="#万维网必须解决的问题" class="headerlink" title="万维网必须解决的问题"></a>万维网必须解决的问题</h4><blockquote>
<p>1.怎样标志分布在整个因特网上的万维网文档？</p>
</blockquote>
<ul>
<li>使用<strong>统一资源定位符</strong> URL (Uniform Resource Locator)来标志万维网上的各种文档。</li>
<li>使每一个文档在整个因特网的范围内具有唯一的标识符 URL。</li>
</ul>
<blockquote>
<p>2.用什么协议实现万维网上各种超链的链接？</p>
</blockquote>
<ul>
<li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li>
<li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送，一般使用80端口。</li>
</ul>
<blockquote>
<p>3.怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？</p>
</blockquote>
<ul>
<li><strong>超文本标记语言</strong> HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。</li>
</ul>
<h3 id="6-4-2-统一资源定位符-URL"><a href="#6-4-2-统一资源定位符-URL" class="headerlink" title="6.4.2 统一资源定位符 URL"></a>6.4.2 统一资源定位符 URL</h3><ul>
<li>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</li>
<li>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</li>
</ul>
<h4 id="URL-的一般形式"><a href="#URL-的一般形式" class="headerlink" title="URL 的一般形式"></a>URL 的一般形式</h4><ul>
<li>由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。</li>
<li>URL 的一般形式是：</li>
</ul>
<p>![URL 的一般形式](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/URL">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/6-应用层/URL</a> 的一般形式.png)</p>
<ul>
<li>“http”——表示使用HTTP协议；</li>
<li>“：//“——冒号和两个左斜杠是规定的格式；</li>
<li>“&lt;主机&gt;”——表示主机的域名；</li>
<li>“&lt;端口&gt;”——HTTP的默认端口号是80，通常可省略；</li>
<li>“&lt;路径&gt;”——表示文件路径，若再省略文件的&lt;路径&gt;项，则 URL 就指到因特网上的某个主页(home page)。</li>
</ul>
<h3 id="6-4-3-超文本传送协议-HTTP"><a href="#6-4-3-超文本传送协议-HTTP" class="headerlink" title="6.4.3 超文本传送协议 HTTP"></a>6.4.3 超文本传送协议 HTTP</h3><h4 id="HTTP-的操作过程"><a href="#HTTP-的操作过程" class="headerlink" title="HTTP 的操作过程"></a>HTTP 的操作过程</h4><ul>
<li>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。</li>
<li>从层次的角度看，HTTP 是<strong>面向事务</strong>的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li>
</ul>
<h4 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h4><p>HTTP 有两类报文：</p>
<ul>
<li>请求报文——从客户向服务器发送请求报文。</li>
<li>响应报文——从服务器到客户的回答。</li>
<li>由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</li>
</ul>
<h4 id="HTTP-请求报文的结构"><a href="#HTTP-请求报文的结构" class="headerlink" title="HTTP 请求报文的结构"></a>HTTP 请求报文的结构</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="HTTP请求报文的结构"></p>
<p>报文由三个部分组成，即<strong>开始行</strong>、<strong>首部行</strong>和<strong>实体主体</strong>。在请求报文中，开始行就是请求行。</p>
<ul>
<li><p><strong>方法</strong>字段——对所请求的对象进行的操作，即一些命令。请求报文的类型是由它所采用的方法决定的；</p>
<blockquote>
<p>HTTP 请求报文的一些方法</p>
</blockquote>
<ul>
<li>OPTION：请求一些选项的信息；</li>
<li>GET：请求读取由 URL所标志的信息；</li>
<li>HEAD：请求读取由 URL所标志的信息的首部；</li>
<li>POST：给服务器添加信息（例如，注释）；</li>
<li>PUT：在指明的 URL下存储一个文档；</li>
<li>DELETE：删除指明的 URL所标志的资源；</li>
<li>TRACE：用来进行环回测试的请求报文；</li>
<li>CONNECT：用于代理服务器；</li>
</ul>
</li>
<li><p><strong>URL</strong>字段——所请求的资源的 URL；</p>
</li>
<li><p><strong>版本</strong>字段——表示 HTTP 的版本；</p>
</li>
</ul>
<h4 id="HTTP-响应报文的结构"><a href="#HTTP-响应报文的结构" class="headerlink" title="HTTP 响应报文的结构"></a>HTTP 响应报文的结构</h4><p>![HTTP 响应报文的结构](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/HTTP">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/6-应用层/HTTP</a> 响应报文的结构.png)</p>
<p>响应报文的开始行是<strong>状态行</strong>。状态行包括三项内容，即 <strong>HTTP 的版本</strong>，<strong>状态码</strong>，以及解释状态码的简单<strong>短语</strong>。</p>
<ul>
<li><p><strong>状态码</strong></p>
<p>状态码都由三个数字组成：</p>
<ul>
<li>1xx 表示通知信息的，如请求收到了或正在进行处理；</li>
<li>2xx 表示成功，如接受或知道了；</li>
<li>3xx 表示重定向，表示要完成请求还必须采取进一步的行动；</li>
<li>4xx 表示客户的差错，如请求中有错误的语法或不能完成；</li>
<li>5xx 表示服务器的差错，如服务器失效无法完成请求；</li>
</ul>
</li>
</ul>
<h4 id="超链接的工作过程"><a href="#超链接的工作过程" class="headerlink" title="超链接的工作过程"></a>超链接的工作过程</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E4%B8%87%E7%BB%B4%E7%BD%91%E6%96%87%E6%A1%A3%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4.png" alt="超链接的工作过程"></p>
<p>用户点击”链接”后所发生的事件 :</p>
<ul>
<li><p>浏览器分析”文本”超链指向页面的 URL；</p>
</li>
<li><p>浏览器向 DNS 请求解析 <a href="http://www.123.edu.cn/">www.123.edu.cn</a> 的 IP 地址；</p>
</li>
<li><p>域名系统 DNS 解析出服务器的 IP 地址；</p>
</li>
<li><p>浏览器与服务器建立 TCP 连接</p>
</li>
<li><p>浏览器发出取文件命令：</p>
<p>GET /chn/yxsz/index.htm。</p>
</li>
<li><p>服务器给出响应，把文件 index.htm 发给浏览器。</p>
</li>
<li><p>TCP 连接释放。</p>
</li>
<li><p>浏览器显示“文本”文件 index.htm 中的所有文本。</p>
</li>
</ul>
<h4 id="请求一个万维网文档所需的时间"><a href="#请求一个万维网文档所需的时间" class="headerlink" title="请求一个万维网文档所需的时间"></a>请求一个万维网文档所需的时间</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="请求一个万维网文档所需的时间"></p>
<p>RTT表示数据包（报文）往返时间。</p>
<h4 id="持续连接-persistent-connection"><a href="#持续连接-persistent-connection" class="headerlink" title="持续连接 (persistent connection)"></a>持续连接 (persistent connection)</h4><ul>
<li>HTTP/1.1 协议使用持续连接。</li>
<li>万维网服务器在发送响应后仍然在一段时间内保持这条TCP连接，使同一个客户（浏览器）和该服务器可以继续在这条TCP连接上传送后续的 HTTP 请求报文和响应报文。</li>
<li>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</li>
</ul>
<h4 id="持续连接的两种工作方式"><a href="#持续连接的两种工作方式" class="headerlink" title="持续连接的两种工作方式"></a>持续连接的两种工作方式</h4><ul>
<li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。与非持续连接相比节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li>
<li><strong>流水线方式</strong>：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li>
</ul>
<h4 id="在服务器上存放用户的信息"><a href="#在服务器上存放用户的信息" class="headerlink" title="在服务器上存放用户的信息"></a>在服务器上存放用户的信息</h4><ul>
<li>万维网站点使用 <strong>Cookie</strong> 来跟踪用户。</li>
<li>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。</li>
<li>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。</li>
</ul>
<h3 id="6-4-4-代理服务器-proxy-server"><a href="#6-4-4-代理服务器-proxy-server" class="headerlink" title="6.4.4 代理服务器 (proxy server)"></a>6.4.4 代理服务器 (proxy server)</h3><ul>
<li><strong>代理服务器</strong>(proxy server)又称为万维网高速缓存(Web cache)，它代替浏览器发出 HTTP 请求；</li>
<li>可以在代理服务器中设置哪些网段的计算机能通过代理服务器上网，能通过代理服务器上什么网；</li>
<li>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中；</li>
<li>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去因特网访问该资源。</li>
</ul>
<h4 id="使用代理服务器的场合"><a href="#使用代理服务器的场合" class="headerlink" title="使用代理服务器的场合"></a>使用代理服务器的场合</h4><blockquote>
<p><strong>1.节省内网访问 Internet 的带宽。</strong></p>
</blockquote>
<p>安装代理服务器前：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%AE%89%E8%A3%85%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E.png" alt="代理服务器；"></p>
<p>内网的所有计算机上网的流量都通过这条2Mb/s的链路，这会造成该链路时延过大。</p>
<p>安装了代理服务器后：</p>
<ul>
<li>浏览器访问因特网的服务器时，要先与校园网的代理服务器建立 TCP 连接，并向代理服务器发出 HTTP 请求报文。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9B.png" alt="安装代理服务器后"></p>
<ul>
<li>若代理服务器已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E4%BD%BF%E7%94%A8%E4%BA%86%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E1.png" alt="使用了代理服务器后1"></p>
<ul>
<li>否则，代理服务器就代表发出请求的用户浏览器，与因特网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E6%BA%90%E7%82%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5.png" alt="代理服务器与源点服务器建立TCP连接"></p>
<ul>
<li>源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的代理服务器。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BB%95%E8%BF%87%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91.png" alt="返回给校园网的代理服务器。"></p>
<ul>
<li>代理服务器收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E8%BF%94%E5%9B%9E%E7%BB%99%E8%AF%B7%E6%B1%82%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8.png" alt="返回给请求该对象的浏览器"></p>
<h4 id="绕过路由器的防火墙访问外网"><a href="#绕过路由器的防火墙访问外网" class="headerlink" title="绕过路由器的防火墙访问外网"></a>绕过路由器的防火墙访问外网</h4><ul>
<li>路由器设置的防火墙会拦截目标地址或源地址为特定地址的数据包。</li>
<li>路由器只识别数据包的源地址和目标地址，不关心数据包内容。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="绕过路由器的防火墙访问外网"></p>
<p>如图所示，在国内的用户PC1想访问国外的某些网站时，路由器收到PC1的请求后，判断出目标地址为国外的某网于是路由器的防火墙截断了该请求，导致PC1无法成功访问；</p>
<p>如果PC1通过国外的代理服务器中转就可以访问外网。PC1发出的请求数据包目标地址为国外某代理服务器，请求数据包到达路由器时，路由器判断出数据包的目标地址不是防火墙设置的屏蔽地址，故能够把数据包传输给国外的代理服务器，代理服务器再把数据包传输给外网的源服务器；从外网返回的数据包通过代理服务器中转之后到达路由器时源地址变为代理服务器地址，故能绕开路由器的防火墙，成功到达PC1；由此PC1能够访问外网。</p>
<p><strong>避免IP地址被跟踪</strong></p>
<p>当我们在网上发表言论时，有时候隐藏个人计算机的IP地址能够带来很大便利。通过代理服务器在网络上进行活动能够有效地防止个人计算机地IP地址被跟踪。</p>
<p>原理为改变数据包地目标地址或源地址，过程与”上2”类似。</p>
<h3 id="6-4-5-浏览器"><a href="#6-4-5-浏览器" class="headerlink" title="6.4.5 浏览器"></a>6.4.5 浏览器</h3><p>浏览器就是在用户计算机上的万维网<strong>客户程序</strong>，相当于客户端。</p>
<h4 id="浏览器的结构"><a href="#浏览器的结构" class="headerlink" title="浏览器的结构"></a>浏览器的结构</h4><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E8%BF%94%E5%9B%9E%E7%BB%99%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82.png" alt="浏览器的结构"></p>
<h4 id="浏览器中的缓存"><a href="#浏览器中的缓存" class="headerlink" title="浏览器中的缓存"></a>浏览器中的缓存</h4><ul>
<li>浏览器将它取回的每一个页面副本都放入本地磁盘的缓存中。</li>
<li>当用户用点击某个超链接时，浏览器首先检查磁盘的缓存。若缓存中保存了超链接的URL指向的文件，浏览器就直接从缓存中得到该文件副本而不必从网络获取，这样就明显地改善浏览器的运行特性。 。</li>
<li>但缓存要占用磁盘大量的空间，而浏览器性能的改善只有在用户再次查看缓存中的页面时才有帮助。许多浏览器允许用户调整缓存策略。</li>
</ul>
<h2 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h2><h3 id="6-5-1-电子邮件概述"><a href="#6-5-1-电子邮件概述" class="headerlink" title="6.5.1 电子邮件概述"></a>6.5.1 电子邮件概述</h3><ul>
<li><strong>电子邮件</strong>(e-mail)是因特网上使用得最多的和最受用户欢迎的一种应用。</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取。</li>
</ul>
<h4 id="1-1-电子邮件使用的协议"><a href="#1-1-电子邮件使用的协议" class="headerlink" title="1.1.电子邮件使用的协议"></a>1.1.电子邮件使用的协议</h4><ul>
<li>发送邮件的协议：<strong>SMTP</strong></li>
<li>读取邮件的协议：<strong>POP3</strong> 和 <strong>IMAP</strong></li>
<li><strong>MIME</strong> 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。</li>
</ul>
<h4 id="1-2-发送电子邮件的过程"><a href="#1-2-发送电子邮件的过程" class="headerlink" title="1.2.发送电子邮件的过程"></a>1.2.发送电子邮件的过程</h4><p>简略图例为：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E5%9B%BE%E4%BE%8B.png" alt="发送电子邮件的过程"></p>
<ul>
<li>如图用户x在qq服务器上注册了邮箱：<a href="mailto:&#120;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#120;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a>；用户y在163服务器上注册了邮箱：<a href="mailto:&#x79;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;">&#x79;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a>；这样qq服务器和163服务器就会分别给用户x和y分配一块空间，称为邮局，地址为他们的邮箱地址。邮局分为收件箱与发件箱。</li>
<li>用户需要在计算机上安装邮件服务器的客户端，比如：Fox mail。用户x使用Fox mail通过身份验证后可登录到个人的邮箱：<a href="mailto:&#120;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;">&#120;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;</a>，并可以下载收件箱中的邮件。</li>
<li>当用户x想发邮件给用户y时，在Fox mail中新建邮件，邮件的目标地址为：<a href="mailto:&#121;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;">&#121;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a>，并放入其发件箱中。随后Fox mail把发件箱中的邮件通过SMTP协议发送到邮局的收件箱中。邮局：<a href="mailto:&#120;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#120;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a>通过DNS服务器查找邮件交换机录找出邮局：<a href="mailto:&#121;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#109;">&#121;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#109;</a>的IP地址，并通过发件箱使用SMTP协议发送到邮局：<a href="mailto:&#x79;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;">&#x79;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a>的收件箱中。最后，用户y使用Fox mail通过身份验证后，使用POP3或IMAP协议从邮局：<a href="mailto:&#121;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;">&#121;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d;</a>的收件箱中下载邮件。由此用户y收到用户x发出的邮件。</li>
</ul>
<p>详细图例为：</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%9F%BA%E4%BA%8E%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6.png" alt="发送电子邮件的过程详细图例"></p>
<ul>
<li>用户代理 UA(User Agent) 就是用户与电子邮件系统的接口，是电子邮件客户端软件（如Fox mail）。</li>
<li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</li>
<li>邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。</li>
<li>一个邮件服务器收信时可作为服务器，发信时可作为客户。</li>
</ul>
<blockquote>
<p><strong>几个重要步骤</strong></p>
</blockquote>
<p>1.发件人调用 PC 机中的用户代理撰写和编辑要发送的邮件。</p>
<p>2.发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，</p>
<p>3.SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</p>
<p>4.发送方邮件服务器通过DNS服务器找到接收方邮件服务器地址后，其 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</p>
<p>5.运行在接收方邮件服务器中的SMTP服务器进 程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。</p>
<p>6.收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。</p>
<p><strong>注意：</strong>POP3 服务器和 POP3 客户之间的通信是由 POP3 客户发起的。</p>
<h4 id="1-3-电子邮件的组成"><a href="#1-3-电子邮件的组成" class="headerlink" title="1.3.电子邮件的组成"></a>1.3.电子邮件的组成</h4><ul>
<li>电子邮件由<strong>信封</strong>(envelope)和<strong>内容</strong>(content)两部分组成。</li>
<li>在邮件的信封上，最重要的就是收件人的地址。</li>
</ul>
<h4 id="1-4-电子邮件地址的格式"><a href="#1-4-电子邮件地址的格式" class="headerlink" title="1.4.电子邮件地址的格式"></a>1.4.电子邮件地址的格式</h4><ul>
<li><p>TCP/IP 体系的电子邮件系统规定电子邮件地址的格式如下：</p>
<p>**收件人邮箱名@邮箱所在主机的域名 **</p>
</li>
<li><p>符号“@”读作“at”，表示“在”的意思。例如：电子邮件地址 <a href="mailto:&#x54;&#x6f;&#109;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#x54;&#x6f;&#109;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;</a> 。”Tom”表示用户名，在该域名范围内是唯一的；qq.com”表示邮箱所在的主机的域名，必须是全世界唯一的。</p>
</li>
</ul>
<h3 id="6-5-2-简单邮件传送协议-SMTP"><a href="#6-5-2-简单邮件传送协议-SMTP" class="headerlink" title="6.5.2 简单邮件传送协议 SMTP"></a>6.5.2 简单邮件传送协议 SMTP</h3><ul>
<li>SMTP 所规定的就是在两个相互通信的 SMTP 进程之间应如何交换信息。</li>
<li>由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。</li>
<li>SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明。</li>
</ul>
<h4 id="2-1-SMTP-通信的三个阶段"><a href="#2-1-SMTP-通信的三个阶段" class="headerlink" title="2.1.SMTP 通信的三个阶段"></a>2.1.SMTP 通信的三个阶段</h4><ol>
<li>连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。</li>
<li>邮件传送</li>
<li>连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。</li>
</ol>
<h3 id="6-5-3-邮件读取协议POP3-和-IMAP"><a href="#6-5-3-邮件读取协议POP3-和-IMAP" class="headerlink" title="6.5.3 邮件读取协议POP3 和 IMAP"></a>6.5.3 邮件读取协议POP3 和 IMAP</h3><h4 id="3-1-POP3协议"><a href="#3-1-POP3协议" class="headerlink" title="3.1.POP3协议"></a>3.1.POP3协议</h4><ul>
<li>邮局协议 POP 是一个非常简单、但功能有限的邮件读取协议，现在使用的是它的第三个版本 POP3。</li>
<li>POP 也使用客户服务器的工作方式。</li>
<li>在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。</li>
</ul>
<h4 id="3-2-IMAP-协议-Internet-Message-Access-Protocol"><a href="#3-2-IMAP-协议-Internet-Message-Access-Protocol" class="headerlink" title="3.2.IMAP 协议 (Internet Message Access Protocol)"></a>3.2.IMAP 协议 (Internet Message Access Protocol)</h4><ul>
<li>IMAP 也是按客户服务器方式工作，现在较新的是版本 4，即 IMAP4。</li>
<li>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。</li>
<li>IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。</li>
</ul>
<h4 id="3-3-IMAP-的特点"><a href="#3-3-IMAP-的特点" class="headerlink" title="3.3.IMAP 的特点"></a>3.3.IMAP 的特点</h4><ul>
<li>IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。</li>
<li>IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。</li>
<li>IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>不要将邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 弄混。</li>
<li>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。</li>
<li>而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。</li>
</ul>
<h3 id="6-5-4-基于万维网的电子邮件"><a href="#6-5-4-基于万维网的电子邮件" class="headerlink" title="6.5.4 基于万维网的电子邮件"></a>6.5.4 基于万维网的电子邮件</h3><p>![基于万维网的电子邮件](<a href="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/MIME">https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/计算机网络/6-应用层/MIME</a> 和 SMTP 的关系 .png)</p>
<ul>
<li><p>电子邮件从 A 发送到网易邮件服务器是使用 HTTP 协议。</p>
</li>
<li><p>两个邮件服务器之间的传送使用 SMTP。</p>
</li>
<li><p>邮件从新浪邮件服务器传送到 B 是使用 HTTP 协议。</p>
<h3 id="6-5-5-通用因特网邮件扩充-MIME"><a href="#6-5-5-通用因特网邮件扩充-MIME" class="headerlink" title="6.5.5 通用因特网邮件扩充 MIME"></a>6.5.5 通用因特网邮件扩充 MIME</h3></li>
</ul>
<blockquote>
<p><strong>MIME 概述</strong></p>
</blockquote>
<p>SMTP 有以下缺点：</p>
<ul>
<li>SMTP 不能传送可执行文件或其他的二进制对象。</li>
<li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。</li>
<li>SMTP 服务器会拒绝超过一定长度的邮件。</li>
<li>某些 SMTP 的实现并没有完全按照[RFC 821]的 SMTP 标准。</li>
</ul>
<blockquote>
<p><strong>MIME 的特点</strong></p>
</blockquote>
<ul>
<li>MIME 并没有改动 SMTP 或取代它。</li>
<li>MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则</li>
</ul>
<p>**MIME 和 SMTP 的关系 **</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-%E5%BA%94%E7%94%A8%E5%B1%82/%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="MIME 和 SMTP 的关系 "></p>
<blockquote>
<p>**MIME 主要包括三个部分 **</p>
</blockquote>
<ul>
<li>5 个新的邮件首部字段，它们可包含在[RFC 822]首部中。这些字段提供了有关邮件主体的信息。</li>
<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
<blockquote>
<p>**MIME 增加 5 个新的邮件首部 **</p>
</blockquote>
<ul>
<li>MIME-Version: 标志 MIME 的版本。现在的版本号是 1.0。若无此行，则为英文文本；</li>
<li>Content-Description: 这是可读字符串，说明此邮件是什么。和邮件的主题差不多；</li>
<li>Content-Id: 邮件的唯一标识符；</li>
<li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的；</li>
<li>Content-Type: 说明邮件的性质；</li>
</ul>
<blockquote>
<p>**MIME的内容传送编码 (Content-Transfer-Encoding) **</p>
</blockquote>
<ul>
<li>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</li>
<li>另一种编码称为 quoted-printable，这种编码方法适用于当所传送的数据中只有少量的非 ASCII 码。</li>
<li>对于任意的二进制文件，可用 base64 编码。</li>
</ul>
<blockquote>
<p>**MIME内容类型 **</p>
</blockquote>
<ul>
<li>MIME的标准规定 Content-Type 说明必须含有两个标识符，即内容类型(type)和子类型(subtype)，中间用“/”分开。</li>
<li>MIME 标准定义了 7 个基本内容类型和 15 种子类型。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>git-commands</title>
    <url>/2022/01/05/Git/git-commands/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    平时自以为 Git 一些比较简单的命令会使用了，就可以熟练的使用版本控制工具了；然而实际上每每遇到问题都要去网上查找解决方案，其中一些命令总是记不住，和小白差不多。因此想学习总结 Git 常用的命令。并通过不断的使用达到孰能生巧的地步。</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰的网络日志-git命令</a></p>
<p><a href="https://git-scm.com/book/zh/v2/">Git 官网</a></p>
<a id="more"></a>

<h2 id="Git-流程原理"><a href="#Git-流程原理" class="headerlink" title="Git 流程原理"></a>Git 流程原理</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="git-bg2015"></p>
<ul>
<li><p>工作目录 workspace ：是本地放代码的地方。</p>
</li>
<li><p>暂存区 index：暂时存放你的修改的代码。</p>
</li>
<li><p>资源库  repository：稳定存放代码的本地区域。</p>
</li>
<li><p>远程仓库 remote ：托管代码的服务器。</p>
</li>
</ul>
<h3 id="git-help-获取帮助"><a href="#git-help-获取帮助" class="headerlink" title="git help 获取帮助"></a>git help 获取帮助</h3><p>第一种如下所示。verb 为命令，通过 git help 可以打开本地的 Git 综合手册。内容全面，就是挺长的，阅读起来可能难找到重点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br></pre></td></tr></table></figure>

<p>第二种我比较推荐的，比较直观的获取命令的各种参数及说明。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git &lt;verb&gt; -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> example</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -h</span></span><br><span class="line">usage: git add [&lt;options&gt;] [--] &lt;pathspec&gt;...</span><br><span class="line"></span><br><span class="line">    -n, --dry-run         dry run</span><br><span class="line">    -v, --verbose         be verbose</span><br><span class="line"></span><br><span class="line">    -i, --interactive     interactive picking</span><br><span class="line">    -p, --patch           select hunks interactively</span><br><span class="line">    -e, --edit            edit current diff and apply</span><br><span class="line">    -f, --force           allow adding otherwise ignored files</span><br><span class="line">    -u, --update          update tracked files</span><br><span class="line">    --renormalize         renormalize EOL of tracked files (implies -u)</span><br><span class="line">    -N, --intent-to-add   record only the fact that the path will be added later</span><br><span class="line">    -A, --all             add changes from all tracked and untracked files</span><br><span class="line">    --ignore-removal      ignore paths removed in the working tree (same as --no-all)</span><br><span class="line">    --refresh             don&#x27;t add, only refresh the index</span><br><span class="line">    --ignore-errors       just skip files which cannot be added because of errors</span><br><span class="line">    --ignore-missing      check if - even missing - files are ignored in dry run</span><br><span class="line">    --sparse              allow updating entries outside of the sparse-checkout cone</span><br><span class="line">    --chmod (+|-)x        override the executable bit of the listed files</span><br><span class="line">    --pathspec-from-file &lt;file&gt;</span><br><span class="line">                          read pathspec from file</span><br><span class="line">    --pathspec-file-nul   with --pathspec-from-file, pathspec elements are separated with NUL character</span><br></pre></td></tr></table></figure>



<h2 id="仓库管理命令"><a href="#仓库管理命令" class="headerlink" title="仓库管理命令"></a>仓库管理命令</h2><h3 id="初始化代码库"><a href="#初始化代码库" class="headerlink" title="初始化代码库"></a>初始化代码库</h3><p>初始化仓库有两种方式，一种是在本地初始化未版本控制的目录。第二种是直接 clone 网上已存在的仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种 在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">git init [project-name]</span><br><span class="line"><span class="comment"># 第二种 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<p>初始化结束后，会在项目目录中生成一个 <code>.git</code> 文件，版本控制的信息基本都在该目录中。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br><span class="line"><span class="comment"># remove  proxy configuration on git 这个使用代理遇到错误时可以用到</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    </span><br></pre></td></tr></table></figure>

<p><code>.gitignore</code> 文件是记录不追踪的文件，在进行项目管理时，忽略对应的文件。</p>
<h3 id="增加、删除文件"><a href="#增加、删除文件" class="headerlink" title="增加、删除文件"></a>增加、删除文件</h3><p>新增和删除文件到暂存区中，命令一般为 <code>git add</code> 和 <code>git rm</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>将代码提交到本地的仓库区域。使用 <code>commit</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"><span class="comment"># 将add和commit合为一步</span></span><br><span class="line">$ git commit -am <span class="string">&#x27;message&#x27;</span></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>代码同步则是指将远程仓库的代码同步到本地仓库代码、本地仓库更新代码推送到远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同步以及推送</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"><span class="comment"># 检出版本v2.0</span></span><br><span class="line">$ git checkout v2.0</span><br><span class="line"><span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">$ git checkout -b devel origin/develop</span><br><span class="line"><span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git checkout -- README </span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init                                                  <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span>                       <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span>              <span class="comment"># 配置邮件</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">&#x27;xxx&#x27;</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">&#x27;xxx&#x27;</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">&#x27;xxx&#x27;</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git rm -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br><span class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></span><br><span class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></span><br><span class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></span><br><span class="line">git tag -a v2.0 -m <span class="string">&#x27;xxx&#x27;</span>                                  <span class="comment"># 增加v2.0的tag</span></span><br><span class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></span><br><span class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></span><br><span class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></span><br><span class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></span><br><span class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></span><br><span class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></span><br><span class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></span><br><span class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></span><br><span class="line">git branch                                                <span class="comment"># 显示本地分支</span></span><br><span class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></span><br><span class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></span><br><span class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></span><br><span class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></span><br><span class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></span><br><span class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></span><br><span class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></span><br><span class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></span><br><span class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></span><br><span class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></span><br><span class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></span><br><span class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></span><br><span class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></span><br><span class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></span><br><span class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></span><br><span class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></span><br><span class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></span><br><span class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></span><br><span class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></span><br><span class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></span><br><span class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933</span></span><br><span class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></span><br><span class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></span><br><span class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></span><br><span class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></span><br><span class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></span><br><span class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></span><br><span class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">&#x27;%h %s&#x27;</span> --graph                   <span class="comment"># 图示提交日志</span></span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></span><br><span class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></span><br><span class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></span><br><span class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></span><br><span class="line">git grep <span class="string">&quot;delete from&quot;</span>                                    <span class="comment"># 文件中搜索文本“delete from”</span></span><br><span class="line">git grep -e <span class="string">&#x27;#define&#x27;</span> --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>



<p>带薪刷题的一小时，然后 leetcode 就崩了， emo了。</p>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202201051747634.png" alt="image-20220105174744794"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
