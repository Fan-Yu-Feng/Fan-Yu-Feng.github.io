<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/tapple-touch-icon-nex.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-sdj.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-sdj.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fan-yu-feng.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="该篇是学习并发编程相关的基础知识 参考 《Java 并发编程的艺术 》 参考博客 万丈高楼平地起，唯有基础扎实才能筑起筑起属于自己的高楼大厦。">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程-基础">
<meta property="og:url" content="https://fan-yu-feng.github.io/2021/08/04/JUC/juc-base/index.html">
<meta property="og:site_name" content="FYF&#39;s Blog">
<meta property="og:description" content="该篇是学习并发编程相关的基础知识 参考 《Java 并发编程的艺术 》 参考博客 万丈高楼平地起，唯有基础扎实才能筑起筑起属于自己的高楼大厦。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111251456953.png">
<meta property="og:image" content="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111261631048.png">
<meta property="article:published_time" content="2021-08-04T09:58:04.000Z">
<meta property="article:modified_time" content="2021-12-24T03:26:59.054Z">
<meta property="article:author" content="FYF">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111251456953.png">


<link rel="canonical" href="https://fan-yu-feng.github.io/2021/08/04/JUC/juc-base/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://fan-yu-feng.github.io/2021/08/04/JUC/juc-base/","path":"2021/08/04/JUC/juc-base/","title":"并发编程-基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>并发编程-基础 | FYF's Blog</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?1f500c78c10b508fc86cbb939f2828aa"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="FYF's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FYF's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E7%8A%B6%E6%80%81%EF%BC%88New%EF%BC%89"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">新建状态（New）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%EF%BC%88Runnable%EF%BC%89"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">就绪状态（Runnable）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%EF%BC%88Running%EF%BC%89"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">运行状态（Running）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%EF%BC%88Blocked%EF%BC%89"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">阻塞状态（Blocked）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">线程死亡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.4.</span> <span class="nav-text">Java 线程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">继承 Thread 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.2.</span> <span class="nav-text">实现 Runnable 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">Callable有返回值线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA"><span class="nav-number">1.4.4.</span> <span class="nav-text">线程池创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable-%E5%92%8C-Callable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.5.</span> <span class="nav-text">Runnable 和 Callable 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.6.</span> <span class="nav-text">线程的 run 和 start 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.7.</span> <span class="nav-text">sleep 和 wait 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">守护线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">并发存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.1.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.2.</span> <span class="nav-text">如何减少上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%BB%E8%A6%81%E6%98%AF%EF%BC%9A"><span class="nav-number">2.3.1.</span> <span class="nav-text">产生死锁的原因主要是：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="nav-number">2.3.2.</span> <span class="nav-text">产生死锁的四个必要条件：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">Java 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">锁的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">3.1.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%92%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">重量级锁和轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">3.1.3.</span> <span class="nav-text">锁升级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">锁的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">3.2.2.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E9%94%81"><span class="nav-number">3.2.4.</span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.2.5.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-number">3.2.6.</span> <span class="nav-text">共享锁和独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.2.7.</span> <span class="nav-text">可重入锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">Java 锁的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronize-%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">3.3.1.</span> <span class="nav-text">Synchronize 同步锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">作用范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">核心组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchnized-%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">synchnized 实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">3.3.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">3.3.3.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphare-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.3.4.</span> <span class="nav-text">Semaphare 信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AtomicInteger-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.5.</span> <span class="nav-text">AtomicInteger 原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">3.4.</span> <span class="nav-text">锁优化</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FYF"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">FYF</p>
  <div class="site-description" itemprop="description">Welcome to my world</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fan-Yu-Feng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fan-Yu-Feng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fan-yu-feng.github.io/2021/08/04/JUC/juc-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.png">
      <meta itemprop="name" content="FYF">
      <meta itemprop="description" content="Welcome to my world">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FYF's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发编程-基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-04 17:58:04" itemprop="dateCreated datePublished" datetime="2021-08-04T17:58:04+08:00">2021-08-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-24 11:26:59" itemprop="dateModified" datetime="2021-12-24T11:26:59+08:00">2021-12-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
    <span id="/2021/08/04/JUC/juc-base/" class="post-meta-item leancloud_visitors" data-flag-title="并发编程-基础" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>该篇是学习并发编程相关的基础知识</p>
<p>参考 《Java 并发编程的艺术 》 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44630656/article/details/119835383">参考博客</a></p>
<p>万丈高楼平地起，唯有基础扎实才能筑起筑起属于自己的高楼大厦。</p>
</blockquote>
<a id="more"></a>

<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线程：线程是 CPU 调度的最小单位也叫轻量级进程（Light  Weight  Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。  </p>
<p>进程：进程是程序的一次执行过程，是 CPU 资源分配的最小单位，每个进程都有自己的独立空间，一个进程可以有多个线程。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>根本区别：进程是操作系统资源分配的基本单位。线程是处理器任务调度和执行的基本单位</li>
<li>资源开销：每个进程都有独立的代码和数据空间。程序之间的切换有比较大的开销。线程可以看做是轻量级的进程，同一类线程共享堆和方法区，每个线程有自己的程序计数器、虚拟机栈、本地方法栈，线程之间切换开销比较小。</li>
<li>包含关系：一般一个进程内有多个线程，执行过程不是一条线的，而是由多个线程共同完成；线程是进程的一部分，所以被称为轻量级进程</li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃可能导致整个进程都死掉。所以多进程要比多线程健壮。</li>
</ul>
<p><strong>并行和并发有什么区别？</strong></p>
<ul>
<li>并行是指两个或者多个事件在<strong>同一时刻发生</strong></li>
<li>并发是指两个或多个事件在<strong>同一时间间隔发生</strong></li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>当线程创建后，并不是启动就进入执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocaked）和死亡（Dead）5种状态。尤其是当线程启动后，不能一直独占 CPU，CPU 需要在多线程之间切换，于是线程会在运行、阻塞之间切换。</p>
<h5 id="新建状态（New）"><a href="#新建状态（New）" class="headerlink" title="新建状态（New）"></a>新建状态（New）</h5><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，虚拟机为其分配内存，并初始化成员变量的值。</p>
<h5 id="就绪状态（Runnable）"><a href="#就绪状态（Runnable）" class="headerlink" title="就绪状态（Runnable）"></a>就绪状态（Runnable）</h5><p>当调用了线程的 start 方法后，该线程处于就绪状态，Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h5 id="运行状态（Running）"><a href="#运行状态（Running）" class="headerlink" title="运行状态（Running）"></a>运行状态（Running）</h5><p>如果处于就绪状态的线程获得了 CPU 分配时间，开始执行 run 方法中的线程执行体，则该线程处于运行状态。</p>
<h5 id="阻塞状态（Blocked）"><a href="#阻塞状态（Blocked）" class="headerlink" title="阻塞状态（Blocked）"></a>阻塞状态（Blocked）</h5><p>阻塞状态是指线程因为某种原因放弃了 CPU 的使用权，让出 CPU 时间片，暂停停止运行，知道线程进入到就绪（Runnable）状态，才有机会再次获得时间片进入运行状态。阻塞的情况分为三种：</p>
<ul>
<li>等待阻塞（0.wait -&gt; 等待队列）：运行中的线程执行 o.wait 方法，JVM 会把线程放入等待队列中</li>
<li>同步阻塞（lock-&gt; 锁池）：运行中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中（ lock pool）</li>
<li>其他阻塞（sleep、Join）：运行中的线程执行 Thread.sleep(long ms) 或 t.join()方法，或者发出了 I/O 请求时，JVM 会把线程置为阻塞状态，当 sleep() 方法超时，join() 等待线程终止或者超时，或者 I/O 处理完毕时，线程重新转入可运行状态。</li>
</ul>
<h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以下面三种方式结束，结束后就是死亡状态</p>
<ul>
<li>正常结束：run() 或 call() 方法执行完成，线程正常结束。</li>
<li>异常结束：线程抛出一个未捕获的 Exception 或 Error。</li>
<li>调用 stop: 直接调用 stop 方法来结束线程，该方法容易导致死锁。</li>
</ul>
<p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111251456953.png" alt="image-20211125145627824"></p>
<h3 id="Java-线程的创建"><a href="#Java-线程的创建" class="headerlink" title="Java 线程的创建"></a>Java 线程的创建</h3><p>创建线程的方式有很多种，主要有以下四种，代码实现多种多样，我只列举我的仅供参考。</p>
<h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>Thread 类本质上是实现了 Runnable 接口的一个实例。代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法调用了 native 方法，它将启动一个新线程，并执行 run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        threadDemo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// start 方法调用的 native 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>如果一个类已经继承了其他的类，那么就无法继承 Thread 接口，此时可以实现 Runnable 接口，重写其中的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">otherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(threadDemo,<span class="string">&quot;thread&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="Callable有返回值线程"><a href="#Callable有返回值线程" class="headerlink" title="Callable有返回值线程"></a>Callable<Class>有返回值线程</h4><p>有返回值的任务必须实现 Callable 接口，执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;   执行callable的call方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建callable对象</span></span><br><span class="line">        Callable&lt;String&gt; myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 2.由上面的callable对象创建一个FutureTask对象</span></span><br><span class="line">        FutureTask&lt;String&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(myCallable);</span><br><span class="line">        <span class="comment">// 3.由FutureTask创建一个Thread对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line">        <span class="comment">// 4.开启线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 提交多个线程任务，并执行</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running ..&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable-和-Callable-的区别"><a href="#Runnable-和-Callable-的区别" class="headerlink" title="Runnable 和 Callable 的区别"></a>Runnable 和 Callable 的区别</h4><p>相同点：都是接口、可以编写多线程程序且都才用 Thread.start() 启动线程。</p>
<p>区别：Runnable 接口的 run 方法无返回值；Callable 的 call 方法有返回值，且支持返回泛型，允许抛出异常，返回的结果支持 Furture 的 get 方法异步获取结果。</p>
<h4 id="线程的-run-和-start-的区别"><a href="#线程的-run-和-start-的区别" class="headerlink" title="线程的 run 和 start 的区别"></a>线程的 run 和 start 的区别</h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 多次调用会抛出 java.lang.IllegalThreadStateException 异常</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h4 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep 和 wait 的区别"></a>sleep 和 wait 的区别</h4><ol>
<li>sleep 属于 Thread 中的，wait 属于 Object 类中的，</li>
<li>sleep 方法导致程序暂停指定时间，让出 CPU 给其他线程，但是他的监控状态依然保持着，当指定时间结束又会恢复到运行状态。</li>
<li>当调用 sleep 方法的过程中，线程不会释放对象锁。</li>
<li>当调用 wait 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象的调用 notify 方法后，本线程才进入对象锁池准备获取对象锁进入运行状态。</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>守护线程是 Java 的后台线程，也称为“服务线程”，为用户线程提供公共服务。在没有用户线程可服务时，会自动离开。</p>
</li>
<li><p>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</p>
</li>
<li><p>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程</p>
</li>
</ol>
<p>的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。</p>
<ol start="4">
<li><p>在 Daemon 线程中产生的新线程也是 Daemon 的。</p>
</li>
<li><p>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。</p>
</li>
<li><p>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p>
</li>
<li><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 </p>
</li>
</ol>
<h2 id="并发存在的问题"><a href="#并发存在的问题" class="headerlink" title="并发存在的问题"></a>并发存在的问题</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>多线程执行代码，避免不了线程之间的上下文切换。CPU 通过给每个线程分配 CPU 时间片来实现多线程执行代码，而时间片非常短，所以 CPU 通过不停的切换线程执行，让我们感觉到多个线程是同步执行的。</p>
<p>在线程切换前会保存上一个任务的状态，这个信息由线程的 PC、虚拟机栈等私有内存。因此在每次切换线程都需要保存上一个任务的信息以及读取下一个任务的状态，是影响 CPU 的效率和多线程的执行速度的。</p>
<p>使用多线程可能会带来内存泄漏、死锁、线程不安全等等问题，这些都是需要去解决的。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。 </p>
<ul>
<li><p>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。 </p>
</li>
<li><p>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。 </p>
</li>
<li><p>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这 样会造成大量线程都处于等待状态。 </p>
</li>
<li><p>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>
<h4 id="产生死锁的原因主要是："><a href="#产生死锁的原因主要是：" class="headerlink" title="产生死锁的原因主要是："></a>产生死锁的原因主要是：</h4><p>（1） 因为系统资源不足。</p>
<p>（2） 进程运行推进的顺序不合适。</p>
<p>（3） 资源分配不当等。</p>
<p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p>
<h4 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h4><p>（1） 互斥条件：一个资源每次只能被一个进程使用。</p>
<p>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>锁的状态共有4种，无锁状态、偏向锁、轻量级锁和重量级锁。将锁进一步的细化，有助于提升程序并发性能。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，。<strong>偏向锁的目的是在某个线程获得锁之后，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</strong>（该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁，而只需简单的测试一下对象头的 Mark Word（对象头的一个标志） 里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 CAS 竞争锁，如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</p>
<p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语， 进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互 斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。 </p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线 程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需 要再进行同步。 </p>
<p>（摘自 《深入理解 Java 虚拟机》）</p>
<h4 id="重量级锁和轻量级锁"><a href="#重量级锁和轻量级锁" class="headerlink" title="重量级锁和轻量级锁"></a>重量级锁和轻量级锁</h4><p><strong>轻量级锁</strong></p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是<strong>线程交替执行同步块</strong>的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀（<strong>互斥</strong>）。为重量级锁。轻量级锁是通过 虚拟机中栈帧标志位 Lock Record 实现的，具体参考《深入Java虚拟机》13章锁优化。而传统的重量级锁使用到了操作系统的互斥变量来实现，消耗资源比较大。</p>
<p><strong>重量级锁（Mutex Lock）</strong></p>
<p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，<strong>这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。</strong>JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁（锁升级的方式是单向的，不会出现降级的情况），这个问题也困扰了我一段时间，尤其是锁是在什么时候会升级。</p>
<p>可以将偏向锁、轻量级锁认为是乐观锁，重量级锁是悲观锁，以下是我对锁升级的理解</p>
<ol>
<li>在一个对象实例化后，如果没有线程访问这个对象时，首先锁会偏向于第一个获取它的线程，如果在接下来的执行过程中，没有其他线程竞争该锁，那么就偏向第一个线程；则这个线程修改对象头称为偏向锁的标志使用 CAS 操作，将对象头的 ID 改成这个线程ID，之后访问该对象的时候，只需要比较线程ID，而不需要进行 CAS 操作。</li>
<li>一旦有第二个线程来访问该锁，第二个锁会查看该锁的偏向状态，检查原来持有该偏向锁的线程的状态。<ol>
<li>如果第一个线程挂了，那么该对象为无锁状态，重新偏向新的线程</li>
<li>如果第一个线程依然存活，则检查该线程的操作栈，<strong>检查其是否继续持有偏向锁，如果持有则升级为轻量级锁</strong>，如果不持有则重新偏向。</li>
<li>轻量级锁认为竞争存在，但是很低，对一个锁的操作会错开或者说可以通过自旋锁的操作进行等待一阵子，另一个锁就会释放锁。该锁就为轻量级锁。</li>
</ol>
</li>
<li>如果<strong>线程自旋超过一定时间，或者此时一个线程在持有轻量级锁、另一个在自旋操作，又有第三个线程来访时</strong>，那么轻量级锁就会膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li>
</ol>
<h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>乐观锁是一种乐观思想，任务<strong>读多写少</strong>，遇到并发写的可能性很低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>（比较跟上一次的版本号，如果一样更新，如果不一样则要重复读-比较-写的操作）。</p>
<p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<p>悲观锁的思想则和乐观锁的思想相反，为悲观思想，认为写多读少，遇到并发写的可能性高，每次去拿数据的时候认为别人都会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁，Java 悲观锁就是 Synchronized，AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转化为悲观锁，如 RetreenLock。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁则是表示如果持有锁的线程在很短的时间内释放资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只需要等一等（自旋），等待有锁的线程释放锁后既可立即获得锁。这样就避免了用户线程和内核之间的切换。</p>
<p>线程自旋是需要消耗 CPU 的，说白了就是让 CPU 在做无用功，如果一直获取不到锁，那线程也不能一直占用 CPU 自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>公平锁：加锁钱检查是否有排队等待的线程，优先排队等待的线程，先来先得</p>
<p>非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</p>
<ul>
<li>非公平锁性能比公平锁搞 5~10倍，因为公平锁需要在多核的情况下维护一个队列。</li>
<li>Java 中的 synchronized 是非公平锁。ReentrantLock 默认的 lock() 方法采用的是非公平锁。</li>
</ul>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>分段锁也是一种锁的思想，意为将数据分段上锁。</p>
<p>具体应用如下：HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是 ConcurrentHashMap 所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<p><strong>读锁</strong></p>
<p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<p><strong>写锁</strong></p>
<p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁</p>
<p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。</p>
<p>读写锁可参考《现代操作系统》中的PV操作-读者写者问题。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_40701582/article/details/106729215">参考</a></p>
<h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>Java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p><strong>独占锁</strong></p>
<p>独占锁模式下，每次只能有一个线程持有锁，ReentrantLock 就是以独占的方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他的读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p><strong>共享锁</strong></p>
<p>共享锁则允许多个线程同时获取锁，并发访问共享资源，如 ReadWriteLock，共享锁则是一种乐观锁，放宽了加锁政策，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</li>
<li>Java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源被多个读操作一起访问或者一个写操作访问，但是两者不能同时进行。</li>
</ol>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。<strong>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，,但不受影响，简单来说就是可以重复获取同一把锁。</strong>在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<p>java线程是基于“每线程（per-thread）”，而不是基于“每调用的（per-invocation）”的，也就是说java为每个线程分配一个锁，而不是为每次调用分配一个锁。最大的作用是避免死锁。在很多情况下线程需要多次进入锁内执行任务。</p>
<h3 id="Java-锁的使用"><a href="#Java-锁的使用" class="headerlink" title="Java 锁的使用"></a>Java 锁的使用</h3><h4 id="Synchronize-同步锁"><a href="#Synchronize-同步锁" class="headerlink" title="Synchronize 同步锁"></a>Synchronize 同步锁</h4><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><ol>
<li>实例方法：作用于方法时，锁住的是对象的实例(this)。</li>
<li>静态方法：作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据都存在永久代 PermGen 中（jdk1.8之后则是 metaspace ），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程</li>
<li>同步代码块：作用于一个实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储到不同的容器中。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://m.imooc.com/wiki/concurrencylesson-synchronized">Synchronized 作用范围详解参考</a></p>
<h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><ol>
<li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<h5 id="synchnized-实现"><a href="#synchnized-实现" class="headerlink" title="synchnized 实现"></a>synchnized 实现</h5><p><img src="https://gitee.com/Fan_Yu_Feng/blogImage/raw/master/hexo/202111261631048.png" alt="这里写图片描述"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p>
</li>
<li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify。</p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p>
</li>
<li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</p>
</li>
<li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p>
</li>
<li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p>
</li>
<li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:UseBiasedLocking 来禁用偏向锁。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqz_zqz/article/details/70233767">锁实现参考</a></p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="Semaphare-信号量"><a href="#Semaphare-信号量" class="headerlink" title="Semaphare 信号量"></a>Semaphare 信号量</h4><h4 id="AtomicInteger-原子操作"><a href="#AtomicInteger-原子操作" class="headerlink" title="AtomicInteger 原子操作"></a>AtomicInteger 原子操作</h4><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/17/Linux/Linux%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" rel="prev" title="Linux集群搭建">
                  <i class="fa fa-chevron-left"></i> Linux集群搭建
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/19/Linux/Linux-%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/" rel="next" title="Linux-日志查看">
                  Linux-日志查看 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FYF</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">131k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"FwWV7XdhRzlX8OMOb0AmQS2D-gzGzoHsz","app_key":"vDwqKC2MlntliNMY3zc5XMCF","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Fan-Yu-Feng","repo":"Fan-Yu-Feng.github.io","client_id":"dbe041ce2e296f608913","client_secret":"075de71ff4ed44779fe6334462893050f3109ed5","admin_user":"Fan-Yu-Feng","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"04557bb8963a8ec69b7a13fbf5622bcc"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
